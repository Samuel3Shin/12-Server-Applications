/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 27);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(14);
} else {
  module.exports = __webpack_require__(13);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}();

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object') {
            if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || (typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && (typeof targetItem === 'undefined' ? 'undefined' : _typeof(targetItem)) === 'object' && item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function decode(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if ((typeof str === 'undefined' ? 'undefined' : _typeof(str)) === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (c === 0x2D // -
        || c === 0x2E // .
        || c === 0x5F // _
        || c === 0x7E // ~
        || c >= 0x30 && c <= 0x39 // 0-9
        || c >= 0x41 && c <= 0x5A // a-z
        || c >= 0x61 && c <= 0x7A // A-Z
        ) {
                out += string.charAt(i);
                continue;
            }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
        out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(18);
} else {
  module.exports = __webpack_require__(17);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }return _typeof(obj);
}

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var util = __webpack_require__(3);

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = util.assign({
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function RFC1738(value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function RFC3986(value) {
            return String(value);
        }
    }
}, Format);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(12);
} else {
  module.exports = __webpack_require__(11);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }return _typeof(obj);
}

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self === 'undefined') {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
} else {
  // Web Worker
  root = self;
}

var Emitter = __webpack_require__(9);

var safeStringify = __webpack_require__(10);

var qs = __webpack_require__(24);

var RequestBase = __webpack_require__(21);

var isObject = __webpack_require__(5);

var ResponseBase = __webpack_require__(22);

var Agent = __webpack_require__(20);
/**
 * Noop.
 */

function noop() {}
/**
 * Expose `request`.
 */

module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports = module.exports;
var request = exports;
exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || root.location.protocol !== 'file:' || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  }

  try {
    return new ActiveXObject('Microsoft.XMLHTTP');
  } catch (_unused) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.6.0');
  } catch (_unused2) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.3.0');
  } catch (_unused3) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP');
  } catch (_unused4) {}

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val === undefined) return;

  if (val === null) {
    pairs.push(encodeURI(key));
    return;
  }

  if (Array.isArray(val)) {
    val.forEach(function (v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  } else if (isObject(val)) {
    for (var subkey in val) {
      if (Object.prototype.hasOwnProperty.call(val, subkey)) pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
    }
  } else {
    pairs.push(encodeURI(key) + '=' + encodeURIComponent(val));
  }
}
/**
 * Expose serialization method.
 */

request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos === -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */

request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': qs.stringify,
  'application/json': safeStringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return (/[/+]json($|[^-\w])/i.test(mime)
  );
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method !== 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  this.header = this.headers; // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method === 'HEAD' ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
} // eslint-disable-next-line new-cap


ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */

request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (err_) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = err_; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || res.text || 'Unsuccessful HTTP response');
      }
    } catch (err_) {
      new_err = err_; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */
// eslint-disable-next-line new-cap


Emitter(Request.prototype); // eslint-disable-next-line new-cap

RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function (val) {
  if (typeof val !== 'string') val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
};

Request.prototype.ca = Request.prototype.agent;
Request.prototype.buffer = Request.prototype.ca; // This throws, because it can't send/receive data as expected

Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};

Request.prototype.pipe = Request.prototype.write;
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */

Request.prototype._isHost = function (obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._setUploadTimeout = function () {
  var self = this; // upload timeout it's wokrs only if deadline timeout is off

  if (this._uploadTimeout && !this._uploadTimeoutTimer) {
    this._uploadTimeoutTimer = setTimeout(function () {
      self._timeoutError('Upload timeout of ', self._uploadTimeout, 'ETIMEDOUT');
    }, this._uploadTimeout);
  }
}; // eslint-disable-next-line complexity


Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  this.xhr = request.getXHR();
  var xhr = this.xhr;
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState !== 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (_unused5) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;

      if (e.percent === 100) {
        clearTimeout(self._uploadTimeoutTimer);
      }
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (_unused6) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  if (xhr.upload) {
    this._setUploadTimeout();
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method !== 'GET' && this.method !== 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] === null) continue;
    if (Object.prototype.hasOwnProperty.call(this.header, field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data === 'undefined' ? null : data);
};

request.agent = function () {
  return new Agent();
};

['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE'].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function (url, data, fn) {
  var req = request('HEAD', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request.del = del;
request.delete = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function (url, data, fn) {
  var req = request('POST', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function (url, data, fn) {
  var req = request('PUT', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;

var arr = [];
var replacerStack = [];

// Regular stringify
function stringify(obj, replacer, spacer) {
  decirc(obj, '', [], undefined);
  var res;
  if (replacerStack.length === 0) {
    res = JSON.stringify(obj, replacer, spacer);
  } else {
    res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
  }
  while (arr.length !== 0) {
    var part = arr.pop();
    if (part.length === 4) {
      Object.defineProperty(part[0], part[1], part[3]);
    } else {
      part[0][part[1]] = part[2];
    }
  }
  return res;
}
function decirc(val, k, stack, parent) {
  var i;
  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
        if (propertyDescriptor.get !== undefined) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: '[Circular]' });
            arr.push([parent, k, val, propertyDescriptor]);
          } else {
            replacerStack.push([val, k]);
          }
        } else {
          parent[k] = '[Circular]';
          arr.push([parent, k, val]);
        }
        return;
      }
    }
    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, stack, val);
      }
    }
    stack.pop();
  }
}

// Stable-stringify
function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

function deterministicStringify(obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj;
  var res;
  if (replacerStack.length === 0) {
    res = JSON.stringify(tmp, replacer, spacer);
  } else {
    res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
  }
  while (arr.length !== 0) {
    var part = arr.pop();
    if (part.length === 4) {
      Object.defineProperty(part[0], part[1], part[3]);
    } else {
      part[0][part[1]] = part[2];
    }
  }
  return res;
}

function deterministicDecirc(val, k, stack, parent) {
  var i;
  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
        if (propertyDescriptor.get !== undefined) {
          if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, { value: '[Circular]' });
            arr.push([parent, k, val, propertyDescriptor]);
          } else {
            replacerStack.push([val, k]);
          }
        } else {
          parent[k] = '[Circular]';
          arr.push([parent, k, val]);
        }
        return;
      }
    }
    if (typeof val.toJSON === 'function') {
      return;
    }
    stack.push(val);
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val);
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, stack, val);
        tmp[key] = val[key];
      }
      if (parent !== undefined) {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as [Circular]
function replaceGetterValues(replacer) {
  replacer = replacer !== undefined ? replacer : function (k, v) {
    return v;
  };
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = '[Circular]';
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v17.0.1
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(2);var _assign=__webpack_require__(1);var Scheduler=__webpack_require__(4);var tracing=__webpack_require__(19);var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.
function warn(format){{for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}function printWarning(level,format,args){// When changing this logic, you might want to also
// update consoleWithStackDev.www.js as well.
{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}var argsWithFormat=args.map(function(item){return''+item;});// Careful: RN currently depends on this prefix
argsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it
// breaks IE9: https://github.com/facebook/react/issues/13610
// eslint-disable-next-line react-internal/no-production-logging
Function.prototype.apply.call(console[level],console,argsWithFormat);}}if(!React){{throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class
var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var FundamentalComponent=20;var ScopeComponent=21;var Block=22;var OffscreenComponent=23;var LegacyHiddenComponent=24;// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
var enableProfilerTimer=true;// Record durations for commit and passive effects phases.
var enableFundamentalAPI=false;// Experimental Scope support.
var enableNewReconciler=false;// Errors that are thrown while unmounting (or after in the case of passive effects)
var warnAboutStringRefs=false;var allNativeEvents=new Set();/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
function registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED=0;// A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.
var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING=2;// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here
case'symbol':// eslint-disable-line
return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
var reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML boolean attributes.
['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture','download'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be positive numbers.
['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be numbers.
['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.
['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,null,// attributeNamespace
false,// sanitizeURL
false);});// String SVG attributes with the xlink namespace.
['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL
false);});// String SVG attributes with the xml namespace.
['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL
false);});// These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.
var xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty
'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL
false);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
true,// sanitizeURL
true);});// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space
/* eslint-disable max-len */var isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if
// the hydration is successful of a javascript: URL, we
// still want to warn on the client.
sanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}// If the object is an opaque reference ID, it's expected that
// the next prop is different than the server value, so just return
// expected
if(isOpaqueHydratingObject(expected)){return expected;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.
if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink
// and we won't require Trusted Type here.
attributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
{attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE=0xeac7;var REACT_PORTAL_TYPE=0xeaca;var REACT_FRAGMENT_TYPE=0xeacb;var REACT_STRICT_MODE_TYPE=0xeacc;var REACT_PROFILER_TYPE=0xead2;var REACT_PROVIDER_TYPE=0xeacd;var REACT_CONTEXT_TYPE=0xeace;var REACT_FORWARD_REF_TYPE=0xead0;var REACT_SUSPENSE_TYPE=0xead1;var REACT_SUSPENSE_LIST_TYPE=0xead8;var REACT_MEMO_TYPE=0xead3;var REACT_LAZY_TYPE=0xead4;var REACT_BLOCK_TYPE=0xead9;var REACT_SERVER_BLOCK_TYPE=0xeada;var REACT_FUNDAMENTAL_TYPE=0xead5;var REACT_SCOPE_TYPE=0xead7;var REACT_OPAQUE_ID_TYPE=0xeae0;var REACT_DEBUG_TRACING_MODE_TYPE=0xeae1;var REACT_OFFSCREEN_TYPE=0xeae2;var REACT_LEGACY_HIDDEN_TYPE=0xeae3;if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;REACT_ELEMENT_TYPE=symbolFor('react.element');REACT_PORTAL_TYPE=symbolFor('react.portal');REACT_FRAGMENT_TYPE=symbolFor('react.fragment');REACT_STRICT_MODE_TYPE=symbolFor('react.strict_mode');REACT_PROFILER_TYPE=symbolFor('react.profiler');REACT_PROVIDER_TYPE=symbolFor('react.provider');REACT_CONTEXT_TYPE=symbolFor('react.context');REACT_FORWARD_REF_TYPE=symbolFor('react.forward_ref');REACT_SUSPENSE_TYPE=symbolFor('react.suspense');REACT_SUSPENSE_LIST_TYPE=symbolFor('react.suspense_list');REACT_MEMO_TYPE=symbolFor('react.memo');REACT_LAZY_TYPE=symbolFor('react.lazy');REACT_BLOCK_TYPE=symbolFor('react.block');REACT_SERVER_BLOCK_TYPE=symbolFor('react.server.block');REACT_FUNDAMENTAL_TYPE=symbolFor('react.fundamental');REACT_SCOPE_TYPE=symbolFor('react.scope');REACT_OPAQUE_ID_TYPE=symbolFor('react.opaque.id');REACT_DEBUG_TRACING_MODE_TYPE=symbolFor('react.debug_trace_mode');REACT_OFFSCREEN_TYPE=symbolFor('react.offscreen');REACT_LEGACY_HIDDEN_TYPE=symbolFor('react.legacy_hidden');}var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||(typeof maybeIterable==='undefined'?'undefined':_typeof(maybeIterable))!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099
var props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{log:_assign({},props,{value:prevLog}),info:_assign({},props,{value:prevInfo}),warn:_assign({},props,{value:prevWarn}),error:_assign({},props,{value:prevError}),group:_assign({},props,{value:prevGroup}),groupCollapsed:_assign({},props,{value:prevGroupCollapsed}),groupEnd:_assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.
try{throw Error();}catch(x){var match=x.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.
return'\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.
if(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.
Error.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function
// for warnings.
ReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.
if(construct){// Something should be setting the props in the constructor.
var Fake=function Fake(){throw Error();};// $FlowFixMe
Object.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props
// because that won't throw in a non-strict mode function.
throw Error();}});if((typeof Reflect==='undefined'?'undefined':_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra
// frames added by the construct call.
try{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.
if(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.
// Skipping one frame that we assume is the frame that calls the two.
var sampleLines=sample.stack.split('\n');var controlLines=control.stack.split('\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.
// Typically this will be the root most one. However, stack frames may be
// cut off due to maximum stack limits. In this case, one maybe cut off
// earlier than the other. We assume that the sample is longer or the same
// and there for cut off earlier. So we should find the root most frame in
// the sample somewhere in the control.
c--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the
// frame that called our sample function and the control.
if(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.
// If we're about to return the first line, and the control is also on the same
// line, that's a pretty good indicator that our sample threw at same line as
// the control. I.e. before we entered the sample frame. So we ignore this result.
// This can happen if you passed a class to function component, or non-function.
if(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.
// The next one that isn't the same should be our match though.
if(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
var _frame='\n'+sampleLines[s].replace(' at new ',' at ');{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.
return _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.
var name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if((typeof type==='undefined'?'undefined':_typeof(type))==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_BLOCK_TYPE:return describeFunctionComponentFrame(type._render);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case Block:return describeFunctionComponentFrame(fiber.type._render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return'\nError generating stack: '+x.message+'\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+"("+functionName+")":wrapperName);}function getContextName(type){return type.displayName||'Context';}function getComponentName(type){if(type==null){// Host root, text node or just invalid type.
return null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentName(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if((typeof type==='undefined'?'undefined':_typeof(type))==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:return getComponentName(type.type);case REACT_BLOCK_TYPE:return getComponentName(type._render);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentName(init(payload));}catch(x){return null;}}}}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner.type);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function setIsRendering(rendering){{isRendering=rendering;}}function getIsRendering(){{return isRendering;}}// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value){return''+value;}function getToStringValue(value){switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':case'number':case'object':case'string':case'undefined':return value;default:// function, symbol are assigned as empty strings
return'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time
// but it triggers a bug in IE11 and Edge 14/15.
// Calling defineProperty() again should be equivalent.
// https://github.com/facebook/react/issues/11768
Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=_assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
// eslint-disable-next-line
node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
// blank-text buttons.
node.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of
// properties:
//  1. The value React property
//  2. The defaultValue React property
//  3. Otherwise there should be no change
if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs
// to be removed, such as transitioning from a checkbox into a text input
if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
// default value provided by the browser. See: #12872
if(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(!isHydrating){{// When syncing the value attribute, the value property should use
// the wrapperState._initialValue property. This uses:
//
//   1. The value React property when present
//   2. The defaultValue React property when present
//   3. An empty string
if(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,
// so we assign defaultValue to the same thing as the value property
// assignment step above.
node.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and
// attribute are assigned at the same time using defaultChecked. This uses:
//
//   1. The checked React property when present
//   2. The defaultChecked React property when present
//   3. Otherwise, false
node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){{throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");}}// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
type!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;function flattenChildren(children){var content='';// Flatten children. We'll warn if they are invalid
// during validateProps() which runs for hydration too.
// Note that this would throw on non-element objects.
// Elements are stringified (which is normally irrelevant
// but matters for <fbt>).
React.Children.forEach(children,function(child){if(child==null){return;}content+=child;// Note: we don't warn about invalid children here.
// Instead, this is done separately below so that
// it happens during the hydration code path too.
});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){{// This mirrors the code path above, but runs for hydration too.
// Warn about invalid children here so that client and hydration are consistent.
// TODO: this seems like it could cause a DEV-only throw for hydration
// if children contains a non-element object. We should try to avoid that.
if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(typeof child.type!=='string'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Only strings and numbers are supported as <option> children.');}});}// TODO: Remove support for `selected` in <option>.
if(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;if(!(props.dangerouslySetInnerHTML==null)){{throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");}}// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(!(defaultValue==null)){{throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");}}if(Array.isArray(children)){if(!(children.length<=1)){{throw Error("<textarea> can only have at most one child.");}}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===Namespaces.svg){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
// is converted to lowercase `ms`.
camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error("Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+"avoid this, don't mix shorthand and non-shorthand properties "+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
};// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){if(!(props.children==null&&props.dangerouslySetInnerHTML==null)){{throw Error(tag+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");}}}if(props.dangerouslySetInnerHTML!=null){if(!(props.children==null)){{throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");}}if(!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML in props.dangerouslySetInnerHTML)){{throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");}}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(!(props.style==null||_typeof(props.style)==='object')){{throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");}}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this list too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty$1=Object.prototype.hasOwnProperty;function validateProperty(tagName,name){{if(hasOwnProperty$1.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var _hasOwnProperty=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(_hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value==='undefined'?'undefined':_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
error('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;var IS_REPLAYED=1<<4;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.
var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
// https://github.com/facebook/react/issues/12506
var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}if(!(typeof restoreImpl==='function')){{throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");}}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.
if(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var discreteUpdatesImpl=function discreteUpdatesImpl(fn,a,b,c,d){return fn(a,b,c,d);};var flushDiscreteUpdatesImpl=function flushDiscreteUpdatesImpl(){};var batchedEventUpdatesImpl=batchedUpdatesImpl;var isInsideEventHandler=false;var isBatchingEventUpdates=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
// the DOM node back to the controlled value. This is necessary when React
// bails out of the update without touching the DOM.
flushDiscreteUpdatesImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,bookkeeping){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(bookkeeping);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,bookkeeping);}finally{isInsideEventHandler=false;finishEventHandler();}}function batchedEventUpdates(fn,a,b){if(isBatchingEventUpdates){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(a,b);}isBatchingEventUpdates=true;try{return batchedEventUpdatesImpl(fn,a,b);}finally{isBatchingEventUpdates=false;finishEventHandler();}}function discreteUpdates(fn,a,b,c,d){var prevIsInsideEventHandler=isInsideEventHandler;isInsideEventHandler=true;try{return discreteUpdatesImpl(fn,a,b,c,d);}finally{isInsideEventHandler=prevIsInsideEventHandler;if(!isInsideEventHandler){finishEventHandler();}}}function flushDiscreteUpdatesIfNeeded(timeStamp){{if(!isInsideEventHandler){flushDiscreteUpdatesImpl();}}}function setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushDiscreteUpdatesImpl,_batchedEventUpdatesImpl){batchedUpdatesImpl=_batchedUpdatesImpl;discreteUpdatesImpl=_discreteUpdatesImpl;flushDiscreteUpdatesImpl=_flushDiscreteUpdatesImpl;batchedEventUpdatesImpl=_batchedEventUpdatesImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.
return null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(!(!listener||typeof listener==='function')){{throw Error("Expected `"+registrationName+"` listener to be a function, instead got a value of `"+(typeof listener==='undefined'?'undefined':_typeof(listener))+"` type.");}}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
if(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value
Object.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// unintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
// when we call document.createEvent(). However this can cause confusing
// errors: https://github.com/facebookincubator/create-react-app/issues/3482
// So we preemptively throw with a better message instead.
if(!(typeof document!=='undefined')){{throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");}}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Keeps track of the value of window.event so that we can reset it
// during the callback to let user code access window.event in the
// browsers that support it.
var windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event
// dispatching: https://github.com/facebook/react/issues/13688
var windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
// window.event assignment in both IE <= 10 as they throw an error
// "Member not found" in strict mode, and in Firefox which does not
// support window.event.
if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
// Browsers silence the error report if this happens.
// We'll remember this to later decide whether to log it or not.
if(error!=null&&(typeof error==='undefined'?'undefined':_typeof(error))==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
}}}}// Create a fake event type.
var evtType="react-"+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
window.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.
// https://github.com/facebook/react/issues/16734
// https://github.com/facebook/react/issues/16585
// Fall back to the production implementation.
restoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
var hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{{{throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");}}}}/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.
var NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).
var Placement=/*                    */2;var Update=/*                       */4;var PlacementAndUpdate=/*           */6;var Deletion=/*                     */8;var ContentReset=/*                 */16;var Callback=/*                     */32;var DidCapture=/*                   */64;var Ref=/*                          */128;var Snapshot=/*                     */256;var Passive=/*                      */512;// TODO (effects) Remove this bit once the new reconciler is synced to the old.
var PassiveUnmountPendingDev=/*     */8192;var Hydrating=/*                    */1024;var HydratingAndUpdate=/*           */1028;// Passive & Update & Callback & Ref & Snapshot
var LifecycleEffectMask=/*          */932;// Union of all host effects
var HostEffectMask=/*               */2047;// These are not really side effects, but we still reuse this field.
var Incomplete=/*                   */2048;var ShouldCapture=/*                */4096;var ForceUpdateForLegacySuspense=/* */16384;// Static tags describe aspects of a fiber that are not specific to a render,
var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
var nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible
// mounted fiber is the parent but we need to continue to figure out
// if that one is still mounted.
nearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber.type)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(!(getNearestMountedFiber(fiber)===fiber)){{throw Error("Unable to find node on an unmounted component.");}}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var nearestMounted=getNearestMountedFiber(fiber);if(!(nearestMounted!==null)){{throw Error("Unable to find node on an unmounted component.");}}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.
break;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only
// happens when a Suspense component is hidden. An extra fragment fiber
// is inserted in between the Suspense fiber and its children. Skip
// over this extra fragment fiber and proceed to the next parent.
var nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
{{throw Error("Unable to find node on an unmounted component.");}}}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){{throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");}}}}if(!(a.alternate===b)){{throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");}}}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
if(!(a.tag===HostRoot)){{throw Error("Unable to find node on an unmounted component.");}}if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText||enableFundamentalAPI){return node;}else if(node.child&&node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function doesFiberContain(parentFiber,childFiber){var node=childFiber;var parentFiberAlternate=parentFiber.alternate;while(node!==null){if(node===parentFiber||node===parentFiberAlternate){return true;}node=node.return;}return false;}var attemptUserBlockingHydration;function setAttemptUserBlockingHydration(fn){attemptUserBlockingHydration=fn;}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that
var hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.
var queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.
var queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.
var queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.
var queuedExplicitHydrationTargets=[];function hasQueuedDiscreteEvents(){return queuedDiscreteEvents.length>0;}var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase
'copy','cut','paste','click','change','contextmenu','reset','submit'];function isReplayableDiscreteEvent(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags|IS_REPLAYED,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function queueDiscreteEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);queuedDiscreteEvents.push(queuedEvent);}// Resets the replaying for this type of continuous event to no event.
function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.
attemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because
// the different event systems have different DOM event listeners.
// We can accumulate the flags, and the targetContainers, and
// store a single event to be replayed.
existingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we
// moved from outside the window (no target) onto the target once it hydrates.
// Instead of mutating we could clone the event.
switch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.
function attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with attemptToDispatchEvent.
// Try to unify them. It's a bit tricky since it would require two return
// values.
var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.
// Increase its priority.
queuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.lanePriority,function(){Scheduler.unstable_runWithPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(root.hydrate){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of
// a root other than sync.
return;}}}}queuedTarget.blockedOn=null;}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=attemptToDispatchEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn!==null){// We're still blocked. Try again later.
var _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.
targetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;// First replay discrete events.
while(queuedDiscreteEvents.length>0){var nextDiscreteEvent=queuedDiscreteEvents[0];if(nextDiscreteEvent.blockedOn!==null){// We're still blocked.
// Increase the priority of this boundary to unblock
// the next discrete event.
var _fiber4=getInstanceFromNode(nextDiscreteEvent.blockedOn);if(_fiber4!==null){attemptUserBlockingHydration(_fiber4);}break;}var targetContainers=nextDiscreteEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=attemptToDispatchEvent(nextDiscreteEvent.domEventName,nextDiscreteEvent.eventSystemFlags,targetContainer,nextDiscreteEvent.nativeEvent);if(nextBlockedOn!==null){// We're still blocked. Try again later.
nextDiscreteEvent.blockedOn=nextBlockedOn;break;}// This target container was successfully dispatched. Try the next.
targetContainers.shift();}if(nextDiscreteEvent.blockedOn===null){// We've successfully replayed the first event. Let's try the next one.
queuedDiscreteEvents.shift();}}// Next replay any continuous events.
if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are
// now unblocked. This first might not actually be unblocked yet.
// We could check it early to avoid scheduling an unnecessary callback.
Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked
// and eligible for a replay.
if(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's
// worth it because we expect very few discrete events to queue up and once
// we are actually fully unblocked it will be fast to replay them.
for(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.
break;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.
queuedExplicitHydrationTargets.shift();}}}}var DiscreteEvent=0;var UserBlockingEvent=1;var ContinuousEvent=2;/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();var eventPriorities=new Map();// We store most of the events in this module in pairs of two strings so we can re-use
// the code required to apply the same logic for event prioritization and that of the
// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
// duplication (for which there would be quite a bit). For the events that are not needed
// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
// array of top level events.
// Lastly, we ignore prettier so we can keep the formatting sane.
// prettier-ignore
var discreteEventPairsForSimpleEventPlugin=['cancel','cancel','click','click','close','close','contextmenu','contextMenu','copy','copy','cut','cut','auxclick','auxClick','dblclick','doubleClick',// Careful!
'dragend','dragEnd','dragstart','dragStart','drop','drop','focusin','focus',// Careful!
'focusout','blur',// Careful!
'input','input','invalid','invalid','keydown','keyDown','keypress','keyPress','keyup','keyUp','mousedown','mouseDown','mouseup','mouseUp','paste','paste','pause','pause','play','play','pointercancel','pointerCancel','pointerdown','pointerDown','pointerup','pointerUp','ratechange','rateChange','reset','reset','seeked','seeked','submit','submit','touchcancel','touchCancel','touchend','touchEnd','touchstart','touchStart','volumechange','volumeChange'];var otherDiscreteEvents=['change','selectionchange','textInput','compositionstart','compositionend','compositionupdate'];var userBlockingPairsForSimpleEventPlugin=['drag','drag','dragenter','dragEnter','dragexit','dragExit','dragleave','dragLeave','dragover','dragOver','mousemove','mouseMove','mouseout','mouseOut','mouseover','mouseOver','pointermove','pointerMove','pointerout','pointerOut','pointerover','pointerOver','scroll','scroll','toggle','toggle','touchmove','touchMove','wheel','wheel'];// prettier-ignore
var continuousPairsForSimpleEventPlugin=['abort','abort',ANIMATION_END,'animationEnd',ANIMATION_ITERATION,'animationIteration',ANIMATION_START,'animationStart','canplay','canPlay','canplaythrough','canPlayThrough','durationchange','durationChange','emptied','emptied','encrypted','encrypted','ended','ended','error','error','gotpointercapture','gotPointerCapture','load','load','loadeddata','loadedData','loadedmetadata','loadedMetadata','loadstart','loadStart','lostpointercapture','lostPointerCapture','playing','playing','progress','progress','seeking','seeking','stalled','stalled','suspend','suspend','timeupdate','timeUpdate',TRANSITION_END,'transitionEnd','waiting','waiting'];/**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */function registerSimplePluginEventsAndSetTheirPriorities(eventTypes,priority){// As the event types are in pairs of two, we need to iterate
// through in twos. The events are in pairs of two to save code
// and improve init perf of processing this array, as it will
// result in far fewer object allocations and property accesses
// if we only use three arrays to process all the categories of
// instead of tuples.
for(var i=0;i<eventTypes.length;i+=2){var topEvent=eventTypes[i];var event=eventTypes[i+1];var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var reactName='on'+capitalizedEvent;eventPriorities.set(topEvent,priority);topLevelEventsToReactNames.set(topEvent,reactName);registerTwoPhaseEvent(reactName,[topEvent]);}}function setEventPriorities(eventTypes,priority){for(var i=0;i<eventTypes.length;i++){eventPriorities.set(eventTypes[i],priority);}}function getEventPriorityForPluginSystem(domEventName){var priority=eventPriorities.get(domEventName);// Default to a ContinuousEvent. Note: we might
// want to warn if we can't detect the priority
// for the event.
return priority===undefined?ContinuousEvent:priority;}function registerSimpleEvents(){registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin,DiscreteEvent);registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin,UserBlockingEvent);registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin,ContinuousEvent);setEventPriorities(otherDiscreteEvents,DiscreteEvent);}var Scheduler_now=Scheduler.unstable_now;{// Provide explicit error message when production+profiling bundle of e.g.
// react-dom is used with production (non-profiling) bundle of
// scheduler/tracing
if(!(tracing.__interactionsRef!=null&&tracing.__interactionsRef.current!=null)){{throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");}}}// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.
var ImmediatePriority=99;var UserBlockingPriority=98;var NormalPriority=97;var LowPriority=96;var IdlePriority=95;// NoPriority is the absence of priority. Also React-only.
var NoPriority=90;var initialTimeMs=Scheduler_now();// If the initial timestamp is reasonably small, use Scheduler's `now` directly.
var SyncLanePriority=15;var SyncBatchedLanePriority=14;var InputDiscreteHydrationLanePriority=13;var InputDiscreteLanePriority=12;var InputContinuousHydrationLanePriority=11;var InputContinuousLanePriority=10;var DefaultHydrationLanePriority=9;var DefaultLanePriority=8;var TransitionHydrationPriority=7;var TransitionPriority=6;var RetryLanePriority=5;var SelectiveHydrationLanePriority=4;var IdleHydrationLanePriority=3;var IdleLanePriority=2;var OffscreenLanePriority=1;var NoLanePriority=0;var TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var SyncBatchedLane=/*                 */2;var InputDiscreteHydrationLane=/*      */4;var InputDiscreteLanes=/*                    */24;var InputContinuousHydrationLane=/*           */32;var InputContinuousLanes=/*                  */192;var DefaultHydrationLane=/*            */256;var DefaultLanes=/*                   */3584;var TransitionHydrationLane=/*                */4096;var TransitionLanes=/*                       */4186112;var RetryLanes=/*                            */62914560;var SomeRetryLane=/*                  */33554432;var SelectiveHydrationLane=/*          */67108864;var NonIdleLanes=/*                                 */134217727;var IdleHydrationLane=/*               */134217728;var IdleLanes=/*                             */805306368;var OffscreenLane=/*                   */1073741824;var NoTimestamp=-1;function setCurrentUpdateLanePriority(newLanePriority){}// "Registers" used to "return" multiple values
// Used by getHighestPriorityLanes and getNextLanes:
var return_highestLanePriority=DefaultLanePriority;function getHighestPriorityLanes(lanes){if((SyncLane&lanes)!==NoLanes){return_highestLanePriority=SyncLanePriority;return SyncLane;}if((SyncBatchedLane&lanes)!==NoLanes){return_highestLanePriority=SyncBatchedLanePriority;return SyncBatchedLane;}if((InputDiscreteHydrationLane&lanes)!==NoLanes){return_highestLanePriority=InputDiscreteHydrationLanePriority;return InputDiscreteHydrationLane;}var inputDiscreteLanes=InputDiscreteLanes&lanes;if(inputDiscreteLanes!==NoLanes){return_highestLanePriority=InputDiscreteLanePriority;return inputDiscreteLanes;}if((lanes&InputContinuousHydrationLane)!==NoLanes){return_highestLanePriority=InputContinuousHydrationLanePriority;return InputContinuousHydrationLane;}var inputContinuousLanes=InputContinuousLanes&lanes;if(inputContinuousLanes!==NoLanes){return_highestLanePriority=InputContinuousLanePriority;return inputContinuousLanes;}if((lanes&DefaultHydrationLane)!==NoLanes){return_highestLanePriority=DefaultHydrationLanePriority;return DefaultHydrationLane;}var defaultLanes=DefaultLanes&lanes;if(defaultLanes!==NoLanes){return_highestLanePriority=DefaultLanePriority;return defaultLanes;}if((lanes&TransitionHydrationLane)!==NoLanes){return_highestLanePriority=TransitionHydrationPriority;return TransitionHydrationLane;}var transitionLanes=TransitionLanes&lanes;if(transitionLanes!==NoLanes){return_highestLanePriority=TransitionPriority;return transitionLanes;}var retryLanes=RetryLanes&lanes;if(retryLanes!==NoLanes){return_highestLanePriority=RetryLanePriority;return retryLanes;}if(lanes&SelectiveHydrationLane){return_highestLanePriority=SelectiveHydrationLanePriority;return SelectiveHydrationLane;}if((lanes&IdleHydrationLane)!==NoLanes){return_highestLanePriority=IdleHydrationLanePriority;return IdleHydrationLane;}var idleLanes=IdleLanes&lanes;if(idleLanes!==NoLanes){return_highestLanePriority=IdleLanePriority;return idleLanes;}if((OffscreenLane&lanes)!==NoLanes){return_highestLanePriority=OffscreenLanePriority;return OffscreenLane;}{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.
return_highestLanePriority=DefaultLanePriority;return lanes;}function schedulerPriorityToLanePriority(schedulerPriorityLevel){switch(schedulerPriorityLevel){case ImmediatePriority:return SyncLanePriority;case UserBlockingPriority:return InputContinuousLanePriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
return DefaultLanePriority;case IdlePriority:return IdleLanePriority;default:return NoLanePriority;}}function lanePriorityToSchedulerPriority(lanePriority){switch(lanePriority){case SyncLanePriority:case SyncBatchedLanePriority:return ImmediatePriority;case InputDiscreteHydrationLanePriority:case InputDiscreteLanePriority:case InputContinuousHydrationLanePriority:case InputContinuousLanePriority:return UserBlockingPriority;case DefaultHydrationLanePriority:case DefaultLanePriority:case TransitionHydrationPriority:case TransitionPriority:case SelectiveHydrationLanePriority:case RetryLanePriority:return NormalPriority;case IdleHydrationLanePriority:case IdleLanePriority:case OffscreenLanePriority:return IdlePriority;case NoLanePriority:return NoPriority;default:{{throw Error("Invalid update priority: "+lanePriority+". This is a bug in React.");}}}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.
var pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return_highestLanePriority=NoLanePriority;return NoLanes;}var nextLanes=NoLanes;var nextLanePriority=NoLanePriority;var expiredLanes=root.expiredLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Check if any work has expired.
if(expiredLanes!==NoLanes){nextLanes=expiredLanes;nextLanePriority=return_highestLanePriority=SyncLanePriority;}else{// Do not work on any idle work until all the non-idle work has finished,
// even if the work is suspended.
var nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);nextLanePriority=return_highestLanePriority;}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);nextLanePriority=return_highestLanePriority;}}}else{// The only remaining work is Idle.
var unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);nextLanePriority=return_highestLanePriority;}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);nextLanePriority=return_highestLanePriority;}}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended
// TODO: Consider warning in this path if a fallback timer is not scheduled.
return NoLanes;}// If there are higher priority lanes, we'll include them even if they
// are suspended.
nextLanes=pendingLanes&getEqualOrHigherPriorityLanes(nextLanes);// If we're already in the middle of a render, switching lanes will interrupt
// it and we'll lose our progress. We should only do this if the new lanes are
// higher priority.
if(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't
// bother waiting until the root is complete.
(wipLanes&suspendedLanes)===NoLanes){getHighestPriorityLanes(wipLanes);var wipLanePriority=return_highestLanePriority;if(nextLanePriority<=wipLanePriority){return wipLanes;}else{return_highestLanePriority=nextLanePriority;}}// Check for entangled lanes and add them to the batch.
//
// A lane is said to be entangled with another when it's not allowed to render
// in a batch that does not also include the other lane. Typically we do this
// when multiple updates have the same source, and we only want to respond to
// the most recent event from that source.
//
// Note that we apply entanglements *after* checking for partial work above.
// This means that if a lane is entangled during an interleaved event while
// it's already rendering, we won't interrupt it. This is intentional, since
// entanglement is usually "best effort": we'll try our best to render the
// lanes in the same batch, but it's not worth throwing out partially
// completed work in order to do it.
//
// For those exceptions where entanglement is semantically important, like
// useMutableSource, we should ensure that there is no partial work at the
// time we apply the entanglement.
var entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){// TODO: Expiration heuristic is constant per lane, so could use a map.
getHighestPriorityLanes(lane);var priority=return_highestLanePriority;if(priority>=InputContinuousLanePriority){// User interactions should expire slightly more quickly.
//
// NOTE: This is set to the corresponding constant as in Scheduler.js. When
// we made it larger, a product metric in www regressed, suggesting there's
// a user interaction that's being starved by a series of synchronous
// updates. If that theory is correct, the proper solution is to fix the
// starvation. However, this scenario supports the idea that expiration
// times are an important safeguard when starvation does happen.
//
// Also note that, in the case of user input specifically, this will soon no
// longer be an issue because we plan to make user input synchronous by
// default (until you enter `startTransition`, of course.)
//
// If weren't planning to make these updates synchronous soon anyway, I
// would probably make this number a configurable parameter.
return currentTime+250;}else if(priority>=TransitionPriority){return currentTime+5000;}else{// Anything idle priority or lower should never expire.
return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing
// the earliest expiration time on the root. Then use that to quickly bail out
// of this function.
var pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their
// expiration time. If so, we'll assume the update is being starved and mark
// it as expired to force it to finish.
var lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or
// if it's pinged, assume it's CPU-bound. Compute a new expiration time
// using the current time.
if((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.
expirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired
root.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they
function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function returnNextLanesPriority(){return return_highestLanePriority;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}// To ensure consistency across multiple updates in the same event, this should
// be a pure function, so that it always returns the same lane for given inputs.
function findUpdateLane(lanePriority,wipLanes){switch(lanePriority){case NoLanePriority:break;case SyncLanePriority:return SyncLane;case SyncBatchedLanePriority:return SyncBatchedLane;case InputDiscreteLanePriority:{var _lane=pickArbitraryLane(InputDiscreteLanes&~wipLanes);if(_lane===NoLane){// Shift to the next priority level
return findUpdateLane(InputContinuousLanePriority,wipLanes);}return _lane;}case InputContinuousLanePriority:{var _lane2=pickArbitraryLane(InputContinuousLanes&~wipLanes);if(_lane2===NoLane){// Shift to the next priority level
return findUpdateLane(DefaultLanePriority,wipLanes);}return _lane2;}case DefaultLanePriority:{var _lane3=pickArbitraryLane(DefaultLanes&~wipLanes);if(_lane3===NoLane){// If all the default lanes are already being worked on, look for a
// lane in the transition range.
_lane3=pickArbitraryLane(TransitionLanes&~wipLanes);if(_lane3===NoLane){// All the transition lanes are taken, too. This should be very
// rare, but as a last resort, pick a default lane. This will have
// the effect of interrupting the current work-in-progress render.
_lane3=pickArbitraryLane(DefaultLanes);}}return _lane3;}case TransitionPriority:// Should be handled by findTransitionLane instead
case RetryLanePriority:// Should be handled by findRetryLane instead
break;case IdleLanePriority:var lane=pickArbitraryLane(IdleLanes&~wipLanes);if(lane===NoLane){lane=pickArbitraryLane(IdleLanes);}return lane;}{{throw Error("Invalid update priority: "+lanePriority+". This is a bug in React.");}}}// To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.
function findTransitionLane(wipLanes,pendingLanes){// First look for lanes that are completely unclaimed, i.e. have no
// pending work.
var lane=pickArbitraryLane(TransitionLanes&~pendingLanes);if(lane===NoLane){// If all lanes have pending work, look for a lane that isn't currently
// being worked on.
lane=pickArbitraryLane(TransitionLanes&~wipLanes);if(lane===NoLane){// If everything is being worked on, pick any lane. This has the
// effect of interrupting the current work-in-progress.
lane=pickArbitraryLane(TransitionLanes);}}return lane;}// To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.
function findRetryLane(wipLanes){// This is a fork of `findUpdateLane` designed specifically for Suspense
// "retries" — a special update that attempts to flip a Suspense boundary
// from its placeholder state to its primary/resolved state.
var lane=pickArbitraryLane(RetryLanes&~wipLanes);if(lane===NoLane){lane=pickArbitraryLane(RetryLanes);}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function getLowestPriorityLane(lanes){// This finds the most significant non-zero bit.
var index=31-clz32(lanes);return index<0?NoLanes:1<<index;}function getEqualOrHigherPriorityLanes(lanes){return(getLowestPriorityLane(lanes)<<1)-1;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it
// doesn't matter which bit is selected; you can pick any bit without
// affecting the algorithms where its used. Here I'm using
// getHighestPriorityLane because it requires the fewest operations.
return getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}// Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).
function laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.
return a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.
// https://v8.dev/blog/elements-kinds#avoid-creating-holes
var laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// TODO: Theoretically, any update to any lane can unblock any other lane. But
// it's not practical to try every single possible combination. We need a
// heuristic to decide which lanes to attempt to render, and in which batches.
// For now, we use the same heuristic as in the old ExpirationTimes model:
// retry any lane at equal or lower priority, but don't try updates at higher
// priority without also including the lower priority updates. This works well
// when considering updates across different priority levels, but isn't
// sufficient for updates within the same priority, since we want to treat
// those updates as parallel.
// Unsuspend any update at equal or lower priority.
var higherPriorityLanes=updateLane-1;// Turns 0b1000 into 0b0111
root.suspendedLanes&=higherPriorityLanes;root.pingedLanes&=higherPriorityLanes;var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most
// recent event, and we assume time is monotonically increasing.
eventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.
var expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markDiscreteUpdatesExpired(root){root.expiredLanes|=InputDiscreteLanes&root.pendingLanes;}function hasDiscreteLanes(lanes){return(lanes&InputDiscreteLanes)!==NoLanes;}function markRootMutableRead(root,updateLane){root.mutableReadLanes|=updateLane&root.pendingLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again
root.suspendedLanes=0;root.pingedLanes=0;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work
var lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]|=entangledLanes;lanes&=~lane;}}var clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros. Only used on lanes, so assume input is an integer.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
var log=Math.log;var LN2=Math.LN2;function clz32Fallback(lanes){if(lanes===0){return 32;}return 31-(log(lanes)/LN2|0)|0;}// Intentionally not named imports because Rollup would use dynamic dispatch for
var UserBlockingPriority$1=Scheduler.unstable_UserBlockingPriority,runWithPriority=Scheduler.unstable_runWithPriority;// TODO: can we stop exporting these?
var _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.
function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriorityForPluginSystem(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEvent:listenerWrapper=dispatchDiscreteEvent;break;case UserBlockingEvent:listenerWrapper=dispatchUserBlockingUpdate;break;case ContinuousEvent:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){{flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);}discreteUpdates(dispatchEvent,domEventName,eventSystemFlags,container,nativeEvent);}function dispatchUserBlockingUpdate(domEventName,eventSystemFlags,container,nativeEvent){{runWithPriority(UserBlockingPriority$1,dispatchEvent.bind(null,domEventName,eventSystemFlags,container,nativeEvent));}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}var allowReplay=true;{// TODO: replaying capture phase events is currently broken
// because we used to do it during top-level native bubble handlers
// but now we use different bubble and capture handlers.
// In eager mode, we attach capture listeners early, so we need
// to filter them out until we fix the logic to handle them correctly.
// This could've been outside the flag but I put it inside to reduce risk.
allowReplay=(eventSystemFlags&IS_CAPTURE_PHASE)===0;}if(allowReplay&&hasQueuedDiscreteEvents()&&isReplayableDiscreteEvent(domEventName)){// If we already have a queue of discrete events, and this is another discrete
// event, then we can't dispatch it regardless of its target, since they
// need to dispatch in order.
queueDiscreteEvent(null,// Flags that we're not actually blocked on anything as far as we know.
domEventName,eventSystemFlags,targetContainer,nativeEvent);return;}var blockedOn=attemptToDispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){// We successfully dispatched this event.
if(allowReplay){clearIfContinuousEvent(domEventName,nativeEvent);}return;}if(allowReplay){if(isReplayableDiscreteEvent(domEventName)){// This this to be replayed later once the target is available.
queueDiscreteEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){return;}// We need to clear only if we didn't queue because
// queueing is accummulative.
clearIfContinuousEvent(domEventName,nativeEvent);}// This is not replayable so we'll invoke it but without a target,
// in case the event system needs to trace it.
dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.
function attemptToDispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.
var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.
targetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we
// don't want this event dispatched twice through the event system.
// TODO: If this is the first discrete event in the queue. Schedule an increased
// priority for this boundary.
return instance;}// This shouldn't happen, something went wrong but to avoid blocking
// the whole system, dispatch the event without a target.
// TODO: Warn.
targetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(root.hydrate){// If this happens during a replay something went wrong and it might block
// the whole system.
return getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}}}dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer);// We're not blocked on anything.
return null;}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
// report Enter as charCode 10 when ctrl is pressed.
if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.
function createSyntheticEvent(Interface){/**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}_assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */persist:function persist(){// Modern event system doesn't use pooling.
},/**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=_assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface=_assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here
// because it's guaranteed to have already run when movementX
// was copied.
return lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface=_assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface=_assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface=_assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface=_assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface=_assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */// Happens to share the same list for now.
var SyntheticInputEvent=SyntheticCompositionEvent;/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface=_assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */var PointerEventInterface=_assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface=_assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface=_assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface=_assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to ignore it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'keypress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.
enqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur
setDefaultValue(node,'number',node.value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&(eventSystemFlags&IS_REPLAYED)===0){// If this is an over event with a target, we might have already dispatched
// the event in the out event of the other target. If this is replayed,
// then it's because we couldn't dispatch against this target previously
// so we have to do it now instead.
var related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have
// already dispatched the corresponding events during its mouseout.
if(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
return;}var win;// TODO: why is this nullable in the types but we read from it?
if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing
// the first ancestor. Next time, we will ignore the event.
var nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare
;}var objectIs=typeof Object.is==='function'?Object.is:is;var hasOwnProperty$2=Object.prototype.hasOwnProperty;/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if((typeof objA==='undefined'?'undefined':_typeof(objA))!=='object'||objA===null||(typeof objB==='undefined'?'undefined':_typeof(objB))!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
for(var i=0;i<keysA.length;i++){if(!hasOwnProperty$2.call(objB,keysA[i])||!objectIs(objA[keysA[i]],objB[keysA[i]])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with "Object expected" in some scenarios.
// (For instance: TinyMCE editor used in a list component that supports pasting to add more,
// fails when pasting 100+ items)
if(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser
// to throw, e.g. if it has a cross-origin src attribute.
// Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
// iframe.contentDocument.defaultView;
// A safety way is to access one of the cross origin properties: Window or Location
// Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
return typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 *//**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Get document associated with the event target.
 */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.
var currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.
case'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'selectionchange':if(skipSelectionChangeEvent){break;}// falls through
case'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.
// In the past, React has always bubbled them, but this can be surprising.
// We're going to try aligning closer to the browser behavior by not bubbling
// them in React either. We'll start by not bubbling onScroll, and then expand.
var accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from
// nonDelegatedEvents list in DOMPluginEventSystem.
// Then we can remove this special list.
// This is a breaking change that can wait until React 18.
domEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.
var _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.
registerSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a "SimpleEventPlugin".
// This is the basic functionality of the event system. All
// the other plugins are essentially polyfills. So the plugin
// should probably be inlined somewhere and have its logic
// be core the to event system. This would potentially allow
// us to ship builds of React without the polyfilled plugins below.
extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the
// event's native "bubble" phase, which means that we're
// not in the capture phase. That's because we emulate
// the capture phase here still. This is a trade-off,
// because in an ideal world we would not emulate and use
// the phases properly, like we do with the SimpleEvent
// plugin. However, the plugins below either expect
// emulation (EnterLeave) or use state localized to that
// plugin (BeforeInput, Change, Select). The state in
// these modules complicates things, as you'll essentially
// get the case where the capture phase event might change
// state, only for the following bubble event to come in
// later and not trigger anything as the state now
// invalidates the heuristics of the event plugin. We
// could alter all these plugins to work in such ways, but
// that might cause other unknown side-effects that we
// can't forsee right now.
if(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.
var mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.
var nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.
}// This would be a good time to rethrow if any of the event handlers threw.
rethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}var listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){{if(rootContainerElement[listeningMarker]){// Performance optimization: don't iterate through events
// for the same portal container or root node more than once.
// TODO: once we remove the flag, we may be able to also
// remove some of the bookkeeping maps used for laziness.
return;}rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement,null);}listenToNativeEvent(domEventName,true,rootContainerElement,null);});}}function listenToNativeEvent(domEventName,isCapturePhaseListener,rootContainerElement,targetElement){var eventSystemFlags=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var target=rootContainerElement;// selectionchange needs to be attached to the document
// otherwise it won't capture incoming events that are only
// triggered on the document directly.
if(domEventName==='selectionchange'&&rootContainerElement.nodeType!==DOCUMENT_NODE){target=rootContainerElement.ownerDocument;}// If the event can be delegated (or is capture phase), we can
// register it to the root container. Otherwise, we should
// register the event to the target element and mark it as
// a non-delegated event.
if(targetElement!==null&&!isCapturePhaseListener&&nonDelegatedEvents.has(domEventName)){// For all non-delegated events, apart from scroll, we attach
// their event listeners to the respective elements that their
// events fire on. That means we can skip this step, as event
// listener has already been added previously. However, we
// special case the scroll event because the reality is that any
// element can scroll.
// TODO: ideally, we'd eventually apply the same logic to all
// events from the nonDelegatedEvents list. Then we can remove
// this special case and use the same logic for all events.
if(domEventName!=='scroll'){return;}eventSystemFlags|=IS_NON_DELEGATED;target=targetElement;}var listenerSet=getEventListenerSet(target);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);// If the listener entry is empty or we should upgrade, then
// we need to trap an event listener onto the target.
if(!listenerSet.has(listenerSetKey)){if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be
// active and not passive.
var isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events
// passive by default on document. React doesn't bind them
// to document anymore, but changing this now would undo
// the performance wins from the change. So we emulate
// the existing behavior manually on the roots now.
// https://github.com/facebook/react/issues/19651
if(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we
if(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we
if(targetInst!==null){// The below logic attempts to work out if we need to change
// the target fiber to a different ancestor. We had similar logic
// in the legacy event system, except the big difference between
// systems is that the modern event system now has an event listener
// attached to each React Root and React Portal Root. Together,
// the DOM nodes representing these roots are the "rootContainer".
// To figure out which ancestor instance we should use, we traverse
// up the fiber tree from the target instance and attempt to find
// root boundaries that match that of our current "rootContainer".
// If we find that "rootContainer", we find the parent fiber
// sub-tree for that root and make that our ancestor instance.
var node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.
// Normally portals handle their own events all the way down to the root.
// So we should be able to stop now. However, we don't know if this portal
// was part of *our* root.
var grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as
// a parent of the Portal. That means we can ignore it because the
// Portal will bubble through to us.
return;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other
// tree. To do this we can use getClosestInstanceFromNode, but we
// need to validate that the fiber is a host instance, otherwise
// we need to traverse up through the DOM till we find the correct
// node that is from the other tree.
while(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedEventUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners
if(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't
// continue to propagate through the React fiber tree to find other
// listeners.
if(accumulateTargetOnly){break;}instance=instance.return;}return listeners;}// We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).
function accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.
function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+"__"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var HTML_NAMESPACE$1=Namespaces.html;var warnedUnknownTags;var suppressHydrationWarning;var validatePropertiesInDevelopment;var warnForTextDifference;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeMarkupForTextOrAttribute;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.
dialog:true,// Electron ships a custom <webview> tag to display external web content in
// an isolated frame and process.
// This tag is not present in non Electron environments such as JSDom which
// is often used for testing purposes.
// @see https://electronjs.org/docs/api/webview-tag
webview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other
// browsers. It adds spaces and sorts the properties in some
// non-alphabetical order. Handling that would require sorting CSS
// properties in the client & server versions or applying
// `expectedStyle` to a temporary DOM node to read its `style` attribute
// normalized. Since it only affects IE, we're skipping style warnings
// in that browser completely in favor of doing all that work.
// See https://github.com/facebook/react/issues/11807
canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;error('Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE$1?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML
// tags get no namespace.
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE$1){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE$1){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
if(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
// attributes on `select`s needs to be added before `option`s are inserted.
// This prevents:
// - a bug where the `select` does not scroll to the correct option because singular
//  `select` elements automatically pick the first item #13222
// - a bug where the `select` set the first item as selected despite the `size` attribute #14239
// See https://github.com/facebook/react/issues/13222
// and https://github.com/facebook/react/issues/14239
if(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where
// it is possible that no option is selected.
//
// This is only necessary when a select in "single selection mode".
node.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE$1){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the allowed property list in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else if((typeof nextProp==='undefined'?'undefined':_typeof(nextProp))==='object'&&nextProp!==null&&nextProp.$$typeof===REACT_OPAQUE_ID_TYPE){// If we encounter useOpaqueReference's opaque object, this means we are hydrating.
// In this case, call the opaque object's toString function which generates a new client
// ID so client and server IDs match and throws to rerender.
nextProp.toString();}else{// For any other property we always add it to the queue and then we
// filter it out using the allowed property list during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement){var isCustomComponentTag;var extraAttributeNames;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Built-in SSR attribute is allowed
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(// Convince Flow we've calculated it (it's DEV-only in this method.)
typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
var serverValue=void 0;var propertyInfo=getPropertyInfo(propKey);if(suppressHydrationWarning);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE$1){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE$1){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
// be successfully parsed from HTML, but will produce a mismatch
// (and would be incorrectly rendered on the client).
// However, we already warn about bad casing elsewhere.
// So we'll skip the misleading extra mismatch warning in this case.
isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1;{SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';}var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='option'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
var scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;// -------------------
function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
// fires if there is an `Update` effect scheduled during mounting.
// This happens if `finalizeInitialChildren` returns `true` (which it
// does to implement the `autoFocus` attribute on the client). But
// there are also other cases when this might happen (such as patching
// up text content during hydration mismatch). So we'll check this again.
if(shouldAutoFocusHostComponent(type,newProps)){domElement.focus();}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
// If something inside a portal is clicked, that click should bubble
// through the React tree. However, on Mobile Safari the click would
// never bubble through the *DOM* tree unless an ancestor with onclick
// event exists. So we wouldn't see it and dispatch it.
// This is why we ensure that non React root containers have inline onclick
// defined.
// https://github.com/facebook/react/issues/11918
var reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we
// pass host context to this method?
instance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){var body=container.body;if(body!=null){body.textContent='';}}}// -------------------
function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getNextHydratable(node){// Skip non-hydratable nodes.
for(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace);}function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.
return null;}// Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.
function getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForUnmatchedText(textInstance,text);}}function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}function didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true);}var clientId=0;function makeClientIdInDEV(warnOnAccessInDEV){var id='r:'+(clientId++).toString(36);return{toString:function toString(){warnOnAccessInDEV();return id;},valueOf:function valueOf(){warnOnAccessInDEV();return id;}};}function isOpaqueHydratingObject(value){return value!==null&&(typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value.$$typeof===REACT_OPAQUE_ID_TYPE;}function makeOpaqueHydratingObject(attemptToReadValue){return{$$typeof:REACT_OPAQUE_ID_TYPE,toString:attemptToReadValue,valueOf:attemptToReadValue};}function preparePortalMount(portalInstance){{listenToAllSupportedEvents(portalInstance);}}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.
function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.
return targetInst;}// If the direct event target isn't a React owned DOM node, we need to look
// to see if one of its parents is a React owned DOM node.
var parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include
// React nodes in the future. We need to check this first because
// if we're a child of a dehydrated container, we need to first
// find that inner container before moving on to finding the parent
// instance. Note that we don't check this field on  the targetNode
// itself because the fibers are conceptually between the container
// node and the first child. It isn't surrounding the container node.
// If it's not a container, we check if it's an instance.
targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have
// stepped past dehydrated DOM nodes to get here. However they could
// also have been non-React nodes. We need to answer which one.
// If we the instance doesn't have any children, then there can't be
// a nested suspense boundary within it. So we can use this as a fast
// bailout. Most of the time, when people add non-React children to
// the tree, it is using a ref to a child-less DOM node.
// Normally we'd only need to check one of the fibers because if it
// has ever gone from having children to deleting them or vice versa
// it would have deleted the dehydrated boundary nested inside already.
// However, since the HostRoot starts out with an alternate it might
// have one on the alternate so we need to check in case this was a
// root.
var alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is
// nested within a dehydrated boundary and if so, which one.
var suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't
// hydrated it yet. Even though we leave the comments in the
// DOM after hydrating, and there are boundaries in the DOM
// that could already be hydrated, we wouldn't have found them
// through this pass since if the target is hydrated it would
// have had an internalInstanceKey on it.
// Let's get the fiber associated with the SuspenseComponent
// as the deepest instance.
var targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because
// we haven't gotten to hydrate it yet. There might still be a
// parent boundary that hasn't above this one so we need to find
// the outer most that is known.
suspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent
// host component also hasn't hydrated yet. We can return it
// below since it will bail out on the isMounted check later.
}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
{{throw Error("getNodeFromInstance: Invalid argument.");}}}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.
var has=Function.call.bind(Object.prototype.hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to
// fail the render phase where it didn't fail before. So we log it.
// After these have been cleaned up, we'll let them throw.
try{// This is intentionally an invariant that gets caught. It's the same
// behavior as without this statement except with a better message.
if(typeof typeSpecs[typeSpecName]!=='function'){var err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1==='undefined'?'undefined':_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the
// same error.
loggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
// we may have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(type)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(!(contextStackCursor.current===emptyContextObject)){{throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");}}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(type)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){{throw Error((getComponentName(type)||'Unknown')+".getChildContext(): key \""+contextKey+"\" is not defined in childContextTypes.");}}}{var name=getComponentName(type)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return _assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){{throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");}}if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
if(!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)){{throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");}}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);{{throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");}}}}var LegacyRoot=0;var BlockingRoot=1;var ConcurrentRoot=2;var rendererID=null;var injectedHook=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
injectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{error('React instrumentation encountered an error: %s.',err);}}// DevTools exists
return true;}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,priorityLevel){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){injectedHook.onCommitFiberRoot(rendererID,root,priorityLevel,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}var Scheduler_runWithPriority=Scheduler.unstable_runWithPriority,Scheduler_scheduleCallback=Scheduler.unstable_scheduleCallback,Scheduler_cancelCallback=Scheduler.unstable_cancelCallback,Scheduler_shouldYield=Scheduler.unstable_shouldYield,Scheduler_requestPaint=Scheduler.unstable_requestPaint,Scheduler_now$1=Scheduler.unstable_now,Scheduler_getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel,Scheduler_ImmediatePriority=Scheduler.unstable_ImmediatePriority,Scheduler_UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,Scheduler_NormalPriority=Scheduler.unstable_NormalPriority,Scheduler_LowPriority=Scheduler.unstable_LowPriority,Scheduler_IdlePriority=Scheduler.unstable_IdlePriority;{// Provide explicit error message when production+profiling bundle of e.g.
// react-dom is used with production (non-profiling) bundle of
// scheduler/tracing
if(!(tracing.__interactionsRef!=null&&tracing.__interactionsRef.current!=null)){{throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");}}}var fakeCallbackNode={};// Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.
var ImmediatePriority$1=99;var UserBlockingPriority$2=98;var NormalPriority$1=97;var LowPriority$1=96;var IdlePriority$1=95;// NoPriority is the absence of priority. Also React-only.
var NoPriority$1=90;var shouldYield=Scheduler_shouldYield;var requestPaint=// Fall back gracefully if we're running an older version of Scheduler.
Scheduler_requestPaint!==undefined?Scheduler_requestPaint:function(){};var syncQueue=null;var immediateQueueCallbackNode=null;var isFlushingSyncQueue=false;var initialTimeMs$1=Scheduler_now$1();// If the initial timestamp is reasonably small, use Scheduler's `now` directly.
// This will be the case for modern browsers that support `performance.now`. In
// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
// timestamp. In that case, subtract the module initialization time to simulate
// the behavior of performance.now and keep our times small enough to fit
// within 32 bits.
// TODO: Consider lifting this into Scheduler.
var now=initialTimeMs$1<10000?Scheduler_now$1:function(){return Scheduler_now$1()-initialTimeMs$1;};function getCurrentPriorityLevel(){switch(Scheduler_getCurrentPriorityLevel()){case Scheduler_ImmediatePriority:return ImmediatePriority$1;case Scheduler_UserBlockingPriority:return UserBlockingPriority$2;case Scheduler_NormalPriority:return NormalPriority$1;case Scheduler_LowPriority:return LowPriority$1;case Scheduler_IdlePriority:return IdlePriority$1;default:{{throw Error("Unknown priority level.");}}}}function reactPriorityToSchedulerPriority(reactPriorityLevel){switch(reactPriorityLevel){case ImmediatePriority$1:return Scheduler_ImmediatePriority;case UserBlockingPriority$2:return Scheduler_UserBlockingPriority;case NormalPriority$1:return Scheduler_NormalPriority;case LowPriority$1:return Scheduler_LowPriority;case IdlePriority$1:return Scheduler_IdlePriority;default:{{throw Error("Unknown priority level.");}}}}function runWithPriority$1(reactPriorityLevel,fn){var priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);return Scheduler_runWithPriority(priorityLevel,fn);}function scheduleCallback(reactPriorityLevel,callback,options){var priorityLevel=reactPriorityToSchedulerPriority(reactPriorityLevel);return Scheduler_scheduleCallback(priorityLevel,callback,options);}function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in
// the next tick, or earlier if something calls `flushSyncCallbackQueue`.
if(syncQueue===null){syncQueue=[callback];// Flush the queue in the next tick, at the earliest.
immediateQueueCallbackNode=Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueueImpl);}else{// Push onto existing queue. Don't need to schedule a callback because
// we already scheduled one when we created the queue.
syncQueue.push(callback);}return fakeCallbackNode;}function cancelCallback(callbackNode){if(callbackNode!==fakeCallbackNode){Scheduler_cancelCallback(callbackNode);}}function flushSyncCallbackQueue(){if(immediateQueueCallbackNode!==null){var node=immediateQueueCallbackNode;immediateQueueCallbackNode=null;Scheduler_cancelCallback(node);}flushSyncCallbackQueueImpl();}function flushSyncCallbackQueueImpl(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrancy.
isFlushingSyncQueue=true;var i=0;{try{var _isSync2=true;var _queue=syncQueue;runWithPriority$1(ImmediatePriority$1,function(){for(;i<_queue.length;i++){var callback=_queue[i];do{callback=callback(_isSync2);}while(callback!==null);}});syncQueue=null;}catch(error){// If something throws, leave the remaining callbacks on the queue.
if(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick
Scheduler_scheduleCallback(Scheduler_ImmediatePriority,flushSyncCallbackQueue);throw error;}finally{isFlushingSyncQueue=false;}}}}// TODO: this is special because it gets imported during build.
var ReactVersion='17.0.1';var NoMode=0;var StrictMode=1;// TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead
var BlockingMode=2;var ConcurrentMode=4;var ProfileMode=8;var DebugTracingMode=16;var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=0;function requestCurrentTransition(){return ReactCurrentBatchConfig.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.
var didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedup strategy: Warn once per component.
if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.
instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names
var componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings
// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
if(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, "+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, refactor your "+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
var didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\n\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
var props=_assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var MAX_SIGNED_31_BIT_INT=1073741823;var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context
rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastContextWithAllBitsObserved=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`
// cannot be called outside the render phase.
currentlyRenderingFiber=null;lastContextDependency=null;lastContextWithAllBitsObserved=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,nextValue){var context=providerFiber.type._context;{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);var context=providerFiber.type._context;{context._currentValue=currentValue;}}function calculateChangedBits(context,newValue,oldValue){if(objectIs(oldValue,newValue)){// No change
return 0;}else{var changedBits=typeof context._calculateChangedBits==='function'?context._calculateChangedBits(oldValue,newValue):MAX_SIGNED_31_BIT_INT;{if((changedBits&MAX_SIGNED_31_BIT_INT)!==changedBits){error('calculateChangedBits: Expected the return value to be a '+'31-bit integer. Instead received: %s',changedBits);}}return changedBits|0;}}function scheduleWorkOnParentPath(parent,renderLanes){// Update the child lanes of all the ancestors, including the alternates.
var node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}else{// Neither alternate was updated, which means the rest of the
// ancestor path already has sufficient priority.
break;}node=node.return;}}function propagateContextChange(workInProgress,context,changedBits,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
var list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.
if(dependency.context===context&&(dependency.observedBits&changedBits)!==0){// Match! Schedule an update on this fiber.
if(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.
var update=createUpdate(NoTimestamp,pickArbitraryLane(renderLanes));update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
// update to the current fiber, too, which means it will persist even if
// this render is thrown away. Since it's a race condition, not sure it's
// worth fixing.
enqueueUpdate(fiber,update);}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleWorkOnParentPath(fiber.return,renderLanes);// Mark the updated lanes on the list, too.
list.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the
// dependency list.
break;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else{// Traverse down.
nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
nextFiber.return=fiber;}else{// No child. Traverse to next sibling.
nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastContextWithAllBitsObserved=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.
markWorkInProgressReceivedUpdate();}// Reset the work-in-progress list
dependencies.firstContext=null;}}}function _readContext(context,observedBits){{// This warning would fire if you read context inside a Hook like useMemo.
// Unlike the class check below, it's not enforced in production for perf.
if(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}if(lastContextWithAllBitsObserved===context);else if(observedBits===false||observedBits===0);else{var resolvedObservedBits;// Avoid deopting on observable arguments or heterogeneous types.
if(typeof observedBits!=='number'||observedBits===MAX_SIGNED_31_BIT_INT){// Observe all updates.
lastContextWithAllBitsObserved=context;resolvedObservedBits=MAX_SIGNED_31_BIT_INT;}else{resolvedObservedBits=observedBits;}var contextItem={context:context,observedBits:resolvedObservedBits,next:null};if(lastContextDependency===null){if(!(currentlyRenderingFiber!==null)){{throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");}}// This is the first dependency for this component. Create a new list.
lastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem,responders:null};}else{// Append a new context item.
lastContextDependency=lastContextDependency.next=contextItem;}}return context._currentValue;}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.
var queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
return;}var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render
// phase. They should be discarded if the render is aborted. Therefore,
// we should only put them on the work-in-progress queue, not the current one.
var queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.
var current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when
// we bail out on a parent fiber that then captures an error thrown by
// a child. Since we want to append the update only to the work-in
// -progress queue, we need to clone the updates. We usually clone during
// processUpdateQueue, but that didn't happen in this case because we
// skipped over the parent when we bailed out.
var newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.
var update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.
if(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.
newFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.
var lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictMode){disableLogs();try{payload.call(instance,prevState,nextProps);}finally{reenableLogs();}}exitDisallowedContextReadInDEV();}return nextState;}// State object
return payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough
case UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictMode){disableLogs();try{_payload.call(instance,prevState,nextProps);}finally{reenableLogs();}}exitDisallowedContextReadInDEV();}}else{// Partial state object
partialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
return prevState;}// Merge the partial state and the previous state.
return _assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot
var queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.
var pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first
// and last so that it's non-circular.
var lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue
if(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then
// we need to transfer the updates to that queue, too. Because the base
// queue is a singly-linked list with no cycles, we can append to both
// lists and take advantage of structural sharing.
// TODO: Pass `current` as argument
var current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot
var currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.
if(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.
var newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes
// from the original lanes.
var newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.
newLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.
if(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.
newState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new
// pending updates to the end of the list and keep processing.
var _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we
// unravel them when transferring them to the base queue.
var _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Set the remaining expiration time to be whatever is remaining in the queue.
// This should be fine because the only two other things that contribute to
// expiration time are props and context. We're already in the middle of the
// begin phase by the time we start processing the queue, so we've already
// dealt with the props. Context in components that specify
// shouldComponentUpdate is tricky; but we'll have to account for
// that regardless.
markSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(!(typeof callback==='function')){{throw Error("Invalid argument passed as callback. Expected a function. Instead received: "+callback);}}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects
var effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};var isArray=Array.isArray;// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentName(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){{{throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");}}}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;{if(workInProgress.mode&StrictMode){disableLogs();try{// Invoke the function an extra time to help detect side-effects.
getDerivedStateFromProps(nextProps,prevState);}finally{reenableLogs();}}}var partialState=getDerivedStateFromProps(nextProps,prevState);{warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
var memoizedState=partialState===null||partialState===undefined?prevState:_assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
// base state.
if(workInProgress.lanes===NoLanes){// Queue is always non-null for classes
var updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleUpdateOnFiber(fiber,lane,eventTime);},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleUpdateOnFiber(fiber,lane,eventTime);},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleUpdateOnFiber(fiber,lane,eventTime);}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){{if(workInProgress.mode&StrictMode){disableLogs();try{// Invoke the function an extra time to help detect side-effects.
instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{reenableLogs();}}}var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentName(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentName(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&((typeof _state==='undefined'?'undefined':_typeof(_state))!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration
contextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>
if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if((typeof contextType==='undefined'?'undefined':_typeof(contextType))!=='object'){addendum=' However, it is set to a '+(typeof contextType==='undefined'?'undefined':_typeof(contextType))+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>
addendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentName(ctor)||'Component',addendum);}}}if((typeof contextType==='undefined'?'undefined':_typeof(contextType))==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}// Instantiate twice to help detect side-effects.
{if(workInProgress.mode&StrictMode){disableLogs();try{new ctor(props,context);// eslint-disable-line no-new
}finally{reenableLogs();}}}var instance=new ctor(props,context);var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
// Warn about these lifecycles if they are present.
// Don't warn about react-lifecycles-compat polyfilled methods though.
if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentName(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?"\n  "+foundWillMountName:'',foundWillReceivePropsName!==null?"\n  "+foundWillReceivePropsName:'',foundWillUpdateName!==null?"\n  "+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress.type)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress.type)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if((typeof contextType==='undefined'?'undefined':_typeof(contextType))==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}processUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
processUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){workInProgress.flags|=Update;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if((typeof contextType==='undefined'?'undefined':_typeof(contextType))==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.flags|=Update;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){workInProgress.flags|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.flags|=Update;}// If shouldComponentUpdate returned false, we should still update the
// memoized state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if((typeof contextType==='undefined'?'undefined':_typeof(contextType))==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(!(_typeof(child._store)==='object')){{throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");}}child._store.validated=true;var componentName=getComponentName(returnFiber.type)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'"key" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}var isArray$1=Array.isArray;function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&(typeof mixedRef==='undefined'?'undefined':_typeof(mixedRef))!=='object'){{// TODO: Clean this up once we turn on the string ref warning for
// everyone, because the strict mode case will no longer be relevant
if((returnFiber.mode&StrictMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs
// because these cannot be automatically converted to an arrow function
// using a codemod. Therefore, we don't have to warn about string refs again.
!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentName(returnFiber.type)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(!(ownerFiber.tag===ClassComponent)){{throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");}}inst=ownerFiber.stateNode;}if(!inst){{throw Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a bug in React. Please file an issue.");}}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
refs=inst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(!(typeof mixedRef==='string')){{throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");}}if(!element._owner){{throw Error("Element ref was specified as a string ("+mixedRef+") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");}}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){{{throw Error("Objects are not valid as a React child (found: "+(Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild)+"). If you meant to render a collection of children, use an array instead.");}}}}function warnOnFunctionType(returnFiber){{var componentName=getComponentName(returnFiber.type)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}// We avoid inlining this to avoid potential deopts from using try/catch.
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.flags=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
// instead.
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.flags=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.flags=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){if(current!==null){if(current.elementType===element.type||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(current,element)){// Move based on index
var existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert
var created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,lanes,key);}return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,lanes,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);if(!(typeof iteratorFn==='function')){{throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");}}{// We don't support rendering Generators because it's a mutation.
// See https://github.com/facebook/react/issues/12995
if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
newChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children
if(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(!(newChildren!=null)){{throw Error("An iterable object provided no iterator.");}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){switch(child.tag){case Fragment:{if(element.type===REACT_FRAGMENT_TYPE){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}break;}case Block:// We intentionally fallthrough here if enableBlocksAPI is not on.
// eslint-disable-next-lined no-fallthrough
default:{if(child.elementType===element.type||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(child,element)){deleteRemainingChildren(returnFiber,child.sibling);var _existing3=useFiber(child,element.props);_existing3.ref=coerceRef(returnFiber,child,element);_existing3.return=returnFiber;{_existing3._debugSource=element._source;_existing3._debugOwner=element._owner;}return _existing3;}break;}}// Didn't match.
deleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
var isUnkeyedTopLevelFragment=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}if(typeof newChild==='undefined'&&!isUnkeyedTopLevelFragment){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case Block:case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{{{throw Error((getComponentName(returnFiber.type)||'Component')+"(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");}}}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(!(current===null||workInProgress.child===current.child)){{throw Error("Resuming work not yet implemented.");}}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.
function resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(!(c!==NO_CONTEXT)){{throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");}}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
// However, we can't just call getRootHostContext() and push it because
// we'd have a different number of entries on the stack depending on
// whether getRootHostContext() throws somewhere in renderer code or not.
// So we push an empty value first. This lets us safely unwind on errors.
push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.
var SubtreeSuspenseContextMask=1;// Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.
var InvisibleParentSuspenseContext=1;// Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.
var ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the
// fallback. Otherwise, don't capture and bubble to the next boundary.
var nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.
return true;}return false;}var props=workInProgress.memoizedProps;// In order to capture, the Suspense component must have a fallback prop.
if(props.fallback===undefined){return false;}// Regular boundaries always capture.
if(props.unstable_avoidThisFallback!==true){return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the
// parent boundary if it is currently invisible.
if(hasInvisibleParent){return false;}// If the parent is not able to handle it, we must handle it.
return true;}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't
// keep track of whether it suspended or not.
node.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*  */0;// Represents whether effect should fire.
var HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.
var Layout=/*    */2;var Passive$1=/*   */4;// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;childToDelete.flags=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstance(parentType,parentProps);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}case SuspenseComponent:{return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(firstAttemptedInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){{throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");}}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}function getIsHydrating(){return isHydrating;}// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.
var workInProgressSources=[];var rendererSigil$1;{// Used to detect multiple renderers using the same mutable source.
rendererSigil$1={};}function markSourceAsDirty(mutableSource){workInProgressSources.push(mutableSource);}function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}function getWorkInProgressVersion(mutableSource){{return mutableSource._workInProgressVersionPrimary;}}function setWorkInProgressVersion(mutableSource,version){{mutableSource._workInProgressVersionPrimary=version;}workInProgressSources.push(mutableSource);}function warnAboutMultipleRenderersDEV(mutableSource){{{if(mutableSource._currentPrimaryRenderer==null){mutableSource._currentPrimaryRenderer=rendererSigil$1;}else if(mutableSource._currentPrimaryRenderer!==rendererSigil$1){error('Detected multiple renderers concurrently rendering the '+'same mutable source. This is currently unsupported.');}}}}// Eager reads the version of a mutable source and stores it on the root.
var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnAboutUseOpaqueIdentifier;{didWarnAboutUseOpaqueIdentifier={};didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.
var renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
var currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.
var currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.
var didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
var didScheduleRenderPhaseUpdateDuringThisPass=false;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook
var currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.
var hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.
var ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!Array.isArray(deps)){// Verify deps, but only on mount to avoid extra checks.
// It's unlikely their type would change as usually you define them inline.
error('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps==='undefined'?'undefined':_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentName(currentlyRenderingFiber$1.type);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+". "+oldHookName;// Extra space so second column lines up
// lol @ IE not supporting String#repeat
while(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n'+'   Previous render            Next render\n'+'   ------------------------------------------------------\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',componentName,table);}}}}function throwInvalidHookError(){{{throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");}}}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.
return false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be
// passed inline.
if(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\n\n'+'Previous: %s\n'+'Incoming: %s',currentHookNameInDev,"["+prevDeps.join(', ')+"]","["+nextDeps.join(', ')+"]");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:
ignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset
// currentHook = null;
// workInProgressHook = null;
// didScheduleRenderPhaseUpdate = false;
// TODO Warn if no hooks are used at all during mount, then some are used during update.
// Currently we will identify the update render as a mount because memoizedState === null.
// This is tricky because it's valid for certain types of components (e.g. React.lazy)
// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
// Non-stateful hooks (e.g. context) don't get added to memoizedState,
// so memoizedState would be null during updates and mounts.
{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,
// but no stateful hooks have been used.
// We want to match the production code behavior (which will use HooksDispatcherOnMount),
// but with the extra DEV validation to ensure hooks ordering hasn't changed.
// This dispatcher does that.
ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update
if(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to
// be scheduled. Use a counter to prevent infinite loops.
var numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;if(!(numberOfReRenders<RE_RENDER_LIMIT)){{throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");}}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize
// after first render to prevent infinite render phase updates.
ignorePreviousDependencies=false;}// Start over from the beginning of the list
currentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.
hookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrancy.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.
// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;}didScheduleRenderPhaseUpdate=false;if(!!didRenderTooFewHooks){{throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");}}return children;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;workInProgress.flags&=~(Passive|Update);current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrancy.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render
// phase, which we are now aborting. Remove the updates from the queues so
// they do not persist to the next render. Do not remove updates from hooks
// that weren't processed.
//
// Only reset the updates from the queue if it has a clone. If it does
// not have a clone, that means it wasn't processed, and the updates were
// scheduled before we entered the render phase.
var hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list
currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list
workInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a
// render phase update. It assumes there is either a current hook we can
// clone, or a work-in-progress hook from a previous render pass that we can
// use as a base. When we reach the end of the base list, we must switch to
// the dispatcher used for mounts.
var nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.
workInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.
if(!(nextCurrentHook!==null)){{throw Error("Rendered more hooks than during the previous render.");}}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.
currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.
workInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types
return typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={pending:null,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(!(queue!==null)){{throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");}}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.
var baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.
var pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.
// We'll add them to the base queue.
if(baseQueue!==null){// Merge the pending queue and the base queue.
var baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in
// the future if we implement resuming, or some form of that.
error('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.
var first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={lane:updateLane,action:update.action,eagerReducer:update.eagerReducer,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.
// TODO: Don't need to accumulate this. Instead, we can remove
// renderLanes from the original lanes.
currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.
if(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,action:update.action,eagerReducer:update.eagerReducer,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.
if(update.eagerReducer===reducer){// If this update was processed eagerly, and its reducer matches the
// current reducer, we can use the eagerly computed state.
newState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(!(queue!==null)){{throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");}}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous
// work-in-progress hook.
var dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.
queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the
// priority because it will always be the same as the current
// render's.
var action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to
// the base state unless the queue is empty.
// TODO: Not sure if this is the desired semantics, but it's what we
// do for gDSFP. I can't remember why.
if(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function readFromUnsubcribedMutableSource(root,source,getSnapshot){{warnAboutMultipleRenderersDEV(source);}var getVersion=source._getVersion;var version=getVersion(source._source);// Is it safe for this component to read from this source during the current render?
var isSafeToReadFromSource=false;// Check the version first.
// If this render has already been started with a specific version,
// we can use it alone to determine if we can safely read from the source.
var currentRenderVersion=getWorkInProgressVersion(source);if(currentRenderVersion!==null){// It's safe to read if the store hasn't been mutated since the last time
// we read something.
isSafeToReadFromSource=currentRenderVersion===version;}else{// If there's no version, then this is the first time we've read from the
// source during the current render pass, so we need to do a bit more work.
// What we need to determine is if there are any hooks that already
// subscribed to the source, and if so, whether there are any pending
// mutations that haven't been synchronized yet.
//
// If there are no pending mutations, then `root.mutableReadLanes` will be
// empty, and we know we can safely read.
//
// If there *are* pending mutations, we may still be able to safely read
// if the currently rendering lanes are inclusive of the pending mutation
// lanes, since that guarantees that the value we're about to read from
// the source is consistent with the values that we read during the most
// recent mutation.
isSafeToReadFromSource=isSubsetOfLanes(renderLanes,root.mutableReadLanes);if(isSafeToReadFromSource){// If it's safe to read from this source during the current render,
// store the version in case other components read from it.
// A changed version number will let those components know to throw and restart the render.
setWorkInProgressVersion(source,version);}}if(isSafeToReadFromSource){var snapshot=getSnapshot(source._source);{if(typeof snapshot==='function'){error('Mutable source should not return a function as the snapshot value. '+'Functions may close over mutable values and cause tearing.');}}return snapshot;}else{// This handles the special case of a mutable source being shared between renderers.
// In that case, if the source is mutated between the first and second renderer,
// The second renderer don't know that it needs to reset the WIP version during unwind,
// (because the hook only marks sources as dirty if it's written to their WIP version).
// That would cause this tear check to throw again and eventually be visible to the user.
// We can avoid this infinite loop by explicitly marking the source as dirty.
//
// This can lead to tearing in the first renderer when it resumes,
// but there's nothing we can do about that (short of throwing here and refusing to continue the render).
markSourceAsDirty(source);{{throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");}}}}function useMutableSource(hook,source,getSnapshot,subscribe){var root=getWorkInProgressRoot();if(!(root!==null)){{throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");}}var getVersion=source._getVersion;var version=getVersion(source._source);var dispatcher=ReactCurrentDispatcher$1.current;// eslint-disable-next-line prefer-const
var _dispatcher$useState=dispatcher.useState(function(){return readFromUnsubcribedMutableSource(root,source,getSnapshot);}),currentSnapshot=_dispatcher$useState[0],setSnapshot=_dispatcher$useState[1];var snapshot=currentSnapshot;// Grab a handle to the state hook as well.
// We use it to clear the pending update queue if we have a new source.
var stateHook=workInProgressHook;var memoizedState=hook.memoizedState;var refs=memoizedState.refs;var prevGetSnapshot=refs.getSnapshot;var prevSource=memoizedState.source;var prevSubscribe=memoizedState.subscribe;var fiber=currentlyRenderingFiber$1;hook.memoizedState={refs:refs,source:source,subscribe:subscribe};// Sync the values needed by our subscription handler after each commit.
dispatcher.useEffect(function(){refs.getSnapshot=getSnapshot;// Normally the dispatch function for a state hook never changes,
// but this hook recreates the queue in certain cases  to avoid updates from stale sources.
// handleChange() below needs to reference the dispatch function without re-subscribing,
// so we use a ref to ensure that it always has the latest version.
refs.setSnapshot=setSnapshot;// Check for a possible change between when we last rendered now.
var maybeNewVersion=getVersion(source._source);if(!objectIs(version,maybeNewVersion)){var maybeNewSnapshot=getSnapshot(source._source);{if(typeof maybeNewSnapshot==='function'){error('Mutable source should not return a function as the snapshot value. '+'Functions may close over mutable values and cause tearing.');}}if(!objectIs(snapshot,maybeNewSnapshot)){setSnapshot(maybeNewSnapshot);var lane=requestUpdateLane(fiber);markRootMutableRead(root,lane);}// If the source mutated between render and now,
// there may be state updates already scheduled from the old source.
// Entangle the updates so that they render in the same batch.
markRootEntangled(root,root.mutableReadLanes);}},[getSnapshot,source,subscribe]);// If we got a new source or subscribe function, re-subscribe in a passive effect.
dispatcher.useEffect(function(){var handleChange=function handleChange(){var latestGetSnapshot=refs.getSnapshot;var latestSetSnapshot=refs.setSnapshot;try{latestSetSnapshot(latestGetSnapshot(source._source));// Record a pending mutable source update with the same expiration time.
var lane=requestUpdateLane(fiber);markRootMutableRead(root,lane);}catch(error){// A selector might throw after a source mutation.
// e.g. it might try to read from a part of the store that no longer exists.
// In this case we should still schedule an update with React.
// Worst case the selector will throw again and then an error boundary will handle it.
latestSetSnapshot(function(){throw error;});}};var unsubscribe=subscribe(source._source,handleChange);{if(typeof unsubscribe!=='function'){error('Mutable source subscribe function must return an unsubscribe function.');}}return unsubscribe;},[source,subscribe]);// If any of the inputs to useMutableSource change, reading is potentially unsafe.
//
// If either the source or the subscription have changed we can't can't trust the update queue.
// Maybe the source changed in a way that the old subscription ignored but the new one depends on.
//
// If the getSnapshot function changed, we also shouldn't rely on the update queue.
// It's possible that the underlying source was mutated between the when the last "change" event fired,
// and when the current render (with the new getSnapshot function) is processed.
//
// In both cases, we need to throw away pending updates (since they are no longer relevant)
// and treat reading from the source as we do in the mount case.
if(!objectIs(prevGetSnapshot,getSnapshot)||!objectIs(prevSource,source)||!objectIs(prevSubscribe,subscribe)){// Create a new queue and setState method,
// So if there are interleaved updates, they get pushed to the older queue.
// When this becomes current, the previous queue and dispatch method will be discarded,
// including any interleaving updates that occur.
var newQueue={pending:null,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:snapshot};newQueue.dispatch=setSnapshot=dispatchAction.bind(null,currentlyRenderingFiber$1,newQueue);stateHook.queue=newQueue;stateHook.baseQueue=null;snapshot=readFromUnsubcribedMutableSource(root,source,getSnapshot);stateHook.memoizedState=stateHook.baseState=snapshot;}return snapshot;}function mountMutableSource(source,getSnapshot,subscribe){var hook=mountWorkInProgressHook();hook.memoizedState={refs:{getSnapshot:getSnapshot,setSnapshot:null},source:source,subscribe:subscribe};return useMutableSource(hook,source,getSnapshot,subscribe);}function updateMutableSource(source,getSnapshot,subscribe){var hook=updateWorkInProgressHook();return useMutableSource(hook,source,getSnapshot,subscribe);}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types
initialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={pending:null,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular
next:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();var ref={current:initialValue};{Object.seal(ref);}hook.memoizedState=ref;return ref;}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
if('undefined'!==typeof jest){warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);}}return mountEffectImpl(Update|Passive,Passive$1,create,deps);}function updateEffect(create,deps){{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
if('undefined'!==typeof jest){warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);}}return updateEffectImpl(Update|Passive,Passive$1,create,deps);}function mountLayoutEffect(create,deps){return mountEffectImpl(Update,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create==='undefined'?'undefined':_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return mountEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create==='undefined'?'undefined':_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.
// The react-debug-hooks package injects its own implementation
// so that e.g. DevTools can display custom hook values.
}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.
if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var _mountState=mountState(value),prevValue=_mountState[0],setValue=_mountState[1];mountEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition=1;try{setValue(value);}finally{ReactCurrentBatchConfig$1.transition=prevTransition;}},[value]);return prevValue;}function updateDeferredValue(value){var _updateState=updateState(),prevValue=_updateState[0],setValue=_updateState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition=1;try{setValue(value);}finally{ReactCurrentBatchConfig$1.transition=prevTransition;}},[value]);return prevValue;}function rerenderDeferredValue(value){var _rerenderState=rerenderState(),prevValue=_rerenderState[0],setValue=_rerenderState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition=1;try{setValue(value);}finally{ReactCurrentBatchConfig$1.transition=prevTransition;}},[value]);return prevValue;}function startTransition(setPending,callback){var priorityLevel=getCurrentPriorityLevel();{runWithPriority$1(priorityLevel<UserBlockingPriority$2?UserBlockingPriority$2:priorityLevel,function(){setPending(true);});runWithPriority$1(priorityLevel>NormalPriority$1?NormalPriority$1:priorityLevel,function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition=1;try{setPending(false);callback();}finally{ReactCurrentBatchConfig$1.transition=prevTransition;}});}}function mountTransition(){var _mountState2=mountState(false),isPending=_mountState2[0],setPending=_mountState2[1];// The `start` method can be stored on a ref, since `setPending`
// never changes.
var start=startTransition.bind(null,setPending);mountRef(start);return[start,isPending];}function updateTransition(){var _updateState2=updateState(),isPending=_updateState2[0];var startRef=updateRef();var start=startRef.current;return[start,isPending];}function rerenderTransition(){var _rerenderState2=rerenderState(),isPending=_rerenderState2[0];var startRef=updateRef();var start=startRef.current;return[start,isPending];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function warnOnOpaqueIdentifierAccessInDEV(fiber){{// TODO: Should warn in effects and callbacks, too
var name=getComponentName(fiber.type)||'Unknown';if(getIsRendering()&&!didWarnAboutUseOpaqueIdentifier[name]){error('The object passed back from useOpaqueIdentifier is meant to be '+'passed through to attributes only. Do not read the '+'value directly.');didWarnAboutUseOpaqueIdentifier[name]=true;}}}function mountOpaqueIdentifier(){var makeId=makeClientIdInDEV.bind(null,warnOnOpaqueIdentifierAccessInDEV.bind(null,currentlyRenderingFiber$1));if(getIsHydrating()){var didUpgrade=false;var fiber=currentlyRenderingFiber$1;var readValue=function readValue(){if(!didUpgrade){// Only upgrade once. This works even inside the render phase because
// the update is added to a shared queue, which outlasts the
// in-progress render.
didUpgrade=true;{isUpdatingOpaqueValueInRenderPhase=true;setId(makeId());isUpdatingOpaqueValueInRenderPhase=false;warnOnOpaqueIdentifierAccessInDEV(fiber);}}{{throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");}}};var id=makeOpaqueHydratingObject(readValue);var setId=mountState(id)[1];if((currentlyRenderingFiber$1.mode&BlockingMode)===NoMode){currentlyRenderingFiber$1.flags|=Update|Passive;pushEffect(HasEffect|Passive$1,function(){setId(makeId());},undefined,null);}return id;}else{var _id=makeId();mountState(_id);return _id;}}function updateOpaqueIdentifier(){var id=updateState()[0];return id;}function rerenderOpaqueIdentifier(){var id=rerenderState()[0];return id;}function dispatchAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,eagerReducer:null,eagerState:null,next:null};// Append the update to the end of the list.
var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;var alternate=fiber.alternate;if(fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1){// This is a render phase update. Stash it in a lazily-created map of
// queue -> linked list of updates. After this render pass, we'll restart
// and apply the stashed updates on top of the work-in-progress hook.
didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;}else{if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the
// next state before entering the render phase. If the new state is the
// same as the current state, we may be able to bail out entirely.
var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute
// it, on the update object. If the reducer hasn't changed by the
// time we enter the render phase, then the eager state can be used
// without calling the reducer again.
update.eagerReducer=lastRenderedReducer;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.
// It's still possible that we'll need to rebase this update later,
// if the component re-renders for a different reason and by that
// time the reducer has changed.
return;}}catch(error){// Suppress the error. It will throw again in the render phase.
}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
if('undefined'!==typeof jest){warnIfNotScopedWithMatchingAct(fiber);warnIfNotCurrentlyActingUpdatesInDev(fiber);}}scheduleUpdateOnFiber(fiber,lane,eventTime);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useOpaqueIdentifier:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context,observedBits){return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';mountHookTypesDev();return mountOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context,observedBits){return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';updateHookTypesDev();return mountOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context,observedBits){return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';updateHookTypesDev();return updateOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context,observedBits){return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';updateHookTypesDev();return rerenderOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context,observedBits){warnInvalidContextAccess();return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';warnInvalidHookAccess();mountHookTypesDev();return mountOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context,observedBits){warnInvalidContextAccess();return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';warnInvalidHookAccess();updateHookTypesDev();return updateOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context,observedBits){warnInvalidContextAccess();return _readContext(context,observedBits);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context,observedBits);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource(source,getSnapshot,subscribe);},useOpaqueIdentifier:function useOpaqueIdentifier(){currentHookNameInDev='useOpaqueIdentifier';warnInvalidHookAccess();updateHookTypesDev();return rerenderOpaqueIdentifier();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var profilerStartTime=-1;function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it
// after we rerender. This is used as a helper in special cases
// where we should count the work of multiple passes.
var child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we
// want to reconcile without matching against the existing set. This has the
// effect of all current children being unmounted; even if the type and key
// are the same, the old child is unmounted and a new child is created.
//
// To do this, we're going to go through the reconcile algorithm twice. In
// the first pass, we schedule a deletion for all the current children by
// passing null.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we
// pass null in place of where we usually pass the current child set. This has
// the effect of remounting all children regardless of whether their
// identities match.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens after the first render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent
var nextChildren;prepareToReadContext(workInProgress,renderLanes);{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);if(workInProgress.mode&StrictMode){disableLogs();try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);}finally{reenableLogs();}}setIsRendering(false);}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,updateLanes,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.
Component.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,
// and with only the default shallow comparison, we upgrade it
// to a SimpleMemoComponent to allow fast path updates.
workInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,updateLanes,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(_innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(_type));}}var currentChild=current.child;// This is always exactly one child
if(!includesSomeLane(updateLanes,renderLanes)){// This will be the props with resolved defaultProps,
// unlike current.memoizedProps which will be the unresolved ones.
var prevProps=currentChild.memoizedProps;// Default to shallow comparison
var compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,updateLanes,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens when the inner render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()
// so let's just skip over it to find memo() outer wrapper.
// Inner props for memo are validated later.
var lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.
var outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)
'prop',getComponentName(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.
workInProgress.type===current.type){didReceiveUpdate=false;if(!includesSomeLane(renderLanes,updateLanes)){// The pending lanes were cleared at the beginning of beginWork. We're
// about to bail out, but there might be other lanes that weren't
// included in the current render. Usually, the priority level of the
// remaining updates is accumlated during the evaluation of the
// component (i.e. when processing the update queue). But since since
// we're bailing out early *without* evaluating the component, we need
// to account for it here, too. Reset to the value of the current fiber.
// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
// because a MemoComponent fiber does not have hooks or an update queue;
// rather, it wraps around an inner component, which may or may not
// contains hooks.
// TODO: Move the reset at in beginWork out of the common path so that
// this is no longer necessary.
workInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||nextProps.mode==='unstable-defer-without-hiding'){if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.
// TODO: Figure out what we should do in Blocking mode.
var nextState={baseLanes:NoLanes};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.
{markSpawnedWork(OffscreenLane);}workInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes};workInProgress.memoizedState=_nextState;// We're about to bail out, but we need to push this to the stack anyway
// to avoid a push/pop misalignment.
pushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// Rendering at offscreen, so we can clear the base lanes.
var _nextState2={baseLanes:NoLanes};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.
var subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{var _subtreeRenderLanes;if(prevState!==null){_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);// Since we're not hidden anymore, reset the state
workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing
// special to do. Need to push to the stack regardless, though, to avoid
// a push/pop misalignment.
_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold
// ourselves to this constraint, though. If the behavior diverges, we should
// fork the function.
var updateLegacyHiddenComponent=updateOffscreenComponent;function updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect
workInProgress.flags|=Ref;}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;prepareToReadContext(workInProgress,renderLanes);{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);if(workInProgress.mode&StrictMode){disableLogs();try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);}finally{reenableLogs();}}setIsRendering(false);}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component));}}}// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){if(current!==null){// A class component without an instance only mounts if it suspended
// inside a non-concurrent tree, in an inconsistent state. We want to
// treat it like a new mount, even though an empty version of it already
// committed. Disconnect the alternate pointers.
current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.
shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentName(workInProgress.type)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,
// unmount all the children. componentDidCatch will schedule an update to
// re-render a fallback. This is temporary until we migrate everyone to
// the new API.
// TODO: Warn in a future release.
nextChildren=null;{stopProfilerTimerIfRunning();}}else{{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictMode){disableLogs();try{instance.render();}finally{reenableLogs();}}setIsRendering(false);}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of
// the existing children. Conceptually, the normal children and the children
// that are shown on error are two different sets, so we shouldn't reuse
// normal children even if their identities match.
forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
workInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(!(current!==null&&updateQueue!==null)){{throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");}}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState!==null?prevState.element:null;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;// Caution: React DevTools currently depends on this property
// being called "element".
var nextChildren=nextState.element;if(nextChildren===prevChildren){resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var root=workInProgress.stateNode;if(root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
{var mutableSourceEagerHydrationData=root.mutableSourceEagerHydrationData;if(mutableSourceEagerHydrationData!=null){for(var i=0;i<mutableSourceEagerHydrationData.length;i+=2){var mutableSource=mutableSourceEagerHydrationData[i];var version=mutableSourceEagerHydrationData[i+1];setWorkInProgressVersion(mutableSource,version);}}}var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this
// tree is part of a hydrating tree. This is used to determine if a child
// node has fully mounted yet, and for scheduling event replaying.
// Conceptually this is similar to Placement in that a new subtree is
// inserted into the React tree here. It just happens to not need DOM
// mutations because it already exists.
node.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
reconcileChildren(current,workInProgress,nextChildren,renderLanes);resetHydrationState();}return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also has access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountLazyComponent(_current,workInProgress,elementType,updateLanes,renderLanes){if(_current!==null){// A lazy component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.
workInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only
'prop',getComponentName(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too
updateLanes,renderLanes);return child;}}var hint='';{if(Component!==null&&(typeof Component==='undefined'?'undefined':_typeof(Component))==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent
// because the fact that it's a separate type of work is an
// implementation detail.
{{throw Error("Element type is invalid. Received a promise that resolves to: "+Component+". Lazy element type must resolve to a class or function."+hint);}}}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){if(_current!==null){// An incomplete component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}// Promote the fiber to a class and try rendering again.
workInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`
// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){if(_current!==null){// An indeterminate component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error("The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);setIsRendering(false);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.
// Whether or not it would crash later, we want to show a good message in DEV first.
if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.
// Eventually we'll delete this branch altogether.
(typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentName(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Throw out any hooks that were used.
workInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);var getDerivedStateFromProps=Component.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,props);}adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component
workInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictMode){disableLogs();try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);}finally{reenableLogs();}}}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentName(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentName(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes)};}// TODO: Probably should inline this back
function shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to
// remain on that fallback regardless of whether the content has resolved.
// For example, SuspenseList coordinates when nested content appears.
if(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallack
// is true. More precise name might be "ForceRemainSuspenseFallback".
// Note: This is a factoring smell. Can't remain on a fallback if there's
// no fallback to remain on.
return false;}}// Not currently showing content. Consult the Suspense context.
return hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render
return removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.
{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to
// rendering the fallback children.
showFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content
if(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.
// Mark this subtree context as having at least one invisible parent that could
// handle the fallback state.
// Boundaries without fallbacks or should be avoided are not considered since
// they cannot handle preferred fallback states.
if(nextProps.fallback!==undefined&&nextProps.unstable_avoidThisFallback!==true){suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense
// boundary's children. This involves some custom reconcilation logic. Two
// main reasons this is so complicated.
//
// First, Legacy Mode has different semantics for backwards compatibility. The
// primary tree will commit in an inconsistent state, so when we do the
// second pass to render the fallback, we do some exceedingly, uh, clever
// hacks to make that not totally break. Like transferring effects and
// deletions from hidden tree. In Concurrent Mode, it's much simpler,
// because we bailout on the primary tree completely and leave it in its old
// state, no effects. Same as what we do for Offscreen (except that
// Offscreen doesn't have the first render pass).
//
// Second is hydration. During hydration, the Suspense fiber has a slightly
// different layout, where the child points to a dehydrated fragment, which
// contains the DOM rendered by the server.
//
// Third, even if you set all that aside, Suspense is like error boundaries in
// that we first we try to render one tree, and if that fails, we render again
// and switch to a different tree. Like a try/catch block. So we have to track
// which branch we're currently rendering. Ideally we would model this using
// a stack.
if(current===null){// Initial mount
// If we're currently hydrating, try to hydrate this boundary.
// But only if this has a fallback.
if(nextProps.fallback!==undefined){tryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.
}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else if(typeof nextProps.unstable_expectedLoadTime==='number'){// This is a CPU-bound tree. Skip this tree and show a placeholder to
// unblock the surrounding content. Then immediately retry after the
// initial commit.
var _fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment=workInProgress.child;_primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;// Since nothing actually suspended, there will nothing to ping this to
// get it started back up to attempt the next item. While in terms of
// priority this work has the same priority as this current render, it's
// not part of the same transition once the transition has committed. If
// it's sync, we still want to yield so that it can be painted.
// Conceptually, this is really the same as pinging. We can use any
// RetryLane even if it's the one currently rendering since we're leaving
// it behind on this node.
workInProgress.lanes=SomeRetryLane;{markSpawnedWork(SomeRetryLane);}return _fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren,renderLanes);}}else{// This is an update.
// If the current fiber has a SuspenseState, that means it's already showing
// a fallback.
var prevState=current.memoizedState;if(prevState!==null){if(showFallback){var _nextFallbackChildren2=nextProps.fallback;var _nextPrimaryChildren2=nextProps.children;var _fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren2,_nextFallbackChildren2,renderLanes);var _primaryChildFragment3=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment3.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment3.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment;}else{var _nextPrimaryChildren3=nextProps.children;var _primaryChildFragment4=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren3,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment4;}}else{// The current tree is not already showing a fallback.
if(showFallback){// Timed out.
var _nextFallbackChildren3=nextProps.fallback;var _nextPrimaryChildren4=nextProps.children;var _fallbackChildFragment2=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren4,_nextFallbackChildren3,renderLanes);var _primaryChildFragment5=workInProgress.child;var _prevOffscreenState=current.child.memoizedState;_primaryChildFragment5.memoizedState=_prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(_prevOffscreenState,renderLanes);_primaryChildFragment5.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);// Skip the primary children, and continue working on the
// fallback children.
workInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment2;}else{// Still haven't timed out. Continue rendering the children, like we
// normally do.
var _nextPrimaryChildren5=nextProps.children;var _primaryChildFragment6=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren5,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment6;}}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=createFiberFromOffscreen(primaryChildProps,mode,renderLanes,null);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&BlockingMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=createFiberFromOffscreen(primaryChildProps,mode,NoLanes,null);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function createWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this
// wrapper function to constrain it.
return createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=createWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&BlockingMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment
currentFallbackChildFragment.nextEffect=null;currentFallbackChildFragment.flags=Deletion;workInProgress.firstEffect=workInProgress.lastEffect=currentFallbackChildFragment;}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
(mode&BlockingMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was
// already cloned. In legacy mode, the only case where this isn't true is
// when DevTools forces us to display a fallback; we skip the first render
// pass entirely and go straight to rendering the fallback. (In Concurrent
// Mode, SuspenseList can also trigger this scenario, but this is a legacy-
// only codepath.)
workInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion effect during the first pass.
// However, since we're going to remain on the fallback, we no longer want
// to delete it. So we need to remove it from the list. Deletions are stored
// on the same list as effects. We want to keep the effects from the primary
// tree. So we copy the primary child fragment's effect list, which does not
// include the fallback deletion effect.
var progressedLastEffect=primaryChildFragment.lastEffect;if(progressedLastEffect!==null){workInProgress.firstEffect=primaryChildFragment.firstEffect;workInProgress.lastEffect=progressedLastEffect;progressedLastEffect.nextEffect=null;}else{// TODO: Reset this somewhere else? Lol legacy mode is so weird.
workInProgress.firstEffect=workInProgress.lastEffect=null;}}else{primaryChildFragment=createWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already
// mounted but this is a new fiber.
fallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function scheduleWorkOnFiber(fiber,renderLanes){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleWorkOnParentPath(fiber.return,renderLanes);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.
// If they were previously forced into fallbacks, they may now be able
// to unblock.
var node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleWorkOnFiber(node,renderLanes);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries
// to schedule work on. In this case we have to schedule it on the
// list itself.
// We don't have to traverse to the children of the list since
// the list will propagate the change when it rerenders.
scheduleWorkOnFiber(node,renderLanes);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already
// showing content on the screen, as opposed to being in fallback state or
// new. If a row has multiple Suspense boundaries, any of them being in the
// fallback state, counts as the whole row being in a fallback state.
// Note that the "rows" will be workInProgress, but any nested children
// will still be current since we haven't rendered them yet. The mounted
// order may not be the same as the new order. We use the new order.
var row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('"%s" is not a supported revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('"%s" is not a supported value for tail on <SuspenseList />. '+'Did you mean "collapsed" or "hidden"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail="%s" /> is only valid if revealOrder is '+'"forwards" or "backwards". '+'Did you mean to specify revealOrder="forwards"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isArray=Array.isArray(childSlot);var isIterable=!isArray&&typeof getIteratorFn(childSlot)==='function';if(isArray||isIterable){var type=isArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(Array.isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder="%s" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode,lastEffectBeforeRendering){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode,lastEffect:lastEffectBeforeRendering};}else{// We can reuse the existing object from previous renders.
renderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;renderState.lastEffect=lastEffectBeforeRendering;}}// This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.
function updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work
// on any nested boundaries to let them know to try to render
// again. This is the same as context updating.
propagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&BlockingMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just
// use make it a noop by treating it as the default revealOrder.
workInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.
// TODO: We could fast path by just rendering the tail now.
tail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.
// We're going to render them separately later.
tail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards
tail,lastContentRow,tailMode,workInProgress.lastEffect);break;}case'backwards':{// We're going to find the first row that has existing content.
// At the same time we're going to reverse the list of everything
// we pass in the meantime. That's going to be our tail in reverse
// order.
var _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.
workInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.
initSuspenseListRenderState(workInProgress,true,// isBackwards
_tail,null,// last
tailMode,workInProgress.lastEffect);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards
null,// tail
null,// last
undefined,workInProgress.lastEffect);break;}default:{// The default reveal order is the same as not having
// a boundary.
workInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,newValue);if(oldProps!==null){var oldValue=oldProps.value;var changedBits=calculateChangedBits(context,newValue,oldValue);if(changedBits===0){// No change. Bailout early if children are the same.
if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule
// them to update.
propagateContextChange(workInProgress,context,changedBits,renderLanes);}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In
// DEV mode, we create a separate object for Context.Consumer that acts
// like a proxy to Context. This proxy object adds unnecessary code in PROD
// so we use the old behaviour (Context.Consumer references Context) to
// reduce size and overhead. The separate object references context via
// a property called "_context", which also gives us the ability to check
// in DEV mode if this property exists or not and warn if it does not.
{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).
// Or it may be because it's older React where they're the same thing.
// We only want to warn if we're sure it's a new React.
if(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context,newProps.unstable_observedBits);var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies
workInProgress.dependencies=current.dependencies;}{// Don't update "base" render times for bailouts.
stopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.
if(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.
// TODO: Once we add back resuming, we should check if the children are
// a work-in-progress set. If so, we need to transfer their effects.
return null;}else{// This fiber doesn't have work, but its subtree does. Clone the child
// fibers and continue.
cloneChildFibers(current,workInProgress);return workInProgress.child;}}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){throw new Error('Cannot swap the root fiber.');}// Disconnect from the old current.
// It will get deleted.
current.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.
newWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.
if(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){throw new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){throw new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.
// Since the old fiber is disconnected, we have to schedule it manually.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=current;returnFiber.lastEffect=current;}else{returnFiber.firstEffect=returnFiber.lastEffect=current;}current.nextEffect=null;current.flags=Deletion;newWorkInProgress.flags|=Placement;// Restart work from the new fiber.
return newWorkInProgress;}}function beginWork(current,workInProgress,renderLanes){var updateLanes=workInProgress.lanes;{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.
return remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:
workInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.
// This may be unset if the props are determined to be equal later (memo).
didReceiveUpdate=true;}else if(!includesSomeLane(renderLanes,updateLanes)){didReceiveUpdate=false;// This fiber does not have any pending work. Bailout without entering
// the begin phase. There's still some bookkeeping we that needs to be done
// in this optimized path, mostly pushing stuff onto the stack.
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;pushProvider(workInProgress,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.
var hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){// whether to retry the primary children, or to skip over it and
// go straight to the fallback. Check the priority of the primary
// child fragment.
var primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path
// to attempt to render the primary children again.
return updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked
// on it
pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient
// priority. Bailout.
var child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the
// primary children and work on the fallback.
return child.sibling;}else{return null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the
// same children then we're still in progressive loading state.
// Something might get unblocked by state updates or retries in the
// tree which will affect the tail. So we need to use the normal
// path to compute the correct tail.
return updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
workInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,
// then the tail doesn't matter. Anything new that suspends will work
// in the "together" mode, so we can continue from the state we had.
var renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the "together" mode in case we've started a different
// update in the past but didn't complete it.
renderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
return null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is
// almost identical to the logic used in the normal update path,
// so we'll just enter that. The only difference is we'll bail out
// at the next level instead of this one, because the child props
// have not changed. Which is fine.
// TODO: Probably should refactor `beginWork` to split the bailout
// path from the normal path. I'm tempted to do a labeled break here
// but I won't :)
workInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else{if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props
// nor legacy context. Set this to false. If an update queue or context
// consumer produces a changed value, it will set this to true. Otherwise,
// the component will assume the children have not changed and bail out.
didReceiveUpdate=false;}}}else{didReceiveUpdate=false;}// Before entering the begin phase, clear pending update priority.
// TODO: This assumes that we're about to evaluate the component and process
// the update queue. However, there's an exception: SimpleMemoComponent
// sometimes bails out later in the begin phase. This indicates that we should
// move this assignment out of the common path and into each branch.
workInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,updateLanes,renderLanes);}case FunctionComponent:{var _Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===_Component?unresolvedProps:resolveDefaultProps(_Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,_Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component2?_unresolvedProps:resolveDefaultProps(_Component2,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component2,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.
var _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only
'prop',getComponentName(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,updateLanes,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,updateLanes,renderLanes);}case IncompleteClassComponent:{var _Component3=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component3?_unresolvedProps4:resolveDefaultProps(_Component3,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component3,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case FundamentalComponent:{break;}case ScopeComponent:{break;}case Block:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}case LegacyHiddenComponent:{return updateLegacyHiddenComponent(current,workInProgress,renderLanes);}}{{throw Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}}}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// a PlacementAndUpdate.
workInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode
appendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
// we won't touch this node even if children changed.
return;}// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
// component is hitting the resume path. Figure out why. Possibly
// related to `hidden`.
var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can
// so we don't leave any behind.
return;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(lastTailNode===null){// All remaining items in the tail are insertions.
renderState.tail=null;}else{// Detach the insertion after the last node that was already
// inserted.
lastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(_lastTailNode===null){// All remaining items in the tail are insertions.
if(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one
// row at the tail. So we'll keep on and cut off the rest.
renderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already
// inserted.
_lastTailNode.sibling=null;}break;}}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for
// the commit side-effects on the root.
markUpdate(workInProgress);}else if(!fiberRoot.hydrate){// Schedule an effect to clear this container at the start of the next commit.
// This handles the case of React rendering into a container with previous children.
// It's also safe to do for updates too, because current.child would only be null
// if the previous render was null (so the the container would already be empty).
workInProgress.flags|=Snapshot;}}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(!(workInProgress.stateNode!==null)){{throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");}}// This can happen when we abort work.
return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on whether we want to add them top->down or
// bottom->up. Top->down is faster in IE11.
var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef$1(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(!(workInProgress.stateNode!==null)){{throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");}}// This can happen when we abort work.
}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.
workInProgress.lanes=renderLanes;// Do not reset the effect list.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=false;if(current===null){if(workInProgress.memoizedProps.fallback!==undefined){popHydrationState(workInProgress);}}else{var prevState=current.memoizedState;prevDidTimeout=prevState!==null;}if(nextDidTimeout&&!prevDidTimeout){// If this subtreee is running in blocking mode we can suspend,
// otherwise we won't suspend.
// TODO: This will still suspend a synchronous tree if anything
// in the concurrent tree already suspended during this render.
// This is a known bug.
if((workInProgress.mode&BlockingMode)!==NoMode){// TODO: Move this back to throwException because this is too late
// if this is a large tree which is common for initial loads. We
// don't know if we should restart a render or not until we get
// this marker, and this is too late.
// If this render already had a ping or lower pri updates,
// and this is the first time we know we're going to suspend we
// should be able to immediately restart from within throwException.
var hasInvisibleChildContext=current===null&&workInProgress.memoizedProps.unstable_avoidThisFallback!==true;if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing
// this boundary is ok.
renderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should
// suspend for longer if possible.
renderDidSuspendDelayIfPossible();}}}{// TODO: Only schedule updates if these values are non equal, i.e. it changed.
if(nextDidTimeout||prevDidTimeout){// If this boundary just timed out, schedule an effect to attach a
// retry listener to the promise. This flag is also used to hide the
// primary children. In mutation mode, we also need the flag to
// *unhide* children that were previously hidden, so check if this
// is currently timed out, too.
workInProgress.flags|=Update;}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}return null;case ContextProvider:// Pop provider fiber
popProvider(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are
// sequential to ensure this switch is compiled to a jump table.
var _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, "independent" mode.
// We don't do anything in this mode.
return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.
if(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still
// suspended in the rendered set.
// If new content unsuspended, but there's still some content that
// didn't. Then we need to do a second pass that forces everything
// to keep showing their fallbacks.
// We might be suspended if something in this render pass suspended, or
// something in the previous committed pass suspended. Otherwise,
// there's no chance so we can skip the expensive call to
// findFirstSuspended.
var cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as
// part of the second pass. In that case nothing will subscribe to
// its thennables. Instead, we'll transfer its thennables to the
// SuspenseList so that it can retry if they resolve.
// There might be multiple of these in the list but since we're
// going to wait for all of them anyway, it doesn't really matter
// which ones gets to ping. In theory we could get clever and keep
// track of how many dependencies remain but it gets tricky because
// in the meantime, we can add/remove/change items and dependencies.
// We might bail out of the loop before finding any but that
// doesn't matter since that means that the other boundaries that
// we did find already has their listeners attached.
var newThennables=suspended.updateQueue;if(newThennables!==null){workInProgress.updateQueue=newThennables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks
// to stay in place.
// Reset the effect list before doing the second pass since that's now invalid.
if(renderState.lastEffect===null){workInProgress.firstEffect=null;}workInProgress.lastEffect=renderState.lastEffect;// Reset the child fibers to their original state.
resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately
// rerender the children.
pushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));return workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows
// left in the tail. We'll just give up further attempts to render
// the main content and only render fallbacks.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;{markSpawnedWork(SomeRetryLane);}}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.
}else{// Append the rendered row to the child list.
if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't
// get lost if this row ends up dropped during a second pass.
var _newThennables=_suspended.updateQueue;if(_newThennables!==null){workInProgress.updateQueue=_newThennables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.
if(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.
){// We need to delete the row we just rendered.
// Reset the effect list to what it was before we rendered this
// child. The nested children have already appended themselves.
var lastEffect=workInProgress.lastEffect=renderState.lastEffect;// Remove any effects that were appended after this point.
if(lastEffect!==null){lastEffect.nextEffect=null;}// We're done.
return null;}}else if(// The time it took to render last row is greater than the remaining
// time we have to render. So rendering one more row would likely
// exceed it.
now()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further
// attempts to render the main content and only render fallbacks.
// The assumption is that this is usually faster.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;{markSpawnedWork(SomeRetryLane);}}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added
// to the end. This breaks the guarantee that life-cycles fire in
// sibling order but that isn't a strong guarantee promised by React.
// Especially since these might also just pop in during future commits.
// Append to the beginning of the list.
renderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.
// Pop a row.
var next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.lastEffect=workInProgress.lastEffect;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.
// TODO: We can probably just avoid popping it instead and only
// setting it the first time we go from not suspended to suspended.
var suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.
return next;}return null;}case FundamentalComponent:{break;}case ScopeComponent:{break;}case Block:break;case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);if(current!==null){var _nextState=workInProgress.memoizedState;var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;var nextIsHidden=_nextState!==null;if(prevIsHidden!==nextIsHidden&&newProps.mode!=='unstable-defer-without-hiding'){workInProgress.flags|=Update;}}return null;}}{{throw Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}}}function unwindWork(workInProgress,renderLanes){switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if(!((_flags&DidCapture)===NoFlags)){{throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");}}workInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}case HostComponent:{// TODO: popHydrationState
popHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been
// caught by a nested boundary. If not, it should bubble through.
return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:popProvider(workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;default:return null;}}function unwindInterruptedWork(interruptedWork){switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:popProvider(interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown
// so the stack is accurate.
return{value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling
// `preventDefault()` in window `error` handler.
// We record this information as an expando on the error.
if(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.
// Ignore it and don't print the stack addendum.
// This is handy for testing error boundaries without noise.
return;}// The error is fatal. Since the silencing might have
// been accidental, we'll surface it anyway.
// However, the browser would have silenced the original error
// so we'll print it first, and then print the stack addendum.
console['error'](error);// Don't transform to our wrapper
// For a more detailed description of this block, see:
// https://github.com/facebook/react/pull/13384
}var componentName=source?getComponentName(source.type):null;var componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":'The above error occurred in one of your React components:';var errorBoundaryMessage;var errorBoundaryName=getComponentName(boundary.type);if(errorBoundaryName){errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".");}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}var combinedMessage=componentNameMessage+"\n"+componentStack+"\n\n"+(""+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console['error'](combinedMessage);// Don't transform to our wrapper
}else{// In production, we print the error directly.
// This will include the message, the JS stack, and anything the browser wants to show.
// We pass the error object instead of custom message so that the browser displays the error natively.
console['error'](error);// Don't transform to our wrapper
}}catch(e){// This method must not throw, or React internal state will get messed up.
// If console.error is overridden, or logCapturedError() shows a dialog that throws,
// we want to report this error outside of the normal stack as a last resort.
// https://github.com/facebook/react/issues/13188
setTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.
update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){logCapturedError(fiber,errorInfo);return getDerivedStateFromError(error$1);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,
// we keep track of which ones already failed during this batch.
// This gets reset before we yield back to the browser.
// TODO: Warn in strict mode if getDerivedStateFromError is
// not defined.
markLegacyErrorBoundaryAsFailed(this);// Only log here if componentDidCatch is the only error boundary method defined
logCapturedError(fiber,errorInfo);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,
// then it needs to call setState to recover from errors.
// If no state update is scheduled then the boundary will swallow the error.
if(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentName(fiber.type)||'Unknown');}}}};}else{update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber);};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a listener to the promise to "ping" the root and retry. But only if
// one does not already exist for the lanes we're currently rendering (which
// acts like a "thread ID" here).
var pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.
threadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);wakeable.then(ping,ping);}}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.
sourceFiber.flags|=Incomplete;// Its effect list is no longer valid.
sourceFiber.firstEffect=sourceFiber.lastEffect=null;if(value!==null&&(typeof value==='undefined'?'undefined':_typeof(value))==='object'&&typeof value.then==='function'){// This is a wakeable.
var wakeable=value;if((sourceFiber.mode&BlockingMode)===NoMode){// Reset the memoizedState to what it was before we attempted
// to render it.
var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}var hasInvisibleParentBoundary=hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext);// Schedule the nearest Suspense to re-render the timed out view.
var _workInProgress=returnFiber;do{if(_workInProgress.tag===SuspenseComponent&&shouldCaptureSuspense(_workInProgress,hasInvisibleParentBoundary)){// Found the nearest boundary.
// Stash the promise on the boundary fiber. If the boundary times out, we'll
// attach another listener to flip the boundary back to its normal state.
var wakeables=_workInProgress.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);_workInProgress.updateQueue=updateQueue;}else{wakeables.add(wakeable);}// If the boundary is outside of blocking mode, we should *not*
// suspend the commit. Pretend as if the suspended component rendered
// null and keep rendering. In the commit phase, we'll schedule a
// subsequent synchronous update to re-render the Suspense.
//
// Note: It doesn't matter whether the component that suspended was
// inside a blocking mode tree. If the Suspense is outside of it, we
// should *not* suspend the commit.
if((_workInProgress.mode&BlockingMode)===NoMode){_workInProgress.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.
// But we shouldn't call any lifecycle methods or callbacks. Remove
// all lifecycle effect tags.
sourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a
// completed class component. For example, we should not call
// componentWillUnmount if it is deleted.
sourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,
// since it's known to be in an inconsistent state. Use a force update to
// prevent a bail out.
var update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update);}}// The source fiber did not complete. Mark it with Sync priority to
// indicate that it still has pending work.
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);// Exit without suspending.
return;}// Confirmed that the boundary is in a concurrent mode tree. Continue
// with the normal suspend path.
//
// After this we'll use a set of heuristics to determine whether this
// render pass will run to completion or restart or "suspend" the commit.
// The actual logic for this is spread out in different places.
//
// This first principle is that if we're going to suspend when we complete
// a root, then we should also restart if we get an update or ping that
// might unsuspend it, and vice versa. The only reason to suspend is
// because you think you might want to restart before committing. However,
// it doesn't make sense to restart only while in the period we're suspended.
//
// Restarting too aggressively is also not good because it starves out any
// intermediate loading state. So we use heuristics to determine when.
// Suspense Heuristics
//
// If nothing threw a Promise or all the same fallbacks are already showing,
// then don't suspend/restart.
//
// If this is an initial render of a new tree of Suspense boundaries and
// those trigger a fallback, then don't suspend/restart. We want to ensure
// that we can show the initial loading state as quickly as possible.
//
// If we hit a "Delayed" case, such as when we'd switch from content back into
// a fallback, then we should always suspend/restart. Transitions apply
// to this case. If none is defined, JND is used instead.
//
// If we're already showing a fallback and it gets "retried", allowing us to show
// another level, but there's still an inner boundary that would show a fallback,
// then we suspend/restart for 500ms since the last time we showed a fallback
// anywhere in the tree. This effectively throttles progressive loading into a
// consistent train of commits. This also gives us an opportunity to restart to
// get to the completed state slightly earlier.
//
// If there's ambiguity due to batching it's resolved in preference of:
// 1) "delayed", 2) "initial render", 3) "retry".
//
// We want to ensure that a "busy" state doesn't get force committed. We want to
// ensure that new initial loading states can commit as soon as possible.
attachPingListener(root,wakeable,rootRenderLanes);_workInProgress.flags|=ShouldCapture;_workInProgress.lanes=rootRenderLanes;return;}// This boundary already captured during this render. Continue to the next
// boundary.
_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// No boundary was found. Fallthrough to error mode.
// TODO: Use invariant so the message is stripped in prod?
value=new Error((getComponentName(sourceFiber.type)||'A React component')+' suspended while rendering, but no fallback UI was specified.\n'+'\n'+'Add a <Suspense fallback=...> component higher in the tree to '+'provide a loading indicator or placeholder to display.');}// We didn't find a boundary that could handle this type of exception. Start
// over and traverse parent path again, this time treating the exception
// as an error.
renderDidError();value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var _update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,_update);return;}case ClassComponent:// Capture and retry
var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state
var _update2=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update2);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;{instance.componentWillUnmount();}};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError()){var unmountError=clearCaughtError();captureCommitPhaseError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){{invokeGuardedCallback(null,ref,null,null);if(hasCaughtError()){var refError=clearCaughtError();captureCommitPhaseError(current,refError);}}}else{ref.current=null;}}}function safelyCallDestroy(current,destroy){{invokeGuardedCallback(null,destroy,null);if(hasCaughtError()){var error=clearCaughtError();captureCommitPhaseError(current,error);}}}function commitBeforeMutationLifeCycles(current,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:case Block:{return;}case ClassComponent:{if(finishedWork.flags&Snapshot){if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentName(finishedWork.type));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}}return;}case HostRoot:{{if(finishedWork.flags&Snapshot){var root=finishedWork.stateNode;clearContainer(root.containerInfo);}}return;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types
return;}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function commitHookEffectListUnmount(tag,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&tag)===tag){// Unmount
var destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){destroy();}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(tag,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&tag)===tag){// Mount
var create=effect.create;effect.destroy=create();{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\n\n'+'useEffect(() => {\n'+'  async function fetchData() {\n'+'    // You can await here\n'+'    const response = await MyAPI.getData(someId);\n'+'    // ...\n'+'  }\n'+'  fetchData();\n'+"}, [someId]); // Or [] if effect doesn't need props or state\n\n"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('An effect function must not return anything besides a function, '+'which is used for clean-up.%s',addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function schedulePassiveEffects(finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,next=_effect.next,tag=_effect.tag;if((tag&Passive$1)!==NoFlags$1&&(tag&HasEffect)!==NoFlags$1){enqueuePendingPassiveHookEffectUnmount(finishedWork,effect);enqueuePendingPassiveHookEffectMount(finishedWork,effect);}effect=next;}while(effect!==firstEffect);}}function commitLifeCycles(finishedRoot,current,finishedWork,committedLanes){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:case Block:{// At this point layout effects have already been destroyed (during mutation phase).
// This is done to prevent sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
{commitHookEffectListMount(Layout|HasEffect,finishedWork);}schedulePassiveEffects(finishedWork);return;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(current===null){// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance');}}}// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
commitUpdateQueue(finishedWork,updateQueue,instance);}return;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();if(typeof onRender==='function'){{onRender(finishedWork.memoizedProps.id,current===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime,finishedRoot.memoizedInteractions);}}}return;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);return;}case SuspenseListComponent:case IncompleteClassComponent:case FundamentalComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:return;}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function hideOrUnhideAllChildren(finishedWork,isHidden){{// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent){var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}else if(node.tag===HostText){var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag
if(typeof ref==='function'){ref(instanceToUse);}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentName(finishedWork.type));}}ref.current=instanceToUse;}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){if(typeof currentRef==='function'){currentRef(null);}else{currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(finishedRoot,current,renderPriorityLevel){onCommitUnmount(current);switch(current.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:case Block:{var updateQueue=current.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect2=effect,destroy=_effect2.destroy,tag=_effect2.tag;if(destroy!==undefined){if((tag&Passive$1)!==NoFlags$1){enqueuePendingPassiveHookEffectUnmount(current,effect);}else{{safelyCallDestroy(current,destroy);}}}effect=effect.next;}while(effect!==firstEffect);}}return;}case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
{unmountHostComponents(finishedRoot,current);}return;}case FundamentalComponent:{return;}case DehydratedFragment:{return;}case ScopeComponent:{return;}}}function commitNestedUnmounts(finishedRoot,root,renderPriorityLevel){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
// we do an inner loop while we're still inside the host node.
var node=root;while(true){commitUnmount(finishedRoot,node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node.return===null||node.return===root){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function detachFiberMutation(fiber){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
// Note: we cannot null out sibling here, otherwise it can cause issues
// with findDOMNode and how it requires the sibling field to carry out
// traversal in a later effect. See PR #16820. We now clear the sibling
// field after effects, see: detachFiberAfterEffects.
//
// Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
// It may be required if the current component is an error boundary,
// and one of its descendants throws while unmounting a passive effect.
fiber.alternate=null;fiber.child=null;fiber.dependencies=null;fiber.firstEffect=null;fiber.lastEffect=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.return=null;fiber.updateQueue=null;{fiber._debugOwner=null;}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}{{throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");}}}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
// TODO: Find a more efficient way to do this.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.flags&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.flags&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
var parent;var isContainer;var parentStateNode=parentFiber.stateNode;switch(parentFiber.tag){case HostComponent:parent=parentStateNode;isContainer=false;break;case HostRoot:parent=parentStateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentStateNode.containerInfo;isContainer=true;break;case FundamentalComponent:// eslint-disable-next-line-no-fallthrough
default:{{throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");}}}if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
if(isContainer){insertOrAppendPlacementNodeIntoContainer(finishedWork,before,parent);}else{insertOrAppendPlacementNode(finishedWork,before,parent);}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost||enableFundamentalAPI){var stateNode=isHost?node.stateNode:node.stateNode.instance;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost||enableFundamentalAPI){var stateNode=isHost?node.stateNode:node.stateNode.instance;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}function unmountHostComponents(finishedRoot,current,renderPriorityLevel){// We only have the top Fiber that was deleted but we need to recurse down its
// children to find all the terminal nodes.
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;// Note: these two variables *must* always be updated together.
var currentParent;var currentParentIsContainer;while(true){if(!currentParentIsValid){var parent=node.return;findParent:while(true){if(!(parent!==null)){{throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");}}var parentStateNode=parent.stateNode;switch(parent.tag){case HostComponent:currentParent=parentStateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent.return;}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(finishedRoot,node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){if(node.child!==null){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;currentParentIsContainer=true;// Visit children because portals might contain host components.
node.child.return=node;node=node.child;continue;}}else{commitUnmount(finishedRoot,node);// Visit children because we may find more host components below.
if(node.child!==null){node.child.return=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node.return===null||node.return===current){return;}node=node.return;if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling.return=node.return;node=node.sibling;}}function commitDeletion(finishedRoot,current,renderPriorityLevel){{// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(finishedRoot,current);}var alternate=current.alternate;detachFiberMutation(current);if(alternate!==null){detachFiberMutation(alternate);}}function commitWork(current,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:case Block:{// Layout effects are destroyed during the mutation phase so that all
// destroy functions for all fibers are called before any create functions.
// This prevents sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
{commitHookEffectListUnmount(Layout|HasEffect,finishedWork);}return;}case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps);}}return;}case HostText:{if(!(finishedWork.stateNode!==null)){{throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");}}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{{var _root=finishedWork.stateNode;if(_root.hydrate){// We've just hydrated. No need to hydrate again.
_root.hydrate=false;commitHydratedContainer(_root.containerInfo);}}return;}case Profiler:{return;}case SuspenseComponent:{commitSuspenseComponent(finishedWork);attachSuspenseRetryListeners(finishedWork);return;}case SuspenseListComponent:{attachSuspenseRetryListeners(finishedWork);return;}case IncompleteClassComponent:{return;}case FundamentalComponent:{break;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{var newState=finishedWork.memoizedState;var isHidden=newState!==null;hideOrUnhideAllChildren(finishedWork,isHidden);return;}}{{throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}}function commitSuspenseComponent(finishedWork){var newState=finishedWork.memoizedState;if(newState!==null){markCommitTimeOfFallback();{// Hide the Offscreen component that contains the primary children. TODO:
// Ideally, this effect would have been scheduled on the Offscreen fiber
// itself. That's how unhiding works: the Offscreen component schedules an
// effect on itself. However, in this case, the component didn't complete,
// so the fiber was never added to the effect list in the normal path. We
// could have appended it to the effect list in the Suspense component's
// second pass, but doing it this way is less complicated. This would be
// simpler if we got rid of the effect list and traversed the tree, like
// we're planning to do.
var primaryChildParent=finishedWork.child;hideOrUnhideAllChildren(primaryChildParent,true);}}}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.
// For each wakeable, attach a listener so that when it resolves, React
// attempts to re-render the boundary in the primary (pre-timeout) state.
var wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.
var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){{if(wakeable.__reactDoNotTraceInteractions!==true){retry=tracing.unstable_wrap(retry);}}retryCache.add(wakeable);wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.
// It returns false if the boundary is already hidden.
// TODO: Use an effect tag.
function isSuspenseBoundaryBeingHidden(current,finishedWork){if(current!==null){var oldState=current.memoizedState;if(oldState===null||oldState.dehydrated!==null){var newState=finishedWork.memoizedState;return newState!==null&&newState.dehydrated===null;}}return false;}function commitResetTextContent(current){resetTextContent(current.stateNode);}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol.for){var symbolFor$1=Symbol.for;COMPONENT_TYPE=symbolFor$1('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor$1('selector.has_pseudo_class');ROLE_TYPE=symbolFor$1('selector.role');TEST_NAME_TYPE=symbolFor$1('selector.test_id');TEXT_TYPE=symbolFor$1('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,IsSomeRendererActing=ReactSharedInternals.IsSomeRendererActing;var NoContext=/*             */0;var BatchedContext=/*               */1;var EventContext=/*                 */2;var DiscreteEventContext=/*         */4;var LegacyUnbatchedContext=/*       */8;var RenderContext=/*                */16;var CommitContext=/*                */32;var RetryAfterError=/*       */64;var RootIncomplete=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;// Describes where we are in the React execution stack
var executionContext=NoContext;// The root we're working on
var workInProgressRoot=null;// The fiber we're working on
var workInProgress=null;// The lanes we're rendering
var workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.
var subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.
var workInProgressRootExitStatus=RootIncomplete;// A fatal error, if one is thrown
var workInProgressRootFatalError=null;// "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.
var workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.
var workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.
var workInProgressRootUpdatedLanes=NoLanes;// Lanes that were pinged (in an interleaved event) during this render.
var workInProgressRootPingedLanes=NoLanes;var mostRecentlyUpdatedRoot=null;// The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.
var globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.
var workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.
var RENDER_TIMEOUT_MS=500;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var nextEffect=null;var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;var rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsRenderPriority=NoPriority$1;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveHookEffectsMount=[];var pendingPassiveHookEffectsUnmount=[];var rootsWithPendingDiscreteUpdates=null;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;// Marks the need to reschedule pending interactions at these lanes
// during the commit phase. This enables them to be traced across components
// that spawn new work during render. E.g. hidden boundaries, suspended SSR
// hydration or SuspenseList.
// TODO: Can use a bitmask instead of an array
var spawnedWorkDuringRender=null;// If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.
var currentEventTime=NoTimestamp;var currentEventWipLanes=NoLanes;var currentEventPendingLanes=NoLanes;// Dev only flag that tracks if passive effects are currently being flushed.
// We warn about state updates for unmounted components differently in this case.
var isFlushingPassiveEffects=false;var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.
return now();}// We're not inside React, so we may be in the middle of a browser event.
if(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.
return currentEventTime;}// This is the first update since React yielded. Compute a new start time.
currentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases
var mode=fiber.mode;if((mode&BlockingMode)===NoMode){return SyncLane;}else if((mode&ConcurrentMode)===NoMode){return getCurrentPriorityLevel()===ImmediatePriority$1?SyncLane:SyncBatchedLane;}// The algorithm for assigning an update to a lane should be stable for all
// updates at the same priority within the same event. To do this, the inputs
// to the algorithm must be the same. For example, we use the `renderLanes`
// to avoid choosing a lane that is already in the middle of rendering.
//
// However, the "included" lanes could be mutated in between updates in the
// same event, like if you perform an update inside `flushSync`. Or any other
// code path that might call `prepareFreshStack`.
//
// The trick we use is to cache the first of each of these inputs within an
// event. Then reset the cached values once we can be sure the event is over.
// Our heuristic for that is whenever we enter a concurrent work loop.
//
// We'll do the same for `currentEventPendingLanes` below.
if(currentEventWipLanes===NoLanes){currentEventWipLanes=workInProgressRootIncludedLanes;}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(currentEventPendingLanes!==NoLanes){currentEventPendingLanes=mostRecentlyUpdatedRoot!==null?mostRecentlyUpdatedRoot.pendingLanes:NoLanes;}return findTransitionLane(currentEventWipLanes,currentEventPendingLanes);}// TODO: Remove this dependency on the Scheduler priority.
// To do that, we're replacing it with an update lane priority.
var schedulerPriority=getCurrentPriorityLevel();// The old behavior was using the priority level of the Scheduler.
// This couples React to the Scheduler internals, so we're replacing it
// with the currentUpdateLanePriority above. As an example of how this
// could be problematic, if we're not inside `Scheduler.runWithPriority`,
// then we'll get the priority of the current running Scheduler task,
// which is probably not what we want.
var lane;if(// TODO: Temporary. We're removing the concept of discrete updates.
(executionContext&DiscreteEventContext)!==NoContext&&schedulerPriority===UserBlockingPriority$2){lane=findUpdateLane(InputDiscreteLanePriority,currentEventWipLanes);}else{var schedulerLanePriority=schedulerPriorityToLanePriority(schedulerPriority);lane=findUpdateLane(schedulerLanePriority,currentEventWipLanes);}return lane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense
// "retries" — a special update that attempts to flip a Suspense boundary
// from its placeholder state to its primary/resolved state.
// Special cases
var mode=fiber.mode;if((mode&BlockingMode)===NoMode){return SyncLane;}else if((mode&ConcurrentMode)===NoMode){return getCurrentPriorityLevel()===ImmediatePriority$1?SyncLane:SyncBatchedLane;}// See `requestUpdateLane` for explanation of `currentEventWipLanes`
if(currentEventWipLanes===NoLanes){currentEventWipLanes=workInProgressRootIncludedLanes;}return findRetryLane(currentEventWipLanes);}function scheduleUpdateOnFiber(fiber,lane,eventTime){checkForNestedUpdates();warnAboutRenderPhaseUpdatesInDEV(fiber);var root=markUpdateLaneFromFiberToRoot(fiber,lane);if(root===null){warnAboutUpdateOnUnmountedFiberInDEV(fiber);return null;}// Mark that the root has a pending update.
markRootUpdated(root,lane,eventTime);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark
// that there was an interleaved update work on this root. Unless the
// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
// phase update. In that case, we don't treat render phase updates as if
// they were interleaved, for backwards compat reasons.
{workInProgressRootUpdatedLanes=mergeLanes(workInProgressRootUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render
// definitely won't finish. Since we have a new update, let's mark it as
// suspended now, right before marking the incoming update. This has the
// effect of interrupting the current render and switching to the update.
// TODO: Make sure this doesn't override pings that happen while we've
// already started rendering.
markRootSuspended$1(root,workInProgressRootRenderLanes);}}// TODO: requestUpdateLanePriority also reads the priority. Pass the
// priority as an argument to that function and this one.
var priorityLevel=getCurrentPriorityLevel();if(lane===SyncLane){if(// Check if we're inside unbatchedUpdates
(executionContext&LegacyUnbatchedContext)!==NoContext&&// Check if we're not already rendering
(executionContext&(RenderContext|CommitContext))===NoContext){// Register pending interactions on the root to avoid losing traced interaction data.
schedulePendingInteractions(root,lane);// This is a legacy edge case. The initial mount of a ReactDOM.render-ed
// root inside of batchedUpdates should be synchronous, but layout updates
// should be deferred until the end of the batch.
performSyncWorkOnRoot(root);}else{ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,lane);if(executionContext===NoContext){// Flush the synchronous work now, unless we're already working or inside
// a batch. This is intentionally inside scheduleUpdateOnFiber instead of
// scheduleCallbackForFiber to preserve the ability to schedule a callback
// without immediately flushing it. We only do this for user-initiated
// updates, to preserve historical behavior of legacy mode.
resetRenderTimer();flushSyncCallbackQueue();}}}else{// Schedule a discrete update but only if it's not Sync.
if((executionContext&DiscreteEventContext)!==NoContext&&(// Only updates at user-blocking priority or greater are considered
// discrete, even inside a discrete event.
priorityLevel===UserBlockingPriority$2||priorityLevel===ImmediatePriority$1)){// This is the result of a discrete event. Track the lowest priority
// discrete update per root so we can flush them early, if needed.
if(rootsWithPendingDiscreteUpdates===null){rootsWithPendingDiscreteUpdates=new Set([root]);}else{rootsWithPendingDiscreteUpdates.add(root);}}// Schedule other updates after in case the callback is sync.
ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,lane);}// We use this when assigning a lane for a transition inside
// `requestUpdateLane`. We assume it's the same as the root being updated,
// since in the common case of a single root app it probably is. If it's not
// the same root, then it's not a huge deal, we just might batch more stuff
// together more than necessary.
mostRecentlyUpdatedRoot=root;}// This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.
function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child expiration time.
var node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}// Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.
function ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as
// expired so we know to work on those next.
markStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.
var nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);// This returns the priority level computed during the `getNextLanes` call.
var newCallbackPriority=returnNextLanesPriority();if(nextLanes===NoLanes){// Special case: There's nothing to work on.
if(existingCallbackNode!==null){cancelCallback(existingCallbackNode);root.callbackNode=null;root.callbackPriority=NoLanePriority;}return;}// Check if there's an existing task. We may be able to reuse it.
if(existingCallbackNode!==null){var existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority){// The priority hasn't changed. We can reuse the existing task. Exit.
return;}// The priority changed. Cancel the existing callback. We'll schedule a new
// one below.
cancelCallback(existingCallbackNode);}// Schedule a new callback.
var newCallbackNode;if(newCallbackPriority===SyncLanePriority){// Special case: Sync React callbacks are scheduled on a special
// internal queue
newCallbackNode=scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}else if(newCallbackPriority===SyncBatchedLanePriority){newCallbackNode=scheduleCallback(ImmediatePriority$1,performSyncWorkOnRoot.bind(null,root));}else{var schedulerPriorityLevel=lanePriorityToSchedulerPriority(newCallbackPriority);newCallbackNode=scheduleCallback(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.
function performConcurrentWorkOnRoot(root){// Since we know we're in a React event, we can clear the current
// event time. The next update will compute a new event time.
currentEventTime=NoTimestamp;currentEventWipLanes=NoLanes;currentEventPendingLanes=NoLanes;if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}// Flush any pending passive effects before deciding which lanes to work on,
// in case they schedule additional work.
var originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.
// Check if the task node for this root was changed.
if(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call
// `ensureRootIsScheduled` because the check above implies either that
// there's a new task, or that there's no remaining work on this root.
return null;}}// Determine the next expiration time to work on, using the fields stored
// on the root.
var lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.
return null;}var exitStatus=renderRootConcurrent(root,lanes);if(includesSomeLane(workInProgressRootIncludedLanes,workInProgressRootUpdatedLanes)){// The render included lanes that were updated during the render phase.
// For example, when unhiding a hidden tree, we include all the lanes
// that were previously skipped when the tree was hidden. That set of
// lanes is a superset of the lanes we started rendering with.
//
// So we'll throw out the current work and restart.
prepareFreshStack(root,NoLanes);}else if(exitStatus!==RootIncomplete){if(exitStatus===RootErrored){executionContext|=RetryAfterError;// If an error occurred during hydration,
// discard server response and fall back to client side render.
if(root.hydrate){root.hydrate=false;clearContainer(root.containerInfo);}// If something threw an error, try rendering one more time. We'll render
// synchronously to block concurrent data mutations, and we'll includes
// all pending updates are included. If it still fails after the second
// attempt, we'll give up and commit the resulting tree.
lanes=getLanesToRetrySynchronouslyOnError(root);if(lanes!==NoLanes){exitStatus=renderRootSync(root,lanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}// We now have a consistent tree. The next step is either to commit it,
// or, if something suspended, wait to commit it after a timeout.
var finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's
// currently executed. Need to return a continuation.
return performConcurrentWorkOnRoot.bind(null,root);}return null;}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootIncomplete:case RootFatalErrored:{{{throw Error("Root did not complete. This is a bug in React.");}}}// Flow knows about invariant, so it complains if I add a break
// statement, but eslint doesn't know about invariant, so it complains
// if I do. eslint-disable-next-line no-fallthrough
case RootErrored:{// We should have already attempted to retry this tree. If we reached
// this point, it errored again. Commit it.
commitRoot(root);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we
// should immediately commit it or wait a bit.
if(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope
!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing
// retries so that we don't show too many loading states too quickly.
var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.
if(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.
break;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last
// suspended level. Ping the last suspended level to try
// rendering it again.
// FIXME: What if the suspended lanes are Idle? Should not restart.
var eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no
// lower priority work to do. Instead of committing the fallback
// immediately, wait for more data to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root),msUntilTimeout);break;}}// The work expired. Commit immediately.
commitRoot(root);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a
// placeholder and without scheduling a timeout. Delay indefinitely
// until we receive more data.
break;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.
// Schedule a placeholder to display after a short delay, using the Just
// Noticeable Difference.
// TODO: Is the JND optimization worth the added complexity? If this is
// the only reason we track the event time, then probably not.
// Consider removing.
var mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.
if(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data
// to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root),_msUntilTimeout);break;}}// Commit the placeholder.
commitRoot(root);break;}case RootCompleted:{// The work completed. Ready to commit.
commitRoot(root);break;}default:{{{throw Error("Unknown root exit status.");}}}}}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more
// rarely, since we try to avoid it) updated during the render phase.
// TODO: Lol maybe there's a better way to factor this besides this
// obnoxiously named function :)
suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root){if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}flushPassiveEffects();var lanes;var exitStatus;if(root===workInProgressRoot&&includesSomeLane(root.expiredLanes,workInProgressRootRenderLanes)){// There's a partial tree, and at least one of its lanes has expired. Finish
// rendering it before rendering the rest of the expired work.
lanes=workInProgressRootRenderLanes;exitStatus=renderRootSync(root,lanes);if(includesSomeLane(workInProgressRootIncludedLanes,workInProgressRootUpdatedLanes)){// The render included lanes that were updated during the render phase.
// For example, when unhiding a hidden tree, we include all the lanes
// that were previously skipped when the tree was hidden. That set of
// lanes is a superset of the lanes we started rendering with.
//
// Note that this only happens when part of the tree is rendered
// concurrently. If the whole tree is rendered synchronously, then there
// are no interleaved events.
lanes=getNextLanes(root,lanes);exitStatus=renderRootSync(root,lanes);}}else{lanes=getNextLanes(root,NoLanes);exitStatus=renderRootSync(root,lanes);}if(root.tag!==LegacyRoot&&exitStatus===RootErrored){executionContext|=RetryAfterError;// If an error occurred during hydration,
// discard server response and fall back to client side render.
if(root.hydrate){root.hydrate=false;clearContainer(root.containerInfo);}// If something threw an error, try rendering one more time. We'll render
// synchronously to block concurrent data mutations, and we'll includes
// all pending updates are included. If it still fails after the second
// attempt, we'll give up and commit the resulting tree.
lanes=getLanesToRetrySynchronouslyOnError(root);if(lanes!==NoLanes){exitStatus=renderRootSync(root,lanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}// We now have a consistent tree. Because this is a sync render, we
// will commit it even if something suspended.
var finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root);// Before exiting, make sure there's a callback scheduled for the next
// pending level.
ensureRootIsScheduled(root,now());return null;}function flushDiscreteUpdates(){// TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
// However, `act` uses `batchedUpdates`, so there's no way to distinguish
// those two cases. Need to fix this before exposing flushDiscreteUpdates
// as a public API.
if((executionContext&(BatchedContext|RenderContext|CommitContext))!==NoContext){{if((executionContext&RenderContext)!==NoContext){error('unstable_flushDiscreteUpdates: Cannot flush updates when React is '+'already rendering.');}}// We're already rendering, so we can't synchronously flush pending work.
// This is probably a nested event dispatch triggered by a lifecycle/effect,
// like `el.focus()`. Exit.
return;}flushPendingDiscreteUpdates();// If the discrete updates scheduled passive effects, flush them now so that
// they fire before the next serial event.
flushPassiveEffects();}function flushPendingDiscreteUpdates(){if(rootsWithPendingDiscreteUpdates!==null){// For each root with pending discrete updates, schedule a callback to
// immediately flush them.
var roots=rootsWithPendingDiscreteUpdates;rootsWithPendingDiscreteUpdates=null;roots.forEach(function(root){markDiscreteUpdatesExpired(root);ensureRootIsScheduled(root,now());});}// Now flush the immediate queue.
flushSyncCallbackQueue();}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
resetRenderTimer();flushSyncCallbackQueue();}}}function batchedEventUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=EventContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
resetRenderTimer();flushSyncCallbackQueue();}}}function discreteUpdates$1(fn,a,b,c,d){var prevExecutionContext=executionContext;executionContext|=DiscreteEventContext;{try{return runWithPriority$1(UserBlockingPriority$2,fn.bind(null,a,b,c,d));}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
resetRenderTimer();flushSyncCallbackQueue();}}}}function unbatchedUpdates(fn,a){var prevExecutionContext=executionContext;executionContext&=~BatchedContext;executionContext|=LegacyUnbatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;if(executionContext===NoContext){// Flush the immediate callbacks that were scheduled during this batch
resetRenderTimer();flushSyncCallbackQueue();}}}function flushSync(fn,a){var prevExecutionContext=executionContext;if((prevExecutionContext&(RenderContext|CommitContext))!==NoContext){{error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}return fn(a);}executionContext|=BatchedContext;{try{if(fn){return runWithPriority$1(ImmediatePriority$1,fn.bind(null,a));}else{return undefined;}}finally{executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.
// Note that this will happen even if batchedUpdates is higher up
// the stack.
flushSyncCallbackQueue();}}}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback
// state. Now that we have additional work, cancel the timeout.
root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){unwindInterruptedWork(interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;workInProgress=createWorkInProgress(root.current,null);workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootIncomplete;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;{spawnedWorkDuringRender=null;}{ReactStrictModeWarnings.discardPendingWarnings();}}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.
resetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a
// separate issue. Write a regression test using string refs.
ReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error
// because there's no ancestor that can handle it; the root is
// supposed to capture all errors that weren't caught by an error
// boundary.
workInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next
// sibling, or the parent if there are no siblings. But since the root
// has no siblings nor a parent, we set it to null. Usually this is
// handled by `completeUnitOfWork` or `unwindWork`, but since we're
// intentionally not calling those, we need set it here.
// TODO: Consider calling `unwindWork` to pop the contexts.
workInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This
// avoids inaccurate Profiler durations in the case of a
// suspended render.
stopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.
thrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing
// the error. Bubble it to the next boundary.
erroredWork=erroredWork.return;workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.
return;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.
// Instead the first renderer will lazily attach one, in order to give
// nicer error messages.
return ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function pushInteractions(root){{var prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;return prevInteractions;}}function popInteractions(prevInteractions){{tracing.__interactionsRef.current=prevInteractions;}}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootIncomplete){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootIncomplete||workInProgressRootExitStatus===RootSuspended){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked
// this render.
if(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootUpdatedLanes))){// Mark the current render as suspended so that we switch to working on
// the updates that were skipped. Usually we only suspend at the end of
// the render phase.
// TODO: We should probably always mark the root as suspended immediately
// (inside this function), since by suspending at the end of the render
// phase introduces a potential mistake where we suspend lanes that were
// pinged or updated while we were rendering.
markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(){if(workInProgressRootExitStatus!==RootCompleted){workInProgressRootExitStatus=RootErrored;}}// Called during render to determine if anything has suspended.
// Returns false if we're not sure.
function renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,
// so those are false.
return workInProgressRootExitStatus===RootIncomplete;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){prepareFreshStack(root,lanes);startWorkOnPendingInteractions(root,lanes);}var prevInteractions=pushInteractions(root);do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();{popInteractions(prevInteractions);}executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.
{{throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");}}}workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.
while(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){resetRenderTimer();prepareFreshStack(root,lanes);startWorkOnPendingInteractions(root,lanes);}var prevInteractions=pushInteractions(root);do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();{popInteractions(prevInteractions);}popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){return RootIncomplete;}else{workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.
return workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield
while(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.
completeUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next
// sibling. If there are no more siblings, return to the parent fiber.
var completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.
if((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.
workInProgress=next;return;}resetChildLanes(completedWork);if(returnFiber!==null&&// Do not append effects to parents if a sibling failed to complete
(returnFiber.flags&Incomplete)===NoFlags){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=completedWork.firstEffect;}if(completedWork.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=completedWork.firstEffect;}returnFiber.lastEffect=completedWork.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if needed,
// by doing multiple passes over the effect list. We don't want to
// schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var flags=completedWork.flags;// Skip both NoWork and PerformedWork tags when creating the effect
// list. PerformedWork effect is read by React DevTools but shouldn't be
// committed.
if(flags>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=completedWork;}else{returnFiber.firstEffect=completedWork;}returnFiber.lastEffect=completedWork;}}}else{// This fiber did not complete because something threw. Pop values off
// the stack without entering the complete phase. If this is a boundary,
// capture values if possible.
var _next=unwindWork(completedWork);// Because this fiber did not complete, don't reset its expiration time.
if(_next!==null){// If completing this work spawned new work, do that next. We'll come
// back here again.
// Since we're restarting, remove anything that is not a host effect
// from the effect tag.
_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.
var actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its effect list.
returnFiber.firstEffect=returnFiber.lastEffect=null;returnFiber.flags|=Incomplete;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
workInProgress=siblingFiber;return;}// Otherwise, return to the parent
completedWork=returnFiber;// Update the next thing we're working on in case something throws.
workInProgress=completedWork;}while(completedWork!==null);// We've reached the root.
if(workInProgressRootExitStatus===RootIncomplete){workInProgressRootExitStatus=RootCompleted;}}function resetChildLanes(completedWork){if(// TODO: Move this check out of the hot path by moving `resetChildLanes`
// to switch statement in `completeWork`.
(completedWork.tag===LegacyHiddenComponent||completedWork.tag===OffscreenComponent)&&completedWork.memoizedState!==null&&!includesSomeLane(subtreeRenderLanes,OffscreenLane)&&(completedWork.mode&ConcurrentMode)!==NoLanes){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}var newChildLanes=NoLanes;// Bubble up the earliest expiration time.
if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
// profiler durations.
var actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;// When a fiber is cloned, its actualDuration is reset to 0. This value will
// only be updated if work is done on the fiber (i.e. it doesn't bailout).
// When work is done, it should bubble to the parent's actualDuration. If
// the fiber has not been cloned though, (meaning no work was done), then
// this value will reflect the amount of time spent working on a previous
// render. In that case it should not bubble. We determine whether it was
// cloned by comparing the child pointer.
var shouldBubbleActualDurations=completedWork.alternate===null||completedWork.child!==completedWork.alternate.child;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));if(shouldBubbleActualDurations){actualDuration+=child.actualDuration;}treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}var isTimedOutSuspense=completedWork.tag===SuspenseComponent&&completedWork.memoizedState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var primaryChildFragment=completedWork.child;if(primaryChildFragment!==null){treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));_child=_child.sibling;}}completedWork.childLanes=newChildLanes;}function commitRoot(root){var renderPriorityLevel=getCurrentPriorityLevel();runWithPriority$1(ImmediatePriority$1,commitRootImpl.bind(null,root,renderPriorityLevel));return null;}function commitRootImpl(root,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
// means `flushPassiveEffects` will sometimes result in additional
// passive effects. So we need to keep flushing in a loop until there are
// no more pending effects.
// TODO: Might be better if `flushPassiveEffects` did not automatically
// flush synchronous work at the end, to avoid factoring hazards like this.
flushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Should not already be working.");}}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;if(finishedWork===null){return null;}root.finishedWork=null;root.finishedLanes=NoLanes;if(!(finishedWork!==root.current)){{throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");}}// commitRoot never returns a continuation; it always finishes synchronously.
// So we can clear these now to allow a new callback to be scheduled.
root.callbackNode=null;// Update the first and last pending times on this root. The new first
// pending time is whatever is left on the root fiber.
var remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);// Clear already finished discrete updates in case that a later call of
// `flushDiscreteUpdates` starts a useless render pass which may cancels
// a scheduled timeout.
if(rootsWithPendingDiscreteUpdates!==null){if(!hasDiscreteLanes(remainingLanes)&&rootsWithPendingDiscreteUpdates.has(root)){rootsWithPendingDiscreteUpdates.delete(root);}}if(root===workInProgressRoot){// We can reset these now that they are finished.
workInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// Get the list of effects.
var firstEffect;if(finishedWork.flags>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if it
// had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}if(firstEffect!==null){var prevExecutionContext=executionContext;executionContext|=CommitContext;var prevInteractions=pushInteractions(root);// Reset this to null before calling lifecycles
ReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass
// of the effect list for each phase: all mutation effects come before all
// layout effects, and so on.
// The first phase a "before mutation" phase. We use this phase to read the
// state of the host tree right before we mutate it. This is where
// getSnapshotBeforeUpdate is called.
focusedInstanceHandle=prepareForCommit(root.containerInfo);shouldFireAfterActiveInstanceBlur=false;nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitBeforeMutationEffects,null);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var error=clearCaughtError();captureCommitPhaseError(nextEffect,error);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);// We no longer need to track the active instance fiber
focusedInstanceHandle=null;{// Mark the current commit time to be shared by all Profilers in this
// batch. This enables them to be grouped later.
recordCommitTime();}// The next phase is the mutation phase, where we mutate the host tree.
nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitMutationEffects,null,root,renderPriorityLevel);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var _error=clearCaughtError();captureCommitPhaseError(nextEffect,_error);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
// the mutation phase, so that the previous tree is still current during
// componentWillUnmount, but before the layout phase, so that the finished
// work is current during componentDidMount/Update.
root.current=finishedWork;// The next phase is the layout phase, where we call effects that read
// the host tree after it's been mutated. The idiomatic use case for this is
// layout, but class component lifecycles also fire here for legacy reasons.
nextEffect=firstEffect;do{{invokeGuardedCallback(null,commitLayoutEffects,null,root,lanes);if(hasCaughtError()){if(!(nextEffect!==null)){{throw Error("Should be working on an effect.");}}var _error2=clearCaughtError();captureCommitPhaseError(nextEffect,_error2);nextEffect=nextEffect.nextEffect;}}}while(nextEffect!==null);nextEffect=null;// Tell Scheduler to yield at the end of the frame, so the browser has an
// opportunity to paint.
requestPaint();{popInteractions(prevInteractions);}executionContext=prevExecutionContext;}else{// No effects.
root.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were
// no effects.
// TODO: Maybe there's a better way to report this.
{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't
// schedule a callback until after flushing layout work.
rootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;pendingPassiveEffectsRenderPriority=renderPriorityLevel;}else{// We are done with the effect chain at this point so let's clear the
// nextEffect pointers to assist with GC. If we have passive effects, we'll
// clear this in flushPassiveEffects.
nextEffect=firstEffect;while(nextEffect!==null){var nextNextEffect=nextEffect.nextEffect;nextEffect.nextEffect=null;if(nextEffect.flags&Deletion){detachFiberAfterEffects(nextEffect);}nextEffect=nextNextEffect;}}// Read this again, since an effect might have updated it
remainingLanes=root.pendingLanes;// Check if there's remaining work on this root
if(remainingLanes!==NoLanes){{if(spawnedWorkDuringRender!==null){var expirationTimes=spawnedWorkDuringRender;spawnedWorkDuringRender=null;for(var i=0;i<expirationTimes.length;i++){scheduleInteractions(root,expirationTimes[i],root.memoizedInteractions);}}schedulePendingInteractions(root,remainingLanes);}}else{// If there's no remaining work, we can clear the set of already failed
// error boundaries.
legacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){// If there are no passive effects, then we can complete the pending interactions.
// Otherwise, we'll wait until after the passive effects are flushed.
// Wait to do this until after remaining work has been scheduled,
// so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
finishPendingInteractions(root,lanes);}}if(remainingLanes===SyncLane){// Count the number of times the root synchronously re-renders without
// finishing. If there are too many, it indicates an infinite update loop.
if(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any
// additional work on this root is scheduled.
ensureRootIsScheduled(root,now());if(hasUncaughtError){hasUncaughtError=false;var _error3=firstUncaughtError;firstUncaughtError=null;throw _error3;}if((executionContext&LegacyUnbatchedContext)!==NoContext){// a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
// synchronously, but layout updates should be deferred until the end
// of the batch.
return null;}// If layout work was scheduled, flush it now.
flushSyncCallbackQueue();return null;}function commitBeforeMutationEffects(){while(nextEffect!==null){var current=nextEffect.alternate;if(!shouldFireAfterActiveInstanceBlur&&focusedInstanceHandle!==null){if((nextEffect.flags&Deletion)!==NoFlags){if(doesFiberContain(nextEffect,focusedInstanceHandle)){shouldFireAfterActiveInstanceBlur=true;}}else{// TODO: Move this out of the hot path using a dedicated effect tag.
if(nextEffect.tag===SuspenseComponent&&isSuspenseBoundaryBeingHidden(current,nextEffect)&&doesFiberContain(nextEffect,focusedInstanceHandle)){shouldFireAfterActiveInstanceBlur=true;}}}var flags=nextEffect.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(nextEffect);commitBeforeMutationLifeCycles(current,nextEffect);resetCurrentFiber();}if((flags&Passive)!==NoFlags){// If there are passive effects, schedule a callback to flush at
// the earliest opportunity.
if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback(NormalPriority$1,function(){flushPassiveEffects();return null;});}}nextEffect=nextEffect.nextEffect;}}function commitMutationEffects(root,renderPriorityLevel){// TODO: Should probably move the bulk of this function to commitWork.
while(nextEffect!==null){setCurrentFiber(nextEffect);var flags=nextEffect.flags;if(flags&ContentReset){commitResetTextContent(nextEffect);}if(flags&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every possible
// bitmap value, we remove the secondary effects from the effect tag and
// switch on that value.
var primaryFlags=flags&(Placement|Update|Deletion|Hydrating);switch(primaryFlags){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is
// inserted, before any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted does
// and isMounted is deprecated anyway so we should be able to kill this.
nextEffect.flags&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is
// inserted, before any life-cycles like componentDidMount gets called.
nextEffect.flags&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Hydrating:{nextEffect.flags&=~Hydrating;break;}case HydratingAndUpdate:{nextEffect.flags&=~Hydrating;// Update
var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Update:{var _current3=nextEffect.alternate;commitWork(_current3,nextEffect);break;}case Deletion:{commitDeletion(root,nextEffect);break;}}resetCurrentFiber();nextEffect=nextEffect.nextEffect;}}function commitLayoutEffects(root,committedLanes){while(nextEffect!==null){setCurrentFiber(nextEffect);var flags=nextEffect.flags;if(flags&(Update|Callback)){var current=nextEffect.alternate;commitLifeCycles(root,current,nextEffect);}{if(flags&Ref){commitAttachRef(nextEffect);}}resetCurrentFiber();nextEffect=nextEffect.nextEffect;}}function flushPassiveEffects(){// Returns whether passive effects were flushed.
if(pendingPassiveEffectsRenderPriority!==NoPriority$1){var priorityLevel=pendingPassiveEffectsRenderPriority>NormalPriority$1?NormalPriority$1:pendingPassiveEffectsRenderPriority;pendingPassiveEffectsRenderPriority=NoPriority$1;{return runWithPriority$1(priorityLevel,flushPassiveEffectsImpl);}}return false;}function enqueuePendingPassiveHookEffectMount(fiber,effect){pendingPassiveHookEffectsMount.push(effect,fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback(NormalPriority$1,function(){flushPassiveEffects();return null;});}}function enqueuePendingPassiveHookEffectUnmount(fiber,effect){pendingPassiveHookEffectsUnmount.push(effect,fiber);{fiber.flags|=PassiveUnmountPendingDev;var alternate=fiber.alternate;if(alternate!==null){alternate.flags|=PassiveUnmountPendingDev;}}if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback(NormalPriority$1,function(){flushPassiveEffects();return null;});}}function invokePassiveEffectCreate(effect){var create=effect.create;effect.destroy=create();}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;pendingPassiveEffectsLanes=NoLanes;if(!((executionContext&(RenderContext|CommitContext))===NoContext)){{throw Error("Cannot flush passive effects while already rendering.");}}{isFlushingPassiveEffects=true;}var prevExecutionContext=executionContext;executionContext|=CommitContext;var prevInteractions=pushInteractions(root);// It's important that ALL pending passive effect destroy functions are called
// before ANY passive effect create functions are called.
// Otherwise effects in sibling components might interfere with each other.
// e.g. a destroy function in one component may unintentionally override a ref
// value set by a create function in another component.
// Layout effects have the same constraint.
// First pass: Destroy stale passive effects.
var unmountEffects=pendingPassiveHookEffectsUnmount;pendingPassiveHookEffectsUnmount=[];for(var i=0;i<unmountEffects.length;i+=2){var _effect=unmountEffects[i];var fiber=unmountEffects[i+1];var destroy=_effect.destroy;_effect.destroy=undefined;{fiber.flags&=~PassiveUnmountPendingDev;var alternate=fiber.alternate;if(alternate!==null){alternate.flags&=~PassiveUnmountPendingDev;}}if(typeof destroy==='function'){{setCurrentFiber(fiber);{invokeGuardedCallback(null,destroy,null);}if(hasCaughtError()){if(!(fiber!==null)){{throw Error("Should be working on an effect.");}}var error=clearCaughtError();captureCommitPhaseError(fiber,error);}resetCurrentFiber();}}}// Second pass: Create new passive effects.
var mountEffects=pendingPassiveHookEffectsMount;pendingPassiveHookEffectsMount=[];for(var _i=0;_i<mountEffects.length;_i+=2){var _effect2=mountEffects[_i];var _fiber=mountEffects[_i+1];{setCurrentFiber(_fiber);{invokeGuardedCallback(null,invokePassiveEffectCreate,null,_effect2);}if(hasCaughtError()){if(!(_fiber!==null)){{throw Error("Should be working on an effect.");}}var _error4=clearCaughtError();captureCommitPhaseError(_fiber,_error4);}resetCurrentFiber();}}// Note: This currently assumes there are no passive effects on the root fiber
// because the root is not part of its own effect list.
// This could change in the future.
var effect=root.current.firstEffect;while(effect!==null){var nextNextEffect=effect.nextEffect;// Remove nextEffect pointer to assist GC
effect.nextEffect=null;if(effect.flags&Deletion){detachFiberAfterEffects(effect);}effect=nextNextEffect;}{popInteractions(prevInteractions);finishPendingInteractions(root,lanes);}{isFlushingPassiveEffects=false;}executionContext=prevExecutionContext;flushSyncCallbackQueue();// If additional passive effects were scheduled, increment a counter. If this
// exceeds the limit, we'll fire a warning.
nestedPassiveUpdateCount=rootWithPendingPassiveEffects===null?0:nestedPassiveUpdateCount+1;return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValue(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);enqueueUpdate(rootFiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(rootFiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,SyncLane);}}function captureCommitPhaseError(sourceFiber,error){if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
// itself should capture it.
captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error);return;}var fiber=sourceFiber.return;while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(error,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);enqueueUpdate(fiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(fiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,SyncLane);}else{// This component has already been unmounted.
// We can't schedule any follow up work for the root because the fiber is already unmounted,
// but we can still call the log-only boundary so the error isn't swallowed.
//
// TODO This is only a temporary bandaid for the old reconciler fork.
// We can delete this special case once the new fork is merged.
if(typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){try{instance.componentDidCatch(error,errorInfo);}catch(errorToIgnore){// TODO Ignore this error? Rethrow it?
// This is kind of an edge case.
}}}return;}}fiber=fiber.return;}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
pingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently
// rendering. We might want to restart this render. This should mirror
// the logic of whether or not a root suspends once it completes.
// TODO: If we're rendering sync either due to Sync, Batched or expired,
// we should probably never restart.
// If we're suspended with delay, or if it's a retry, we'll always suspend
// so we can always restart.
if(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.
prepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an
// opportunity later. So we mark this render as having a ping.
workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,pingedLanes);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)
// previously was rendered in its fallback state. One of the promises that
// suspended it has resolved, which means at least part of the tree was
// likely unblocked. Try rendering again, at a new expiration time.
if(retryLane===NoLane){retryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?
var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);schedulePendingInteractions(root,retryLane);}}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default
var retryCache;{retryCache=boundaryFiber.stateNode;}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
retryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.
function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;{{throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");}}}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;error('Maximum update depth exceeded. This can happen when a component '+"calls setState inside useEffect, but useEffect either doesn't "+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.
return;}if(!(fiber.mode&(BlockingMode|ConcurrentMode))){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent&&tag!==Block){// Only warn for user-defined components, not internal ones like Suspense.
return;}// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentName(fiber.type)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error("Can't perform a React state update on a component that hasn't mounted yet. "+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var didWarnStateUpdateForUnmountedComponent=null;function warnAboutUpdateOnUnmountedFiberInDEV(fiber){{var tag=fiber.tag;if(tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent&&tag!==Block){// Only warn for user-defined components, not internal ones like Suspense.
return;}// If there are pending passive effects unmounts for this Fiber,
// we can assume that they would have prevented this update.
if((fiber.flags&PassiveUnmountPendingDev)!==NoFlags){return;}// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentName(fiber.type)||'ReactComponent';if(didWarnStateUpdateForUnmountedComponent!==null){if(didWarnStateUpdateForUnmountedComponent.has(componentName)){return;}didWarnStateUpdateForUnmountedComponent.add(componentName);}else{didWarnStateUpdateForUnmountedComponent=new Set([componentName]);}if(isFlushingPassiveEffects);else{var previousFiber=current;try{setCurrentFiber(fiber);error("Can't perform a React state update on an unmounted component. This "+'is a no-op, but it indicates a memory leak in your application. To '+'fix, cancel all subscriptions and asynchronous tasks in %s.',tag===ClassComponent?'the componentWillUnmount method':'a useEffect cleanup function');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously
// dispatched event, so that the debugger will treat it as an uncaught
// error See ReactErrorUtils for more information.
// Before entering the begin phase, copy the work-in-progress onto a dummy
// fiber. If beginWork throws, we'll use this to reset the state.
var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(originalError!==null&&(typeof originalError==='undefined'?'undefined':_typeof(originalError))==='object'&&typeof originalError.then==='function'){// Don't replay promises. Treat everything else like an error.
throw originalError;}// Keep this code in sync with handleError; any changes here must have
// corresponding changes there.
resetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the
// same fiber again.
// Unwind the failed stack frame
unwindInterruptedWork(unitOfWork);// Restore the original properties of the fiber.
assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.
startProfilerTimer(unitOfWork);}// Run beginWork again.
invokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();// `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
// Rethrow this error instead of the original one.
throw replayError;}else{// This branch is reachable if the render phase is impure.
throw originalError;}}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&(executionContext&RenderContext)!==NoContext&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentName(workInProgress.type)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.
var dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentName(fiber.type)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}// a 'shared' variable that changes when act() opens/closes in tests.
var IsThisRendererActing={current:false};function warnIfNotScopedWithMatchingAct(fiber){{if(IsSomeRendererActing.current===true&&IsThisRendererActing.current!==true){var previousFiber=current;try{setCurrentFiber(fiber);error("It looks like you're using the wrong act() around your test interactions.\n"+'Be sure to use the matching version of act() corresponding to your renderer:\n\n'+'// for react-dom:\n'+// Break up imports to avoid accidentally parsing them as dependencies.
'import {act} fr'+"om 'react-dom/test-utils';\n"+'// ...\n'+'act(() => ...);\n\n'+'// for react-test-renderer:\n'+// Break up imports to avoid accidentally parsing them as dependencies.
'import TestRenderer fr'+"om react-test-renderer';\n"+'const {act} = TestRenderer;\n'+'// ...\n'+'act(() => ...);');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfNotCurrentlyActingEffectsInDEV(fiber){{if((fiber.mode&StrictMode)!==NoMode&&IsSomeRendererActing.current===false&&IsThisRendererActing.current===false){error('An update to %s ran an effect, but was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentName(fiber.type));}}}function warnIfNotCurrentlyActingUpdatesInDEV(fiber){{if(executionContext===NoContext&&IsSomeRendererActing.current===false&&IsThisRendererActing.current===false){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentName(fiber.type));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}var warnIfNotCurrentlyActingUpdatesInDev=warnIfNotCurrentlyActingUpdatesInDEV;// In tests, we want to enforce a mocked scheduler.
var didWarnAboutUnmockedScheduler=false;// TODO Before we release concurrent mode, revisit this and decide whether a mocked
// scheduler is the actual recommendation. The alternative could be a testing build,
// a new lib, or whatever; we dunno just yet. This message is for early adopters
// to get their tests right.
function warnIfUnmockedScheduler(fiber){{if(didWarnAboutUnmockedScheduler===false&&Scheduler.unstable_flushAllWithoutAsserting===undefined){if(fiber.mode&BlockingMode||fiber.mode&ConcurrentMode){didWarnAboutUnmockedScheduler=true;error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked '+'to guarantee consistent behaviour across tests and browsers. '+'For example, with jest: \n'+// Break up requires to avoid accidentally parsing them as dependencies.
"jest.mock('scheduler', () => require"+"('scheduler/unstable_mock'));\n\n"+'For more info, visit https://reactjs.org/link/mock-scheduler');}}}}function computeThreadID(root,lane){// Interaction threads are unique per root and expiration time.
// NOTE: Intentionally unsound cast. All that matters is that it's a number
// and it represents a batch of work. Could make a helper function instead,
// but meh this is fine for now.
return lane*1000+root.interactionThreadID;}function markSpawnedWork(lane){if(spawnedWorkDuringRender===null){spawnedWorkDuringRender=[lane];}else{spawnedWorkDuringRender.push(lane);}}function scheduleInteractions(root,lane,interactions){if(interactions.size>0){var pendingInteractionMap=root.pendingInteractionMap;var pendingInteractions=pendingInteractionMap.get(lane);if(pendingInteractions!=null){interactions.forEach(function(interaction){if(!pendingInteractions.has(interaction)){// Update the pending async work count for previously unscheduled interaction.
interaction.__count++;}pendingInteractions.add(interaction);});}else{pendingInteractionMap.set(lane,new Set(interactions));// Update the pending async work count for the current interactions.
interactions.forEach(function(interaction){interaction.__count++;});}var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(root,lane);subscriber.onWorkScheduled(interactions,threadID);}}}function schedulePendingInteractions(root,lane){scheduleInteractions(root,lane,tracing.__interactionsRef.current);}function startWorkOnPendingInteractions(root,lanes){// we can accurately attribute time spent working on it, And so that cascading
// work triggered during the render phase will be associated with it.
var interactions=new Set();root.pendingInteractionMap.forEach(function(scheduledInteractions,scheduledLane){if(includesSomeLane(lanes,scheduledLane)){scheduledInteractions.forEach(function(interaction){return interactions.add(interaction);});}});// Store the current set of interactions on the FiberRoot for a few reasons:
// We can re-use it in hot functions like performConcurrentWorkOnRoot()
// without having to recalculate it. We will also use it in commitWork() to
// pass to any Profiler onRender() hooks. This also provides DevTools with a
// way to access it when the onCommitRoot() hook is called.
root.memoizedInteractions=interactions;if(interactions.size>0){var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(root,lanes);try{subscriber.onWorkStarted(interactions,threadID);}catch(error){// If the subscriber throws, rethrow it in a separate task
scheduleCallback(ImmediatePriority$1,function(){throw error;});}}}}function finishPendingInteractions(root,committedLanes){var remainingLanesAfterCommit=root.pendingLanes;var subscriber;try{subscriber=tracing.__subscriberRef.current;if(subscriber!==null&&root.memoizedInteractions.size>0){// FIXME: More than one lane can finish in a single commit.
var threadID=computeThreadID(root,committedLanes);subscriber.onWorkStopped(root.memoizedInteractions,threadID);}}catch(error){// If the subscriber throws, rethrow it in a separate task
scheduleCallback(ImmediatePriority$1,function(){throw error;});}finally{// Clear completed interactions from the pending Map.
// Unless the render was suspended or cascading work was scheduled,
// In which case– leave pending interactions until the subsequent render.
var pendingInteractionMap=root.pendingInteractionMap;pendingInteractionMap.forEach(function(scheduledInteractions,lane){// Only decrement the pending interaction count if we're done.
// If there's still work at the current priority,
// That indicates that we are waiting for suspense data.
if(!includesSomeLane(remainingLanesAfterCommit,lane)){pendingInteractionMap.delete(lane);scheduledInteractions.forEach(function(interaction){interaction.__count--;if(subscriber!==null&&interaction.__count===0){try{subscriber.onInteractionScheduledWorkCompleted(interaction);}catch(error){// If the subscriber throws, rethrow it in a separate task
scheduleCallback(ImmediatePriority$1,function(){throw error;});}}});}});}}// `act` testing API
function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.
return actingUpdatesScopeDepth>0;}// so we can tell if any async act() calls try to run in parallel.
var actingUpdatesScopeDepth=0;function detachFiberAfterEffects(fiber){fiber.sibling=null;fiber.stateNode=null;}var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.
var failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.
return family.current;}}function resolveClassForHotReloading(type){// No implementation differences.
return resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.
if(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,
// but it's possible that we only have its inner render function in the map.
// If that inner render function is different, we'll build a new forwardRef type.
var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.
return family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.
return false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.
var needsCompareFamilies=false;var $$typeofNextType=(typeof nextType==='undefined'?'undefined':_typeof(nextType))==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.
// We're going to assume that the lazy inner type is stable,
// and so it is sufficient to avoid reconciling it away.
// We're not going to unwrap or actually use the new lazy type.
needsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,
// we shouldn't set this.
needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.
if(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.
// This means both of them need to be registered to preserve state.
// If we unwrapped and compared the inner types for wrappers instead,
// then we would risk falsely saying two separate memo(Foo)
// calls are equivalent because they wrap the same Foo function.
var prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.
return;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.
return;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context
// but we don't know the parentComponent so we can't pass it.
// Just ignore. We'll delete this with _renderSubtree code path later.
return;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.
// There's no need to search deeper because for the purpose of giving
// visual feedback, "flashing" outermost parent rectangles is sufficient.
findHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.
if(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.
var node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.
foundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}var debugCounter=1;function FiberNode(tag,pendingProps,key,mode){// Instance
this.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber
this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects
this.flags=NoFlags;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.
//
// Initializing the fields below to smis and later updating them with
// double values will cause Fibers to end up having separate shapes.
// This behavior/bug has something to do with Object.preventExtension().
// Fortunately this only impacts DEV builds.
// Unfortunately it makes React unusably slow for some applications.
// To work around this, initialize the fields below with doubles.
//
// Learn more about this here:
// https://github.com/facebook/react/issues/14365
// https://bugs.chromium.org/p/v8/issues/detail?id=8538
this.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.
// This won't trigger the performance cliff mentioned above,
// and it simplifies other profiler code (including DevTools).
this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:
this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.
workInProgress.type=current.type;// We already have an alternate.
// Reset the effect tag.
workInProgress.flags=NoFlags;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.
// This prevents time from endlessly accumulating in new commits.
// This has the downside of resetting values for different priority renders,
// But works for yielding (the common case) and should support resuming.
workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.
function resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would
// have set the values to before during the first pass. Ideally this wouldn't
// be necessary but unfortunately many code paths reads from the workInProgress
// when they should be reading from current and writing to workInProgress.
// We assume pendingProps, index, key, ref, return are still untouched to
// avoid doing another reconciliation.
// Reset the effect tag but keep any Placement tags, since that's something
// that child fiber is setting, not the reconciliation.
workInProgress.flags&=Placement;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;var current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.
workInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.
workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.
workInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode|BlockingMode|StrictMode;}else if(tag===BlockingRoot){mode=BlockingMode|StrictMode;}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.
// This enables DevTools to start capturing timing at any point–
// Without some nodes in the tree having empty base times.
mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType
key,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.
var resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_DEBUG_TRACING_MODE_TYPE:fiberTag=Mode;mode|=DebugTracingMode;break;case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictMode;break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:return createFiberFromLegacyHidden(pendingProps,mode,lanes,key);case REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough
default:{if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;case REACT_BLOCK_TYPE:fiberTag=Block;break getTag;}}var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentName(owner.type):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}{{throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: "+(type==null?type:typeof type==='undefined'?'undefined':_typeof(type))+"."+info);}}}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an "id" as a prop');}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);// TODO: The Profiler fiber shouldn't have a type. It has a tag.
fiber.elementType=REACT_PROFILER_TYPE;fiber.type=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);// TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
// This needs to be fixed in getComponentName so that it relies on the tag
// instead.
fiber.type=REACT_SUSPENSE_TYPE;fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);{// TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
// This needs to be fixed in getComponentName so that it relies on the tag
// instead.
fiber.type=REACT_SUSPENSE_LIST_TYPE;}fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);// TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
// This needs to be fixed in getComponentName so that it relies on the tag
// instead.
{fiber.type=REACT_OFFSCREEN_TYPE;}fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromLegacyHidden(pendingProps,mode,lanes,key){var fiber=createFiber(LegacyHiddenComponent,pendingProps,key,mode);// TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
// This needs to be fixed in getComponentName so that it relies on the tag
// instead.
{fiber.type=REACT_LEGACY_HIDDEN_TYPE;}fiber.elementType=REACT_LEGACY_HIDDEN_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);// TODO: These should not need a type.
fiber.elementType='DELETED';fiber.type='DELETED';return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
// We only use a Fiber to ensure the same hidden class so DEV isn't slow.
target=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.
// We tried to use Object.assign() instead but this is called in
// the hottest path, and Object.assign() was too slow:
// https://github.com/facebook/react/issues/12502
// This code is DEV-only so size is not a concern.
target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.nextEffect=source.nextEffect;target.firstEffect=source.firstEffect;target.lastEffect=source.lastEffect;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugID=source._debugID;target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.hydrate=hydrate;this.callbackNode=null;this.callbackPriority=NoLanePriority;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);{this.mutableSourceEagerHydrationData=null;}{this.interactionThreadID=tracing.unstable_getThreadID();this.memoizedInteractions=new Set();this.pendingInteractionMap=new Map();}{switch(tag){case BlockingRoot:this._debugRootType='createBlockingRoot()';break;case ConcurrentRoot:this._debugRootType='createRoot()';break;case LegacyRoot:this._debugRootType='createLegacyRoot()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,hydrationCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate);// stateNode is any.
var uninitializedFiber=createHostRootFiber(tag);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;initializeUpdateQueue(uninitializedFiber);return root;}// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.
function registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.
// Retaining it forever may interfere with GC.
if(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){{{throw Error("Unable to find node on an unmounted component.");}}}else{{{throw Error("Argument appears to not be a ReactComponent. Keys: "+Object.keys(component));}}}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictMode){var componentName=getComponentName(fiber.type)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in
// render and there's another warning for that anyway.
if(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrate,hydrationCallbacks){return createFiberRoot(containerInfo,tag,hydrate);}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();{// $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
if('undefined'!==typeof jest){warnIfUnmockedScheduler(current$1);warnIfNotScopedWithMatchingAct(current$1);}}var lane=requestUpdateLane(current$1);var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(current.type)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}enqueueUpdate(current$1,update);scheduleUpdateOnFiber(current$1,lane,eventTime);return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thennables when they resolve within this boundary.
function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptUserBlockingHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority and they should not suspend on I/O,
// since you have to wrap anything that might suspend in
// Suspense.
return;}var eventTime=requestEventTime();var lane=InputDiscreteHydrationLane;scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority and they should not suspend on I/O,
// since you have to wrap anything that might suspend in
// Suspense.
return;}var eventTime=requestEventTime();var lane=SelectiveHydrationLane;scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority other than synchronously flush it.
return;}var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function runWithPriority$2(priority,fn){try{setCurrentUpdateLanePriority(priority);return fn();}finally{}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}if(hostFiber.tag===FundamentalComponent){return hostFiber.stateNode.instance;}return hostFiber.stateNode;}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=Array.isArray(obj)?obj.slice():_assign({},obj);if(index+1===path.length){if(Array.isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here
updated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=Array.isArray(obj)?obj.slice():_assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here
updated[newKey]=updated[oldKey];if(Array.isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here
updated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here
obj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=Array.isArray(obj)?obj.slice():_assign({},obj);// $FlowFixMe number or string is fine here
updated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the "id" of stateful hooks is just the stateful hook index.
// This may change in the future with e.g. nested hooks.
var currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.
overrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=_assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=_assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=_assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};// Support DevTools props for function components, forwardRef, memo, host components, etc.
overrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};scheduleUpdate=function scheduleUpdate(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh
findHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.
getCurrentFiber:getCurrentFiberForDevTools});}function ReactDOMRoot(container,options){this._internalRoot=createRootImpl(container,ConcurrentRoot,options);}function ReactDOMBlockingRoot(container,tag,options){this._internalRoot=createRootImpl(container,tag,options);}ReactDOMRoot.prototype.render=ReactDOMBlockingRoot.prototype.render=function(children){var root=this._internalRoot;{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+"root.unmount() to empty a root's container.");}}}}updateContainer(children,root,null,null);};ReactDOMRoot.prototype.unmount=ReactDOMBlockingRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;var container=root.containerInfo;updateContainer(null,root,null,function(){unmarkContainerAsRoot(container);});};function createRootImpl(container,tag,options){// Tag is either LegacyRoot or Concurrent Root
var hydrate=options!=null&&options.hydrate===true;var hydrationCallbacks=options!=null&&options.hydrationOptions||null;var mutableSources=options!=null&&options.hydrationOptions!=null&&options.hydrationOptions.mutableSources||null;var root=createContainer(container,tag,hydrate);markContainerAsRoot(root.current,container);var containerNodeType=container.nodeType;{var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);}if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return root;}function createLegacyRoot(container,options){return new ReactDOMBlockingRoot(container,LegacyRoot,options);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;var warnedAboutHydrateAPI=false;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function legacyCreateRootFromDOMContainer(container,forceHydrate){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;error('render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v18. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}return createLegacyRoot(container,shouldHydrate?{hydrate:true}:undefined);}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}// TODO: Without `any` type, Flow says "Property cannot be accessed on any
// member of intersection type." Whyyyyyy.
var root=container._reactRootContainer;var fiberRoot;if(!root){// Initial mount
root=container._reactRootContainer=legacyCreateRootFromDOMContainer(container,forceHydrate);fiberRoot=root._internalRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(fiberRoot);originalCallback.call(instance);};}// Initial mount should not be batched.
unbatchedUpdates(function(){updateContainer(children,fiberRoot,parentComponent,callback);});}else{fiberRoot=root._internalRoot;if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(fiberRoot);_originalCallback.call(instance);};}// Update
updateContainer(children,fiberRoot,parentComponent,callback);}return getPublicRootInstance(fiberRoot);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. '+'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');}}// TODO: throw or warn if we couldn't hydrate?
return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){if(!isValidContainer(containerNode)){{throw Error("Target container is not a DOM element.");}}if(!(parentComponent!=null&&has(parentComponent))){{throw Error("parentComponent must be a valid React Component");}}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainer(container)){{throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");}}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}}// Unmount should not be batched.
unbatchedUpdates(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`
container._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setAttemptHydrationAtPriority(runWithPriority$2);var didWarnAboutUnstableCreatePortal=false;{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates$1,flushDiscreteUpdates,batchedEventUpdates$1);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){{throw Error("Target container is not a DOM element.");}}// TODO: pass ReactDOM portal implementation as third argument
// $FlowFixMe The Flow type is opaque but there's no way to actually create it.
return createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}function unstable_createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;{if(!didWarnAboutUnstableCreatePortal){didWarnAboutUnstableCreatePortal=true;warn('The ReactDOM.unstable_createPortal() alias has been deprecated, '+'and will be removed in React 18+. Update your code to use '+'ReactDOM.createPortal() instead. It has the exact same API, '+'but without the "unstable_" prefix.');}}return createPortal$1(children,container,key);}var Internals={// Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
// This is an array for better minification.
Events:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,flushPassiveEffects,// TODO: This is related to `act`, not events. Move to separate key?
IsThisRendererActing]};var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging
console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync;exports.hydrate=hydrate;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_createPortal=unstable_createPortal;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(2),
    m = __webpack_require__(1),
    r = __webpack_require__(4);function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}if (!aa) throw Error(y(227));var ba = new Set(),
    ca = {};function da(a, b) {
  ea(a, b);ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;for (a = 0; a < b.length; a++) {
    ba.add(b[a]);
  }
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
    ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    ia = Object.prototype.hasOwnProperty,
    ja = {},
    ka = {};function la(a) {
  if (ia.call(ka, a)) return !0;if (ia.call(ja, a)) return !1;if (ha.test(a)) return ka[a] = !0;ja[a] = !0;return !1;
}function ma(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "function":case "symbol":
      return !0;case "boolean":
      if (d) return !1;if (null !== c) return !c.acceptsBooleans;a = a.toLowerCase().slice(0, 5);return "data-" !== a && "aria-" !== a;default:
      return !1;}
}
function na(a, b, c, d) {
  if (null === b || "undefined" === typeof b || ma(a, b, c, d)) return !0;if (d) return !1;if (null !== c) switch (c.type) {case 3:
      return !b;case 4:
      return !1 === b;case 5:
      return isNaN(b);case 6:
      return isNaN(b) || 1 > b;}return !1;
}function B(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;this.attributeName = d;this.attributeNamespace = e;this.mustUseProperty = c;this.propertyName = a;this.type = b;this.sanitizeURL = f;this.removeEmptyString = g;
}var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  D[a] = new B(a, 0, !1, a, null, !1, !1);
});[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];D[b] = new B(b, 1, !1, a[1], null, !1, !1);
});["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  D[a] = new B(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  D[a] = new B(a, 2, !1, a, null, !1, !1);
});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  D[a] = new B(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  D[a] = new B(a, 3, !0, a, null, !1, !1);
});["capture", "download"].forEach(function (a) {
  D[a] = new B(a, 4, !1, a, null, !1, !1);
});["cols", "rows", "size", "span"].forEach(function (a) {
  D[a] = new B(a, 6, !1, a, null, !1, !1);
});["rowSpan", "start"].forEach(function (a) {
  D[a] = new B(a, 5, !1, a.toLowerCase(), null, !1, !1);
});var oa = /[\-:]([a-z])/g;function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(oa, pa);D[b] = new B(b, 1, !1, a, null, !1, !1);
});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(oa, pa);D[b] = new B(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(oa, pa);D[b] = new B(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});["tabIndex", "crossOrigin"].forEach(function (a) {
  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
D.xlinkHref = new B("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (a) {
  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !0, !0);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    sa = 60103,
    ta = 60106,
    ua = 60107,
    wa = 60108,
    xa = 60114,
    ya = 60109,
    za = 60110,
    Aa = 60112,
    Ba = 60113,
    Ca = 60120,
    Da = 60115,
    Ea = 60116,
    Fa = 60121,
    Ga = 60128,
    Ha = 60129,
    Ia = 60130,
    Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E = Symbol.for;sa = E("react.element");ta = E("react.portal");ua = E("react.fragment");wa = E("react.strict_mode");xa = E("react.profiler");ya = E("react.provider");za = E("react.context");Aa = E("react.forward_ref");Ba = E("react.suspense");Ca = E("react.suspense_list");Da = E("react.memo");Ea = E("react.lazy");Fa = E("react.block");E("react.scope");Ga = E("react.opaque.id");Ha = E("react.debug_trace_mode");Ia = E("react.offscreen");Ja = E("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;function La(a) {
  if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) return null;a = Ka && a[Ka] || a["@@iterator"];return "function" === typeof a ? a : null;
}var Ma;function Na(a) {
  if (void 0 === Ma) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);Ma = b && b[1] || "";
  }return "\n" + Ma + a;
}var Oa = !1;
function Pa(a, b) {
  if (!a || Oa) return "";Oa = !0;var c = Error.prepareStackTrace;Error.prepareStackTrace = void 0;try {
    if (b) {
      if (b = function b() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function set() {
          throw Error();
        } }), "object" === (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }a.call(b.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }a();
    }
  } catch (k) {
    if (k && d && "string" === typeof k.stack) {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) {
        h--;
      }for (; 1 <= g && 0 <= h; g--, h--) {
        if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do {
              if (g--, h--, 0 > h || e[g] !== f[h]) return "\n" + e[g].replace(" at new ", " at ");
            } while (1 <= g && 0 <= h);
          }break;
        }
      }
    }
  } finally {
    Oa = !1, Error.prepareStackTrace = c;
  }return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {case 5:
      return Na(a.type);case 16:
      return Na("Lazy");case 13:
      return Na("Suspense");case 19:
      return Na("SuspenseList");case 0:case 2:case 15:
      return a = Pa(a.type, !1), a;case 11:
      return a = Pa(a.type.render, !1), a;case 22:
      return a = Pa(a.type._render, !1), a;case 1:
      return a = Pa(a.type, !0), a;default:
      return "";}
}
function Ra(a) {
  if (null == a) return null;if ("function" === typeof a) return a.displayName || a.name || null;if ("string" === typeof a) return a;switch (a) {case ua:
      return "Fragment";case ta:
      return "Portal";case xa:
      return "Profiler";case wa:
      return "StrictMode";case Ba:
      return "Suspense";case Ca:
      return "SuspenseList";}if ("object" === (typeof a === "undefined" ? "undefined" : _typeof(a))) switch (a.$$typeof) {case za:
      return (a.displayName || "Context") + ".Consumer";case ya:
      return (a._context.displayName || "Context") + ".Provider";case Aa:
      var b = a.render;b = b.displayName || b.name || "";
      return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");case Da:
      return Ra(a.type);case Fa:
      return Ra(a._render);case Ea:
      b = a._payload;a = a._init;try {
        return Ra(a(b));
      } catch (c) {}}return null;
}function Sa(a) {
  switch (typeof a === "undefined" ? "undefined" : _typeof(a)) {case "boolean":case "number":case "object":case "string":case "undefined":
      return a;default:
      return "";}
}function Ta(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
        f = c.set;Object.defineProperty(a, b, { configurable: !0, get: function get() {
        return e.call(this);
      }, set: function set(a) {
        d = "" + a;f.call(this, a);
      } });Object.defineProperty(a, b, { enumerable: c.enumerable });return { getValue: function getValue() {
        return d;
      }, setValue: function setValue(a) {
        d = "" + a;
      }, stopTracking: function stopTracking() {
        a._valueTracker = null;delete a[b];
      } };
  }
}function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}function Wa(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);if ("undefined" === typeof a) return null;try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
      d = null != b.checked ? b.checked : b.defaultChecked;c = Sa(null != b.value ? b.value : c);a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}function $a(a, b) {
  b = b.checked;null != b && qa(a, "checked", b, !1);
}
function ab(a, b) {
  $a(a, b);var c = Sa(b.value),
      d = b.type;if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");return;
  }b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;b = "" + a._wrapperState.initialValue;c || b === a.value || (a.value = b);a.defaultValue = b;
  }c = a.name;"" !== c && (a.name = "");a.defaultChecked = !!a._wrapperState.initialChecked;"" !== c && (a.name = c);
}
function bb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}function db(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null != a && (b += a);
  });return b;
}function eb(a, b) {
  a = m({ children: void 0 }, b);if (b = db(b.children)) a.children = b;return a;
}
function fb(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + Sa(c);b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(y(91));return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function hb(a, b) {
  var c = b.value;if (null == c) {
    c = b.children;b = b.defaultValue;if (null != c) {
      if (null != b) throw Error(y(92));if (Array.isArray(c)) {
        if (!(1 >= c.length)) throw Error(y(93));c = c[0];
      }b = c;
    }null == b && (b = "");c = b;
  }a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value),
      d = Sa(b.defaultValue);null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));null != d && (a.defaultValue = "" + d);
}function jb(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function mb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var nb,
    ob = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a) a.innerHTML = b;else {
    nb = nb || document.createElement("div");nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";for (b = nb.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
var qb = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0,
  floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    rb = ["Webkit", "ms", "Moz", "O"];Object.keys(qb).forEach(function (a) {
  rb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);qb[b] = qb[a];
  });
});function sb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"),
          e = sb(c, b[c], d);"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var ub = m({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function vb(a, b) {
  if (b) {
    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(y(137, a));if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(y(60));if (!("object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML)) throw Error(y(61));
    }if (null != b.style && "object" !== _typeof(b.style)) throw Error(y(62));
  }
}
function wb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}function xb(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var yb = null,
    zb = null,
    Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(y(280));var b = a.stateNode;b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}function Fb() {
  if (zb) {
    var a = zb,
        b = Ab;Ab = zb = null;Bb(a);if (b) for (a = 0; a < b.length; a++) {
      Bb(b[a]);
    }
  }
}function Gb(a, b) {
  return a(b);
}function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}function Ib() {}var Jb = Gb,
    Kb = !1,
    Lb = !1;function Mb() {
  if (null !== zb || null !== Ab) Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb) return a(b, c);Lb = !0;try {
    return Jb(a, b, c);
  } finally {
    Lb = !1, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;if (null === c) return null;var d = Db(c);if (null === d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;if (c && "function" !== typeof c) throw Error(y(231, b, typeof c === "undefined" ? "undefined" : _typeof(c)));return c;
}var Pb = !1;if (fa) try {
  var Qb = {};Object.defineProperty(Qb, "passive", { get: function get() {
      Pb = !0;
    } });window.addEventListener("test", Qb, Qb);window.removeEventListener("test", Qb, Qb);
} catch (a) {
  Pb = !1;
}function Rb(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, l);
  } catch (n) {
    this.onError(n);
  }
}var Sb = !1,
    Tb = null,
    Ub = !1,
    Vb = null,
    Wb = { onError: function onError(a) {
    Sb = !0;Tb = a;
  } };function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = !1;Tb = null;Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);if (Sb) {
    if (Sb) {
      var l = Tb;Sb = !1;Tb = null;
    } else throw Error(y(198));Ub || (Ub = !0, Vb = l);
  }
}function Zb(a) {
  var b = a,
      c = a;if (a.alternate) for (; b.return;) {
    b = b.return;
  } else {
    a = b;do {
      b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
    } while (a);
  }return 3 === b.tag ? c : null;
}function $b(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;null === b && (a = a.alternate, null !== a && (b = a.memoizedState));if (null !== b) return b.dehydrated;
  }return null;
}function ac(a) {
  if (Zb(a) !== a) throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;if (!b) {
    b = Zb(a);if (null === b) throw Error(y(188));return b !== a ? null : a;
  }for (var c = a, d = b;;) {
    var e = c.return;if (null === e) break;var f = e.alternate;if (null === f) {
      d = e.return;if (null !== d) {
        c = d;continue;
      }break;
    }if (e.child === f.child) {
      for (f = e.child; f;) {
        if (f === c) return ac(e), a;if (f === d) return ac(e), b;f = f.sibling;
      }throw Error(y(188));
    }if (c.return !== d.return) c = e, d = f;else {
      for (var g = !1, h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }if (!g) throw Error(y(189));
      }
    }if (c.alternate !== d) throw Error(y(190));
  }if (3 !== c.tag) throw Error(y(188));return c.stateNode.current === c ? a : b;
}function cc(a) {
  a = bc(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child.return = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b.return || b.return === a) return null;b = b.return;
      }b.sibling.return = b.return;b = b.sibling;
    }
  }return null;
}
function dc(a, b) {
  for (var c = a.alternate; null !== b;) {
    if (b === a || b === c) return !0;b = b.return;
  }return !1;
}var ec,
    fc,
    gc,
    hc,
    ic = !1,
    jc = [],
    kc = null,
    lc = null,
    mc = null,
    nc = new Map(),
    oc = new Map(),
    pc = [],
    qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}function sc(a, b) {
  switch (a) {case "focusin":case "focusout":
      kc = null;break;case "dragenter":case "dragleave":
      lc = null;break;case "mouseover":case "mouseout":
      mc = null;break;case "pointerover":case "pointerout":
      nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":
      oc.delete(b.pointerId);}
}
function tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f) return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;a.eventSystemFlags |= d;b = a.targetContainers;null !== e && -1 === b.indexOf(e) && b.push(e);return a;
}
function uc(a, b, c, d, e) {
  switch (b) {case "focusin":
      return kc = tc(kc, a, b, c, d, e), !0;case "dragenter":
      return lc = tc(lc, a, b, c, d, e), !0;case "mouseover":
      return mc = tc(mc, a, b, c, d, e), !0;case "pointerover":
      var f = e.pointerId;nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));return !0;case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), !0;}return !1;
}
function vc(a) {
  var b = wc(a.target);if (null !== b) {
    var c = Zb(b);if (null !== c) if (b = c.tag, 13 === b) {
      if (b = $b(c), null !== b) {
        a.blockedOn = b;hc(a.lanePriority, function () {
          r.unstable_runWithPriority(a.priority, function () {
            gc(c);
          });
        });return;
      }
    } else if (3 === b && c.stateNode.hydrate) {
      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;return;
    }
  }a.blockedOn = null;
}
function xc(a) {
  if (null !== a.blockedOn) return !1;for (var b = a.targetContainers; 0 < b.length;) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);if (null !== c) return b = Cb(c), null !== b && fc(b), a.blockedOn = c, !1;b.shift();
  }return !0;
}function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic = !1; 0 < jc.length;) {
    var a = jc[0];if (null !== a.blockedOn) {
      a = Cb(a.blockedOn);null !== a && ec(a);break;
    }for (var b = a.targetContainers; 0 < b.length;) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);if (null !== c) {
        a.blockedOn = c;break;
      }b.shift();
    }null === a.blockedOn && jc.shift();
  }null !== kc && xc(kc) && (kc = null);null !== lc && xc(lc) && (lc = null);null !== mc && xc(mc) && (mc = null);nc.forEach(zc);oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b) {
    return Bc(b, a);
  }if (0 < jc.length) {
    Bc(jc[0], a);for (var c = 1; c < jc.length; c++) {
      var d = jc[c];d.blockedOn === a && (d.blockedOn = null);
    }
  }null !== kc && Bc(kc, a);null !== lc && Bc(lc, a);null !== mc && Bc(mc, a);nc.forEach(b);oc.forEach(b);for (c = 0; c < pc.length; c++) {
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  }for (; 0 < pc.length && (c = pc[0], null === c.blockedOn);) {
    vc(c), null === c.blockedOn && pc.shift();
  }
}
function Dc(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;return c;
}var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") },
    Fc = {},
    Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);function Hc(a) {
  if (Fc[a]) return Fc[a];if (!Ec[a]) return a;var b = Ec[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in Gc) return Fc[a] = b[c];
  }return a;
}
var Ic = Hc("animationend"),
    Jc = Hc("animationiteration"),
    Kc = Hc("animationstart"),
    Lc = Hc("transitionend"),
    Mc = new Map(),
    Nc = new Map(),
    Oc = ["abort", "abort", Ic, "animationEnd", Jc, "animationIteration", Kc, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Lc, "transitionEnd", "waiting", "waiting"];function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c],
        e = a[c + 1];e = "on" + (e[0].toUpperCase() + e.slice(1));Nc.set(d, b);Mc.set(d, e);da(e, [d]);
  }
}var Qc = r.unstable_now;Qc();var F = 8;
function Rc(a) {
  if (0 !== (1 & a)) return F = 15, 1;if (0 !== (2 & a)) return F = 14, 2;if (0 !== (4 & a)) return F = 13, 4;var b = 24 & a;if (0 !== b) return F = 12, b;if (0 !== (a & 32)) return F = 11, 32;b = 192 & a;if (0 !== b) return F = 10, b;if (0 !== (a & 256)) return F = 9, 256;b = 3584 & a;if (0 !== b) return F = 8, b;if (0 !== (a & 4096)) return F = 7, 4096;b = 4186112 & a;if (0 !== b) return F = 6, b;b = 62914560 & a;if (0 !== b) return F = 5, b;if (a & 67108864) return F = 4, 67108864;if (0 !== (a & 134217728)) return F = 3, 134217728;b = 805306368 & a;if (0 !== b) return F = 2, b;if (0 !== (1073741824 & a)) return F = 1, 1073741824;
  F = 8;return a;
}function Sc(a) {
  switch (a) {case 99:
      return 15;case 98:
      return 10;case 97:case 96:
      return 8;case 95:
      return 2;default:
      return 0;}
}function Tc(a) {
  switch (a) {case 15:case 14:
      return 99;case 13:case 12:case 11:case 10:
      return 98;case 9:case 8:case 7:case 6:case 4:case 5:
      return 97;case 3:case 2:case 1:
      return 95;case 0:
      return 90;default:
      throw Error(y(358, a));}
}
function Uc(a, b) {
  var c = a.pendingLanes;if (0 === c) return F = 0;var d = 0,
      e = 0,
      f = a.expiredLanes,
      g = a.suspendedLanes,
      h = a.pingedLanes;if (0 !== f) d = f, e = F = 15;else if (f = c & 134217727, 0 !== f) {
    var k = f & ~g;0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
  } else f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);if (0 === d) return 0;d = 31 - Vc(d);d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;if (0 !== b && b !== d && 0 === (b & g)) {
    Rc(b);if (e <= F) return b;F = e;
  }b = a.entangledLanes;if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) {
    c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  }return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}function Xc(a, b) {
  switch (a) {case 15:
      return 1;case 14:
      return 2;case 12:
      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;case 10:
      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;case 8:
      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;case 2:
      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;}throw Error(y(358, a));
}function Yc(a) {
  return a & -a;
}function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++) {
    b.push(a);
  }return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;var d = b - 1;a.suspendedLanes &= d;a.pingedLanes &= d;a = a.eventTimes;b = 31 - Vc(b);a[b] = c;
}var Vc = Math.clz32 ? Math.clz32 : ad,
    bd = Math.log,
    cd = Math.LN2;function ad(a) {
  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
}var dd = r.unstable_UserBlockingPriority,
    ed = r.unstable_runWithPriority,
    fd = !0;function gd(a, b, c, d) {
  Kb || Ib();var e = hd,
      f = Kb;Kb = !0;try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a)) a = rc(null, a, b, c, d), jc.push(a);else {
      var f = yc(a, b, c, d);if (null === f) e && sc(a, d);else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);jc.push(a);return;
          }if (uc(f, a, b, c, d)) return;sc(a, d);
        }jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);e = wc(e);if (null !== e) {
    var f = Zb(e);if (null === f) e = null;else {
      var g = f.tag;if (13 === g) {
        e = $b(f);if (null !== e) return e;e = null;
      } else if (3 === g) {
        if (f.stateNode.hydrate) return 3 === f.tag ? f.stateNode.containerInfo : null;e = null;
      } else f !== e && (e = null);
    }
  }jd(a, b, d, e, c);return null;
}var kd = null,
    ld = null,
    md = null;
function nd() {
  if (md) return md;var a,
      b = ld,
      c = b.length,
      d,
      e = "value" in kd ? kd.value : kd.textContent,
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}return md = e.slice(a, 1 < d ? 1 - d : void 0);
}function od(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;10 === a && (a = 13);return 32 <= a || 13 === a ? a : 0;
}function pd() {
  return !0;
}function qd() {
  return !1;
}
function rd(a) {
  function b(b, d, e, f, g) {
    this._reactName = b;this._targetInst = e;this.type = d;this.nativeEvent = f;this.target = g;this.currentTarget = null;for (var c in a) {
      a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
    }this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;this.isPropagationStopped = qd;return this;
  }m(b.prototype, { preventDefault: function preventDefault() {
      this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
    }, stopPropagation: function stopPropagation() {
      var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
    }, persist: function persist() {}, isPersistent: pd });return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 },
    td = rd(sd),
    ud = m({}, sd, { view: 0, detail: 0 }),
    vd = rd(ud),
    wd,
    xd,
    yd,
    Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function relatedTarget(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function movementX(a) {
    if ("movementX" in a) return a.movementX;a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);return wd;
  }, movementY: function movementY(a) {
    return "movementY" in a ? a.movementY : xd;
  } }),
    Bd = rd(Ad),
    Cd = m({}, Ad, { dataTransfer: 0 }),
    Dd = rd(Cd),
    Ed = m({}, ud, { relatedTarget: 0 }),
    Fd = rd(Ed),
    Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Hd = rd(Gd),
    Id = m({}, sd, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }),
    Jd = rd(Id),
    Kd = m({}, sd, { data: 0 }),
    Ld = rd(Kd),
    Md = { Esc: "Escape",
  Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Nd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7",
  119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" },
    Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function Pd(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
}function zd() {
  return Pd;
}
var Qd = m({}, ud, { key: function key(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function charCode(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }),
    Rd = rd(Qd),
    Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }),
    Td = rd(Sd),
    Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }),
    Vd = rd(Ud),
    Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    Xd = rd(Wd),
    Yd = m({}, Ad, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: 0, deltaMode: 0 }),
    Zd = rd(Yd),
    $d = [9, 13, 27, 32],
    ae = fa && "CompositionEvent" in window,
    be = null;fa && "documentMode" in document && (be = document.documentMode);var ce = fa && "TextEvent" in window && !be,
    de = fa && (!ae || be && 8 < be && 11 >= be),
    ee = String.fromCharCode(32),
    fe = !1;
function ge(a, b) {
  switch (a) {case "keyup":
      return -1 !== $d.indexOf(b.keyCode);case "keydown":
      return 229 !== b.keyCode;case "keypress":case "mousedown":case "focusout":
      return !0;default:
      return !1;}
}function he(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var ie = !1;function je(a, b) {
  switch (a) {case "compositionend":
      return he(b);case "keypress":
      if (32 !== b.which) return null;fe = !0;return ee;case "textInput":
      return a = b.data, a === ee && fe ? null : a;default:
      return null;}
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;switch (a) {case "paste":
      return null;case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;default:
      return null;}
}
var le = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
}function ne(a, b, c, d) {
  Eb(d);b = oe(b, "onChange");0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}var pe = null,
    qe = null;function re(a) {
  se(a, 0);
}function te(a) {
  var b = ue(a);if (Wa(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}var we = !1;if (fa) {
  var xe;if (fa) {
    var ye = "oninput" in document;if (!ye) {
      var ze = document.createElement("div");ze.setAttribute("oninput", "return;");ye = "function" === typeof ze.oninput;
    }xe = ye;
  } else xe = !1;we = xe && (!document.documentMode || 9 < document.documentMode);
}function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];ne(b, qe, a, xb(a));a = re;if (Kb) a(b);else {
      Kb = !0;try {
        Gb(a, b);
      } finally {
        Kb = !1, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}function Ee(a, b) {
  if ("click" === a) return te(b);
}function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}var He = "function" === typeof Object.is ? Object.is : Ge,
    Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b)) return !0;if ("object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) || null === a || "object" !== (typeof b === "undefined" ? "undefined" : _typeof(b)) || null === b) return !1;var c = Object.keys(a),
      d = Object.keys(b);if (c.length !== d.length) return !1;for (d = 0; d < c.length; d++) {
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]])) return !1;
  }return !0;
}function Ke(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Le(a, b) {
  var c = Ke(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Ke(c);
  }
}function Me(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = !1;
    }if (c) a = b.contentWindow;else break;b = Xa(a.document);
  }return b;
}function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode,
    Qe = null,
    Re = null,
    Se = null,
    Te = !1;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);Pc(Oc, 2);for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++) {
  Nc.set(Ve[We], 0);
}ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);ea("onPointerEnter", ["pointerout", "pointerover"]);ea("onPointerLeave", ["pointerout", "pointerover"]);da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";a.currentTarget = c;Yb(d, b, void 0, a);a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);for (var c = 0; c < a.length; c++) {
    var d = a[c],
        e = d.event;d = d.listeners;a: {
      var f = void 0;if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g],
            k = h.instance,
            l = h.currentTarget;h = h.listener;if (k !== f && e.isPropagationStopped()) break a;Ze(e, h, l);f = k;
      } else for (g = 0; g < d.length; g++) {
        h = d[g];k = h.instance;l = h.currentTarget;h = h.listener;if (k !== f && e.isPropagationStopped()) break a;Ze(e, h, l);f = k;
      }
    }
  }if (Ub) throw a = Vb, Ub = !1, Vb = null, a;
}
function G(a, b) {
  var c = $e(b),
      d = a + "__bubble";c.has(d) || (af(b, a, 2, !1), c.add(d));
}var bf = "_reactListening" + Math.random().toString(36).slice(2);function cf(a) {
  a[bf] || (a[bf] = !0, ba.forEach(function (b) {
    Ye.has(b) || df(b, !1, a, null);df(b, !0, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
      f = c;"selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);if (null !== d && !b && Ye.has(a)) {
    if ("scroll" !== a) return;e |= 2;f = d;
  }var g = $e(f),
      h = a + "__" + (b ? "capture" : "bubble");g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
}
function af(a, b, c, d) {
  var e = Nc.get(b);switch (void 0 === e ? 2 : e) {case 0:
      e = gd;break;case 1:
      e = id;break;default:
      e = hd;}c = e.bind(null, b, c, a);e = void 0;!Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);d ? void 0 !== e ? a.addEventListener(b, c, { capture: !0, passive: e }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, !1);
}
function jd(a, b, c, d, e) {
  var f = d;if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
    if (null === d) return;var g = d.tag;if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;if (h === e || 8 === h.nodeType && h.parentNode === e) break;if (4 === g) for (g = d.return; null !== g;) {
        var k = g.tag;if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;g = g.return;
      }for (; null !== h;) {
        g = wc(h);if (null === g) return;k = g.tag;if (5 === k || 6 === k) {
          d = f = g;continue a;
        }h = h.parentNode;
      }
    }d = d.return;
  }Nb(function () {
    var d = f,
        e = xb(c),
        g = [];
    a: {
      var h = Mc.get(a);if (void 0 !== h) {
        var k = td,
            x = a;switch (a) {case "keypress":
            if (0 === od(c)) break a;case "keydown":case "keyup":
            k = Rd;break;case "focusin":
            x = "focus";k = Fd;break;case "focusout":
            x = "blur";k = Fd;break;case "beforeblur":case "afterblur":
            k = Fd;break;case "click":
            if (2 === c.button) break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":
            k = Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":
            k = Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":
            k = Vd;break;case Ic:case Jc:case Kc:
            k = Hd;break;case Lc:
            k = Xd;break;case "scroll":
            k = vd;break;case "wheel":
            k = Zd;break;case "copy":case "cut":case "paste":
            k = Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":
            k = Td;}var w = 0 !== (b & 4),
            z = !w && "scroll" === a,
            u = w ? null !== h ? h + "Capture" : null : h;w = [];for (var t = d, q; null !== t;) {
          q = t;var v = q.stateNode;5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));if (z) break;t = t.return;
        }0 < w.length && (h = new k(h, x, null, c, e), g.push({ event: h, listeners: w }));
      }
    }if (0 === (b & 7)) {
      a: {
        h = "mouseover" === a || "pointerover" === a;k = "mouseout" === a || "pointerout" === a;if (h && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff])) break a;if (k || h) {
          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;if (k) {
            if (x = c.relatedTarget || c.toElement, k = d, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag)) x = null;
          } else k = null, x = d;if (k !== x) {
            w = Bd;v = "onMouseLeave";u = "onMouseEnter";t = "mouse";if ("pointerout" === a || "pointerover" === a) w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";z = null == k ? h : ue(k);q = null == x ? h : ue(x);h = new w(v, t + "leave", k, c, e);h.target = z;h.relatedTarget = q;v = null;wc(e) === d && (w = new w(u, t + "enter", x, c, e), w.target = q, w.relatedTarget = z, v = w);z = v;if (k && x) b: {
              w = k;u = x;t = 0;for (q = w; q; q = gf(q)) {
                t++;
              }q = 0;for (v = u; v; v = gf(v)) {
                q++;
              }for (; 0 < t - q;) {
                w = gf(w), t--;
              }for (; 0 < q - t;) {
                u = gf(u), q--;
              }for (; t--;) {
                if (w === u || null !== u && w === u.alternate) break b;w = gf(w);u = gf(u);
              }w = null;
            } else w = null;null !== k && hf(g, h, k, w, !1);null !== x && null !== z && hf(g, z, x, w, !0);
          }
        }
      }a: {
        h = d ? ue(d) : window;k = h.nodeName && h.nodeName.toLowerCase();if ("select" === k || "input" === k && "file" === h.type) var J = ve;else if (me(h)) {
          if (we) J = Fe;else {
            J = De;var K = Ce;
          }
        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (J = Ee);if (J && (J = J(a, d))) {
          ne(g, J, c, e);break a;
        }K && K(a, h, d);"focusout" === a && (K = h._wrapperState) && K.controlled && "number" === h.type && bb(h, "number", h.value);
      }K = d ? ue(d) : window;switch (a) {case "focusin":
          if (me(K) || "true" === K.contentEditable) Qe = K, Re = d, Se = null;break;case "focusout":
          Se = Re = Qe = null;break;case "mousedown":
          Te = !0;break;case "contextmenu":case "mouseup":case "dragend":
          Te = !1;Ue(g, c, e);break;case "selectionchange":
          if (Pe) break;case "keydown":case "keyup":
          Ue(g, c, e);}var Q;if (ae) b: {
        switch (a) {case "compositionstart":
            var L = "onCompositionStart";break b;case "compositionend":
            L = "onCompositionEnd";break b;
          case "compositionupdate":
            L = "onCompositionUpdate";break b;}L = void 0;
      } else ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), K = oe(d, L), 0 < K.length && (L = new Ld(L, a, null, c, e), g.push({ event: L, listeners: K }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));if (Q = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({ event: e, listeners: d }), e.data = Q);
    }se(g, b);
  });
}function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a;) {
    var e = a,
        f = e.stateNode;5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));a = a.return;
  }return d;
}function gf(a) {
  if (null === a) return null;do {
    a = a.return;
  } while (a && 5 !== a.tag);return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d;) {
    var h = c,
        k = h.alternate,
        l = h.stateNode;if (null !== k && k === d) break;5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));c = c.return;
  }0 !== g.length && a.push({ event: b, listeners: g });
}function jf() {}var kf = null,
    lf = null;function mf(a, b) {
  switch (a) {case "button":case "input":case "select":case "textarea":
      return !!b.autoFocus;}return !1;
}
function nf(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}var of = "function" === typeof setTimeout ? setTimeout : void 0,
    pf = "function" === typeof clearTimeout ? clearTimeout : void 0;function qf(a) {
  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
}
function rf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;if (1 === b || 3 === b) break;
  }return a;
}function sf(a) {
  a = a.previousSibling;for (var b = 0; a;) {
    if (8 === a.nodeType) {
      var c = a.data;if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;b--;
      } else "/$" === c && b++;
    }a = a.previousSibling;
  }return null;
}var tf = 0;function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}var vf = Math.random().toString(36).slice(2),
    wf = "__reactFiber$" + vf,
    xf = "__reactProps$" + vf,
    ff = "__reactContainer$" + vf,
    yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];if (b) return b;for (var c = a.parentNode; c;) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;if (null !== b.child || null !== c && null !== c.child) for (a = sf(a); null !== a;) {
        if (c = a[wf]) return c;a = sf(a);
      }return b;
    }a = c;c = a.parentNode;
  }return null;
}function Cb(a) {
  a = a[wf] || a[ff];return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;throw Error(y(33));
}function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];void 0 === b && (b = a[yf] = new Set());return b;
}var zf = [],
    Af = -1;function Bf(a) {
  return { current: a };
}function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}function I(a, b) {
  Af++;zf[Af] = a.current;a.current = b;
}var Cf = {},
    M = Bf(Cf),
    N = Bf(!1),
    Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;if (!c) return Cf;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function Ff(a) {
  a = a.childContextTypes;return null !== a && void 0 !== a;
}function Gf() {
  H(N);H(M);
}function Hf(a, b, c) {
  if (M.current !== Cf) throw Error(y(168));I(M, b);I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;a = b.childContextTypes;if ("function" !== typeof d.getChildContext) return c;d = d.getChildContext();for (var e in d) {
    if (!(e in a)) throw Error(y(108, Ra(b) || "Unknown", e));
  }return m({}, c, d);
}function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;Df = M.current;I(M, a);I(N, N.current);return !0;
}function Kf(a, b, c) {
  var d = a.stateNode;if (!d) throw Error(y(169));c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);I(N, c);
}
var Lf = null,
    Mf = null,
    Nf = r.unstable_runWithPriority,
    Of = r.unstable_scheduleCallback,
    Pf = r.unstable_cancelCallback,
    Qf = r.unstable_shouldYield,
    Rf = r.unstable_requestPaint,
    Sf = r.unstable_now,
    Tf = r.unstable_getCurrentPriorityLevel,
    Uf = r.unstable_ImmediatePriority,
    Vf = r.unstable_UserBlockingPriority,
    Wf = r.unstable_NormalPriority,
    Xf = r.unstable_LowPriority,
    Yf = r.unstable_IdlePriority,
    Zf = {},
    $f = void 0 !== Rf ? Rf : function () {},
    ag = null,
    bg = null,
    cg = !1,
    dg = Sf(),
    O = 1E4 > dg ? Sf : function () {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {case Uf:
      return 99;case Vf:
      return 98;case Wf:
      return 97;case Xf:
      return 96;case Yf:
      return 95;default:
      throw Error(y(332));}
}function fg(a) {
  switch (a) {case 99:
      return Uf;case 98:
      return Vf;case 97:
      return Wf;case 96:
      return Xf;case 95:
      return Yf;default:
      throw Error(y(332));}
}function gg(a, b) {
  a = fg(a);return Nf(a, b);
}function hg(a, b, c) {
  a = fg(a);return Of(a, b, c);
}function ig() {
  if (null !== bg) {
    var a = bg;bg = null;Pf(a);
  }jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = !0;var a = 0;try {
      var b = ag;gg(99, function () {
        for (; a < b.length; a++) {
          var c = b[a];do {
            c = c(!0);
          } while (null !== c);
        }
      });ag = null;
    } catch (c) {
      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = !1;
    }
  }
}var kg = ra.ReactCurrentBatchConfig;function lg(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);a = a.defaultProps;for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }return b;
  }return b;
}var mg = Bf(null),
    ng = null,
    og = null,
    pg = null;function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;H(mg);a.type._context._currentValue = b;
}function sg(a, b) {
  for (; null !== a;) {
    var c = a.alternate;if ((a.childLanes & b) === b) {
      if (null === c || (c.childLanes & b) === b) break;else c.childLanes |= b;
    } else a.childLanes |= b, null !== c && (c.childLanes |= b);a = a.return;
  }
}function tg(a, b) {
  ng = a;pg = og = null;a = a.dependencies;null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = !0), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && !1 !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b) pg = a, b = 1073741823;b = { context: a, observedBits: b, next: null };if (null === og) {
      if (null === ng) throw Error(y(308));og = b;ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else og = og.next = b;
  }return a._currentValue;
}var wg = !1;function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}function Ag(a, b) {
  a = a.updateQueue;if (null !== a) {
    a = a.shared;var c = a.pending;null === c ? b.next = b : (b.next = c.next, c.next = b);a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue,
      d = a.alternate;if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null,
        f = null;c = c.firstBaseUpdate;if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };null === f ? e = f = g : f = f.next = g;c = c.next;
      } while (null !== c);null === f ? e = f = b : f = f.next = b;
    } else e = f = b;c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };a.updateQueue = c;return;
  }a = c.lastBaseUpdate;null === a ? c.firstBaseUpdate = b : a.next = b;c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;wg = !1;var f = e.firstBaseUpdate,
      g = e.lastBaseUpdate,
      h = e.shared.pending;if (null !== h) {
    e.shared.pending = null;var k = h,
        l = k.next;k.next = null;null === g ? f = l : g.next = l;g = k;var n = a.alternate;if (null !== n) {
      n = n.updateQueue;var A = n.lastBaseUpdate;A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
    }
  }if (null !== f) {
    A = e.baseState;g = 0;n = l = k = null;do {
      h = f.lane;var p = f.eventTime;if ((d & h) === h) {
        null !== n && (n = n.next = { eventTime: p, lane: 0, tag: f.tag, payload: f.payload, callback: f.callback,
          next: null });a: {
          var C = a,
              x = f;h = b;p = c;switch (x.tag) {case 1:
              C = x.payload;if ("function" === typeof C) {
                A = C.call(p, A, h);break a;
              }A = C;break a;case 3:
              C.flags = C.flags & -4097 | 64;case 0:
              C = x.payload;h = "function" === typeof C ? C.call(p, A, h) : C;if (null === h || void 0 === h) break a;A = m({}, A, h);break a;case 2:
              wg = !0;}
        }null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
      } else p = { eventTime: p, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;f = f.next;if (null === f) if (h = e.shared.pending, null === h) break;else f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);null === n && (k = A);e.baseState = k;e.firstBaseUpdate = l;e.lastBaseUpdate = n;Dg |= g;a.lanes = g;a.memoizedState = A;
  }
}function Eg(a, b, c) {
  a = b.effects;b.effects = null;if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b],
        e = d.callback;if (null !== e) {
      d.callback = null;d = c;if ("function" !== typeof e) throw Error(y(191, e));e.call(d);
    }
  }
}var Fg = new aa.Component().refs;
function Gg(a, b, c, d) {
  b = a.memoizedState;c = c(d, b);c = null === c || void 0 === c ? b : m({}, b, c);a.memoizedState = c;0 === a.lanes && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function isMounted(a) {
    return (a = a._reactInternals) ? Zb(a) === a : !1;
  }, enqueueSetState: function enqueueSetState(a, b, c) {
    a = a._reactInternals;var d = Hg(),
        e = Ig(a),
        f = zg(d, e);f.payload = b;void 0 !== c && null !== c && (f.callback = c);Ag(a, f);Jg(a, e, d);
  }, enqueueReplaceState: function enqueueReplaceState(a, b, c) {
    a = a._reactInternals;var d = Hg(),
        e = Ig(a),
        f = zg(d, e);f.tag = 1;f.payload = b;void 0 !== c && null !== c && (f.callback = c);Ag(a, f);Jg(a, e, d);
  }, enqueueForceUpdate: function enqueueForceUpdate(a, b) {
    a = a._reactInternals;var c = Hg(),
        d = Ig(a),
        e = zg(c, d);e.tag = 2;void 0 !== b && null !== b && (e.callback = b);Ag(a, e);Jg(a, d, c);
  } };function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : !0;
}
function Mg(a, b, c) {
  var d = !1,
      e = Cf;var f = b.contextType;"object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);b = new b(c, f);a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;b.updater = Kg;a.stateNode = b;b._reactInternals = a;d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);return b;
}
function Ng(a, b, c, d) {
  a = b.state;"function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);"function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;e.props = c;e.state = a.memoizedState;e.refs = Fg;xg(a);var f = b.contextType;"object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));Cg(a, c, e, d);e.state = a.memoizedState;f = b.getDerivedStateFromProps;"function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);"function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);"function" === typeof e.componentDidMount && (a.flags |= 4);
}var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;if (null !== a && "function" !== typeof a && "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) {
    if (c._owner) {
      c = c._owner;if (c) {
        if (1 !== c.tag) throw Error(y(309));var d = c.stateNode;
      }if (!d) throw Error(y(147, a));var e = "" + a;if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;b = function b(a) {
        var b = d.refs;b === Fg && (b = d.refs = {});null === a ? delete b[e] : b[e] = a;
      };b._stringRef = e;return b;
    }if ("string" !== typeof a) throw Error(y(284));if (!c._owner) throw Error(y(290, a));
  }return a;
}
function Rg(a, b) {
  if ("textarea" !== a.type) throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;c.nextEffect = null;c.flags = 8;
    }
  }function c(c, d) {
    if (!a) return null;for (; null !== d;) {
      b(c, d), d = d.sibling;
    }return null;
  }function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function e(a, b) {
    a = Tg(a, b);a.index = 0;a.sibling = null;return a;
  }function f(b, c, d) {
    b.index = d;if (!a) return c;d = b.alternate;if (null !== d) return d = d.index, d < c ? (b.flags = 2, c) : d;b.flags = 2;return c;
  }function g(b) {
    a && null === b.alternate && (b.flags = 2);return b;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = Ug(c, a.mode, d), b.return = a, b;b = e(b, c);b.return = a;return b;
  }function k(a, b, c, d) {
    if (null !== b && b.elementType === c.type) return d = e(b, c.props), d.ref = Qg(a, b, c), d.return = a, d;d = Vg(c.type, c.key, c.props, null, a.mode, d);d.ref = Qg(a, b, c);d.return = a;return d;
  }function l(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Wg(c, a.mode, d), b.return = a, b;b = e(b, c.children || []);b.return = a;return b;
  }function n(a, b, c, d, f) {
    if (null === b || 7 !== b.tag) return b = Xg(c, a.mode, d, f), b.return = a, b;b = e(b, c);b.return = a;return b;
  }function A(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = Ug("" + b, a.mode, c), b.return = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case sa:
          return c = Vg(b.type, b.key, b.props, null, a.mode, c), c.ref = Qg(a, null, b), c.return = a, c;case ta:
          return b = Wg(b, a.mode, c), b.return = a, b;}if (Pg(b) || La(b)) return b = Xg(b, a.mode, c, null), b.return = a, b;Rg(a, b);
    }return null;
  }function p(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case sa:
          return c.key === e ? c.type === ua ? n(a, b, c.props.children, d, e) : k(a, b, c, d) : null;case ta:
          return c.key === e ? l(a, b, c, d) : null;}if (Pg(c) || La(c)) return null !== e ? null : n(a, b, c, d, null);Rg(a, c);
    }return null;
  }function C(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case sa:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === ua ? n(b, a, d.props.children, e, d.key) : k(b, a, d, e);case ta:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);}if (Pg(d) || La(d)) return a = a.get(c) || null, n(b, a, d, e, null);Rg(b, d);
    }return null;
  }function x(e, g, h, k) {
    for (var l = null, t = null, u = g, z = g = 0, q = null; null !== u && z < h.length; z++) {
      u.index > z ? (q = u, u = null) : q = u.sibling;var n = p(e, u, h[z], k);if (null === n) {
        null === u && (u = q);break;
      }a && u && null === n.alternate && b(e, u);g = f(n, g, z);null === t ? l = n : t.sibling = n;t = n;u = q;
    }if (z === h.length) return c(e, u), l;if (null === u) {
      for (; z < h.length; z++) {
        u = A(e, h[z], k), null !== u && (g = f(u, g, z), null === t ? l = u : t.sibling = u, t = u);
      }return l;
    }for (u = d(e, u); z < h.length; z++) {
      q = C(u, e, z, h[z], k), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g = f(q, g, z), null === t ? l = q : t.sibling = q, t = q);
    }a && u.forEach(function (a) {
      return b(e, a);
    });return l;
  }function w(e, g, h, k) {
    var l = La(h);if ("function" !== typeof l) throw Error(y(150));h = l.call(h);if (null == h) throw Error(y(151));for (var t = l = null, u = g, z = g = 0, q = null, n = h.next(); null !== u && !n.done; z++, n = h.next()) {
      u.index > z ? (q = u, u = null) : q = u.sibling;var w = p(e, u, n.value, k);if (null === w) {
        null === u && (u = q);break;
      }a && u && null === w.alternate && b(e, u);g = f(w, g, z);null === t ? l = w : t.sibling = w;t = w;u = q;
    }if (n.done) return c(e, u), l;if (null === u) {
      for (; !n.done; z++, n = h.next()) {
        n = A(e, n.value, k), null !== n && (g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);
      }return l;
    }for (u = d(e, u); !n.done; z++, n = h.next()) {
      n = C(u, e, z, n.value, k), null !== n && (a && null !== n.alternate && u.delete(null === n.key ? z : n.key), g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);
    }a && u.forEach(function (a) {
      return b(e, a);
    });return l;
  }return function (a, d, f, h) {
    var k = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && f.type === ua && null === f.key;k && (f = f.props.children);var l = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f;if (l) switch (f.$$typeof) {case sa:
        a: {
          l = f.key;for (k = d; null !== k;) {
            if (k.key === l) {
              switch (k.tag) {case 7:
                  if (f.type === ua) {
                    c(a, k.sibling);d = e(k, f.props.children);d.return = a;a = d;break a;
                  }break;default:
                  if (k.elementType === f.type) {
                    c(a, k.sibling);
                    d = e(k, f.props);d.ref = Qg(a, k, f);d.return = a;a = d;break a;
                  }}c(a, k);break;
            } else b(a, k);k = k.sibling;
          }f.type === ua ? (d = Xg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Vg(f.type, f.key, f.props, null, a.mode, h), h.ref = Qg(a, d, f), h.return = a, a = h);
        }return g(a);case ta:
        a: {
          for (k = f.key; null !== d;) {
            if (d.key === k) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);d = e(d, f.children || []);d.return = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = Wg(f, a.mode, h);d.return = a;a = d;
        }return g(a);}if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Ug(f, a.mode, h), d.return = a, a = d), g(a);if (Pg(f)) return x(a, d, f, h);if (La(f)) return w(a, d, f, h);l && Rg(a, f);if ("undefined" === typeof f && !k) switch (a.tag) {case 1:case 22:case 0:case 11:case 15:
        throw Error(y(152, Ra(a.type) || "Component"));}return c(a, d);
  };
}var Yg = Sg(!0),
    Zg = Sg(!1),
    $g = {},
    ah = Bf($g),
    bh = Bf($g),
    ch = Bf($g);
function dh(a) {
  if (a === $g) throw Error(y(174));return a;
}function eh(a, b) {
  I(ch, b);I(bh, a);I(ah, $g);a = b.nodeType;switch (a) {case 9:case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");break;default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);}H(ah);I(ah, b);
}function fh() {
  H(ah);H(bh);H(ch);
}function gh(a) {
  dh(ch.current);var b = dh(ah.current);var c = mb(b, a.type);b !== c && (I(bh, a), I(ah, c));
}function hh(a) {
  bh.current === a && (H(ah), H(bh));
}var P = Bf(0);
function ih(a) {
  for (var b = a; null !== b;) {
    if (13 === b.tag) {
      var c = b.memoizedState;if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 64)) return b;
    } else if (null !== b.child) {
      b.child.return = b;b = b.child;continue;
    }if (b === a) break;for (; null === b.sibling;) {
      if (null === b.return || b.return === a) return null;b = b.return;
    }b.sibling.return = b.return;b = b.sibling;
  }return null;
}var jh = null,
    kh = null,
    lh = !1;
function mh(a, b) {
  var c = nh(5, null, null, 0);c.elementType = "DELETED";c.type = "DELETED";c.stateNode = b;c.return = a;c.flags = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}function oh(a, b) {
  switch (a.tag) {case 5:
      var c = a.type;b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;return null !== b ? (a.stateNode = b, !0) : !1;case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1;case 13:
      return !1;default:
      return !1;}
}
function ph(a) {
  if (lh) {
    var b = kh;if (b) {
      var c = b;if (!oh(a, b)) {
        b = rf(c.nextSibling);if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;lh = !1;jh = a;return;
        }mh(jh, c);
      }jh = a;kh = rf(b.firstChild);
    } else a.flags = a.flags & -1025 | 2, lh = !1, jh = a;
  }
}function qh(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) {
    a = a.return;
  }jh = a;
}
function rh(a) {
  if (a !== jh) return !1;if (!lh) return qh(a), lh = !0, !1;var b = a.type;if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps)) for (b = kh; b;) {
    mh(a, b), b = rf(b.nextSibling);
  }qh(a);if (13 === a.tag) {
    a = a.memoizedState;a = null !== a ? a.dehydrated : null;if (!a) throw Error(y(317));a: {
      a = a.nextSibling;for (b = 0; a;) {
        if (8 === a.nodeType) {
          var c = a.data;if ("/$" === c) {
            if (0 === b) {
              kh = rf(a.nextSibling);break a;
            }b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }a = a.nextSibling;
      }kh = null;
    }
  } else kh = jh ? rf(a.stateNode.nextSibling) : null;return !0;
}
function sh() {
  kh = jh = null;lh = !1;
}var th = [];function uh() {
  for (var a = 0; a < th.length; a++) {
    th[a]._workInProgressVersionPrimary = null;
  }th.length = 0;
}var vh = ra.ReactCurrentDispatcher,
    wh = ra.ReactCurrentBatchConfig,
    xh = 0,
    R = null,
    S = null,
    T = null,
    yh = !1,
    zh = !1;function Ah() {
  throw Error(y(321));
}function Bh(a, b) {
  if (null === b) return !1;for (var c = 0; c < b.length && c < a.length; c++) {
    if (!He(a[c], b[c])) return !1;
  }return !0;
}
function Ch(a, b, c, d, e, f) {
  xh = f;R = b;b.memoizedState = null;b.updateQueue = null;b.lanes = 0;vh.current = null === a || null === a.memoizedState ? Dh : Eh;a = c(d, e);if (zh) {
    f = 0;do {
      zh = !1;if (!(25 > f)) throw Error(y(301));f += 1;T = S = null;b.updateQueue = null;vh.current = Fh;a = c(d, e);
    } while (zh);
  }vh.current = Gh;b = null !== S && null !== S.next;xh = 0;T = S = R = null;yh = !1;if (b) throw Error(y(300));return a;
}function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };null === T ? R.memoizedState = T = a : T = T.next = a;return T;
}
function Ih() {
  if (null === S) {
    var a = R.alternate;a = null !== a ? a.memoizedState : null;
  } else a = S.next;var b = null === T ? R.memoizedState : T.next;if (null !== b) T = b, S = a;else {
    if (null === a) throw Error(y(310));S = a;a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };null === T ? R.memoizedState = T = a : T = T.next = a;
  }return T;
}function Jh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Kh(a) {
  var b = Ih(),
      c = b.queue;if (null === c) throw Error(y(311));c.lastRenderedReducer = a;var d = S,
      e = d.baseQueue,
      f = c.pending;if (null !== f) {
    if (null !== e) {
      var g = e.next;e.next = f.next;f.next = g;
    }d.baseQueue = e = f;c.pending = null;
  }if (null !== e) {
    e = e.next;d = d.baseState;var h = g = f = null,
        k = e;do {
      var l = k.lane;if ((xh & l) === l) null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);else {
        var n = { lane: l, action: k.action, eagerReducer: k.eagerReducer,
          eagerState: k.eagerState, next: null };null === h ? (g = h = n, f = d) : h = h.next = n;R.lanes |= l;Dg |= l;
      }k = k.next;
    } while (null !== k && k !== e);null === h ? f = d : h.next = g;He(d, b.memoizedState) || (ug = !0);b.memoizedState = d;b.baseState = f;b.baseQueue = h;c.lastRenderedState = d;
  }return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(),
      c = b.queue;if (null === c) throw Error(y(311));c.lastRenderedReducer = a;var d = c.dispatch,
      e = c.pending,
      f = b.memoizedState;if (null !== e) {
    c.pending = null;var g = e = e.next;do {
      f = a(f, g.action), g = g.next;
    } while (g !== e);He(f, b.memoizedState) || (ug = !0);b.memoizedState = f;null === b.baseQueue && (b.baseState = f);c.lastRenderedState = f;
  }return [f, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;d = d(b._source);var e = b._workInProgressVersionPrimary;if (null !== e) a = e === d;else if (a = a.mutableReadLanes, a = (xh & a) === a) b._workInProgressVersionPrimary = d, th.push(b);if (a) return c(b._source);th.push(b);throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;if (null === e) throw Error(y(349));var f = b._getVersion,
      g = f(b._source),
      h = vh.current,
      k = h.useState(function () {
    return Mh(e, b, c);
  }),
      l = k[1],
      n = k[0];k = T;var A = a.memoizedState,
      p = A.refs,
      C = p.getSnapshot,
      x = A.source;A = A.subscribe;var w = R;a.memoizedState = { refs: p, source: b, subscribe: d };h.useEffect(function () {
    p.getSnapshot = c;p.setSnapshot = l;var a = f(b._source);if (!He(g, a)) {
      a = c(b._source);He(n, a) || (l(a), a = Ig(w), e.mutableReadLanes |= a & e.pendingLanes);a = e.mutableReadLanes;e.entangledLanes |= a;for (var d = e.entanglements, h = a; 0 < h;) {
        var k = 31 - Vc(h),
            v = 1 << k;d[k] |= a;h &= ~v;
      }
    }
  }, [c, b, d]);h.useEffect(function () {
    return d(b._source, function () {
      var a = p.getSnapshot,
          c = p.setSnapshot;try {
        c(a(b._source));var d = Ig(w);e.mutableReadLanes |= d & e.pendingLanes;
      } catch (q) {
        c(function () {
          throw q;
        });
      }
    });
  }, [b, d]);He(C, c) && He(x, b) && He(A, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);return n;
}
function Ph(a, b, c) {
  var d = Ih();return Nh(d, a, b, c);
}function Qh(a) {
  var b = Hh();"function" === typeof a && (a = a());b.memoizedState = b.baseState = a;a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };a = a.dispatch = Oh.bind(null, R, a);return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };b = R.updateQueue;null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));return a;
}function Sh(a) {
  var b = Hh();a = { current: a };return b.memoizedState = a;
}function Th() {
  return Ih().memoizedState;
}function Uh(a, b, c, d) {
  var e = Hh();R.flags |= a;e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();d = void 0 === d ? null : d;var f = void 0;if (null !== S) {
    var g = S.memoizedState;f = g.destroy;if (null !== d && Bh(d, g.deps)) {
      Rh(b, c, f, d);return;
    }
  }R.flags |= a;e.memoizedState = Rh(1 | b, c, f, d);
}function Wh(a, b) {
  return Uh(516, 4, a, b);
}function Xh(a, b) {
  return Vh(516, 4, a, b);
}function Yh(a, b) {
  return Vh(4, 2, a, b);
}function Zh(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function () {
    b(null);
  };if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
    b.current = null;
  };
}
function $h(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;return Vh(4, 2, Zh.bind(null, b, a), c);
}function ai() {}function bi(a, b) {
  var c = Ih();b = void 0 === b ? null : b;var d = c.memoizedState;if (null !== d && null !== b && Bh(b, d[1])) return d[0];c.memoizedState = [a, b];return a;
}function ci(a, b) {
  var c = Ih();b = void 0 === b ? null : b;var d = c.memoizedState;if (null !== d && null !== b && Bh(b, d[1])) return d[0];a = a();c.memoizedState = [a, b];return a;
}
function di(a, b) {
  var c = eg();gg(98 > c ? 98 : c, function () {
    a(!0);
  });gg(97 < c ? 97 : c, function () {
    var c = wh.transition;wh.transition = 1;try {
      a(!1), b();
    } finally {
      wh.transition = c;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(),
      e = Ig(a),
      f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null },
      g = b.pending;null === g ? f.next = f : (f.next = g.next, g.next = f);b.pending = f;g = a.alternate;if (a === R || null !== g && g === R) zh = yh = !0;else {
    if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g)) try {
      var h = b.lastRenderedState,
          k = g(h, c);f.eagerReducer = g;f.eagerState = k;if (He(k, h)) return;
    } catch (l) {} finally {}Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: !1 },
    Dh = { readContext: vg, useCallback: function useCallback(a, b) {
    Hh().memoizedState = [a, void 0 === b ? null : b];return a;
  }, useContext: vg, useEffect: Wh, useImperativeHandle: function useImperativeHandle(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;return Uh(4, 2, Zh.bind(null, b, a), c);
  }, useLayoutEffect: function useLayoutEffect(a, b) {
    return Uh(4, 2, a, b);
  }, useMemo: function useMemo(a, b) {
    var c = Hh();b = void 0 === b ? null : b;a = a();c.memoizedState = [a, b];return a;
  }, useReducer: function useReducer(a, b, c) {
    var d = Hh();b = void 0 !== c ? c(b) : b;d.memoizedState = d.baseState = b;a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };a = a.dispatch = Oh.bind(null, R, a);return [d.memoizedState, a];
  }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function useDeferredValue(a) {
    var b = Qh(a),
        c = b[0],
        d = b[1];Wh(function () {
      var b = wh.transition;
      wh.transition = 1;try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);return c;
  }, useTransition: function useTransition() {
    var a = Qh(!1),
        b = a[0];a = di.bind(null, a[1]);Sh(a);return [a, b];
  }, useMutableSource: function useMutableSource(a, b, c) {
    var d = Hh();d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };return Nh(d, a, b, c);
  }, useOpaqueIdentifier: function useOpaqueIdentifier() {
    if (lh) {
      var a = !1,
          b = uf(function () {
        a || (a = !0, c("r:" + (tf++).toString(36)));throw Error(y(355));
      }),
          c = Qh(b)[1];0 === (R.mode & 2) && (R.flags |= 516, Rh(5, function () {
        c("r:" + (tf++).toString(36));
      }, void 0, null));return b;
    }b = "r:" + (tf++).toString(36);Qh(b);return b;
  }, unstable_isNewReconciler: !1 },
    Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function useState() {
    return Kh(Jh);
  }, useDebugValue: ai, useDeferredValue: function useDeferredValue(a) {
    var b = Kh(Jh),
        c = b[0],
        d = b[1];Xh(function () {
      var b = wh.transition;wh.transition = 1;try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);return c;
  }, useTransition: function useTransition() {
    var a = Kh(Jh)[0];return [Th().current, a];
  }, useMutableSource: Ph, useOpaqueIdentifier: function useOpaqueIdentifier() {
    return Kh(Jh)[0];
  }, unstable_isNewReconciler: !1 },
    Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function useState() {
    return Lh(Jh);
  }, useDebugValue: ai, useDeferredValue: function useDeferredValue(a) {
    var b = Lh(Jh),
        c = b[0],
        d = b[1];Xh(function () {
      var b = wh.transition;wh.transition = 1;try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);return c;
  }, useTransition: function useTransition() {
    var a = Lh(Jh)[0];return [Th().current, a];
  }, useMutableSource: Ph, useOpaqueIdentifier: function useOpaqueIdentifier() {
    return Lh(Jh)[0];
  }, unstable_isNewReconciler: !1 },
    ei = ra.ReactCurrentOwner,
    ug = !1;function fi(a, b, c, d) {
  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}function gi(a, b, c, d, e) {
  c = c.render;var f = b.ref;tg(b, e);d = Ch(a, b, c, d, f, e);if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);b.flags |= 1;fi(a, b, d, e);return b.child;
}
function ii(a, b, c, d, e, f) {
  if (null === a) {
    var g = c.type;if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);a = Vg(c.type, null, d, b, b.mode, f);a.ref = b.ref;a.return = b;return b.child = a;
  }g = a.child;if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref)) return hi(a, b, f);b.flags |= 1;a = Tg(g, d);a.ref = b.ref;a.return = b;return b.child = a;
}
function ki(a, b, c, d, e, f) {
  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref) if (ug = !1, 0 !== (f & e)) 0 !== (a.flags & 16384) && (ug = !0);else return b.lanes = a.lanes, hi(a, b, f);return li(a, b, c, d, f);
}
function mi(a, b, c) {
  var d = b.pendingProps,
      e = d.children,
      f = null !== a ? a.memoizedState : null;if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode) {
    if (0 === (b.mode & 4)) b.memoizedState = { baseLanes: 0 }, ni(b, c);else if (0 !== (c & 1073741824)) b.memoizedState = { baseLanes: 0 }, ni(b, null !== f ? f.baseLanes : c);else return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);fi(a, b, e, c);return b.child;
}
function oi(a, b) {
  var c = b.ref;if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 128;
}function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;f = Ef(b, f);tg(b, e);c = Ch(a, b, c, d, f, e);if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);b.flags |= 1;fi(a, b, c, e);return b.child;
}
function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f = !0;Jf(b);
  } else f = !1;tg(b, e);if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = !0;else if (null === a) {
    var g = b.stateNode,
        h = b.memoizedProps;g.props = h;var k = g.context,
        l = c.contextType;"object" === (typeof l === "undefined" ? "undefined" : _typeof(l)) && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));var n = c.getDerivedStateFromProps,
        A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);wg = !1;var p = b.memoizedState;g.state = p;Cg(b, d, g, e);k = b.memoizedState;h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = !1);
  } else {
    g = b.stateNode;yg(a, b);h = b.memoizedProps;l = b.type === b.elementType ? h : lg(b.type, h);g.props = l;A = b.pendingProps;p = g.context;k = c.contextType;"object" === (typeof k === "undefined" ? "undefined" : _typeof(k)) && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));var C = c.getDerivedStateFromProps;(n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);wg = !1;p = b.memoizedState;g.state = p;Cg(b, d, g, e);var x = b.memoizedState;h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = !1);
  }return qi(a, b, c, d, f, e);
}
function qi(a, b, c, d, e, f) {
  oi(a, b);var g = 0 !== (b.flags & 64);if (!d && !g) return e && Kf(b, c, !1), hi(a, b, f);d = b.stateNode;ei.current = b;var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();b.flags |= 1;null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);b.memoizedState = d.state;e && Kf(b, c, !0);return b.child;
}function ri(a) {
  var b = a.stateNode;b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, !1);eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps,
      e = P.current,
      f = !1,
      g;(g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));g ? (f = !0, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || !0 === d.unstable_avoidThisFallback || (e |= 1);I(P, e & 1);if (null === a) {
    void 0 !== d.fallback && ph(b);a = d.children;e = d.fallback;if (f) return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;if ("number" === typeof d.unstable_expectedLoadTime) return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;c = vi({ mode: "visible", children: a }, b.mode, c, null);c.return = b;return b.child = c;
  }if (null !== a.memoizedState) {
    if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;c = xi(a, b, d.children, c);b.memoizedState = null;return c;
  }if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;c = xi(a, b, d.children, c);b.memoizedState = null;return c;
}function ui(a, b, c, d) {
  var e = a.mode,
      f = a.child;b = { mode: "hidden", children: b };0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);c = Xg(c, e, d, null);f.return = a;c.return = a;f.sibling = c;a.child = f;return c;
}
function xi(a, b, c, d) {
  var e = a.child;a = e.sibling;c = Tg(e, { mode: "visible", children: c });0 === (b.mode & 2) && (c.lanes = d);c.return = b;c.sibling = null;null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);return b.child = c;
}
function wi(a, b, c, d, e) {
  var f = b.mode,
      g = a.child;a = g.sibling;var h = { mode: "hidden", children: c };0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);d.return = b;c.return = b;c.sibling = d;b.child = c;return d;
}function yi(a, b) {
  a.lanes |= b;var c = a.alternate;null !== c && (c.lanes |= b);sg(a.return, b);
}
function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;null === g ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}
function Ai(a, b, c) {
  var d = b.pendingProps,
      e = d.revealOrder,
      f = d.tail;fi(a, b, d.children, c);d = P.current;if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 64;else {
    if (null !== a && 0 !== (a.flags & 64)) a: for (a = b.child; null !== a;) {
      if (13 === a.tag) null !== a.memoizedState && yi(a, c);else if (19 === a.tag) yi(a, c);else if (null !== a.child) {
        a.child.return = a;a = a.child;continue;
      }if (a === b) break a;for (; null === a.sibling;) {
        if (null === a.return || a.return === b) break a;a = a.return;
      }a.sibling.return = a.return;a = a.sibling;
    }d &= 1;
  }I(P, d);if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {case "forwards":
      c = b.child;for (e = null; null !== c;) {
        a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
      }c = e;null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);zi(b, !1, e, c, f, b.lastEffect);break;case "backwards":
      c = null;e = b.child;for (b.child = null; null !== e;) {
        a = e.alternate;if (null !== a && null === ih(a)) {
          b.child = e;break;
        }a = e.sibling;e.sibling = c;c = e;e = a;
      }zi(b, !0, c, null, f, b.lastEffect);break;case "together":
      zi(b, !1, null, null, void 0, b.lastEffect);break;default:
      b.memoizedState = null;}return b.child;
}
function hi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);Dg |= b.lanes;if (0 !== (c & b.childLanes)) {
    if (null !== a && b.child !== a.child) throw Error(y(153));if (null !== b.child) {
      a = b.child;c = Tg(a, a.pendingProps);b.child = c;for (c.return = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      }c.sibling = null;
    }return b.child;
  }return null;
}var Bi, Ci, Di, Ei;
Bi = function Bi(a, b) {
  for (var c = b.child; null !== c;) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;c = c.child;continue;
    }if (c === b) break;for (; null === c.sibling;) {
      if (null === c.return || c.return === b) return;c = c.return;
    }c.sibling.return = c.return;c = c.sibling;
  }
};Ci = function Ci() {};
Di = function Di(a, b, c, d) {
  var e = a.memoizedProps;if (e !== d) {
    a = b.stateNode;dh(ah.current);var f = null;switch (c) {case "input":
        e = Ya(a, e);d = Ya(a, d);f = [];break;case "option":
        e = eb(a, e);d = eb(a, d);f = [];break;case "select":
        e = m({}, e, { value: void 0 });d = m({}, d, { value: void 0 });f = [];break;case "textarea":
        e = gb(a, e);d = gb(a, d);f = [];break;default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);}vb(c, d);var g;c = null;for (l in e) {
      if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];for (g in h) {
          h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        }
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
    }for (l in d) {
      var k = d[l];h = null != e ? e[l] : void 0;if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
        if (h) {
          for (g in h) {
            !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          }for (g in k) {
            k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          }
        } else c || (f || (f = []), f.push(l, c)), c = k;
      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === (typeof k === "undefined" ? "undefined" : _typeof(k)) && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
    }c && (f = f || []).push("style", c);var l = f;if (b.updateQueue = l) b.flags |= 4;
  }
};Ei = function Ei(a, b, c, d) {
  c !== d && (b.flags |= 4);
};function Fi(a, b) {
  if (!lh) switch (a.tailMode) {case "hidden":
      b = a.tail;for (var c = null; null !== b;) {
        null !== b.alternate && (c = b), b = b.sibling;
      }null === c ? a.tail = null : c.sibling = null;break;case "collapsed":
      c = a.tail;for (var d = null; null !== c;) {
        null !== c.alternate && (d = c), c = c.sibling;
      }null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;}
}
function Gi(a, b, c) {
  var d = b.pendingProps;switch (b.tag) {case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:
      return null;case 1:
      return Ff(b.type) && Gf(), null;case 3:
      fh();H(N);H(M);uh();d = b.stateNode;d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);if (null === a || null === a.child) rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);Ci(b);return null;case 5:
      hh(b);var e = dh(ch.current);c = b.type;if (null !== a && null != b.stateNode) Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);else {
        if (!d) {
          if (null === b.stateNode) throw Error(y(166));return null;
        }a = dh(ah.current);if (rh(b)) {
          d = b.stateNode;c = b.type;var f = b.memoizedProps;d[wf] = b;d[xf] = f;switch (c) {case "dialog":
              G("cancel", d);G("close", d);break;case "iframe":case "object":case "embed":
              G("load", d);break;case "video":case "audio":
              for (a = 0; a < Xe.length; a++) {
                G(Xe[a], d);
              }break;case "source":
              G("error", d);break;case "img":case "image":case "link":
              G("error", d);G("load", d);break;case "details":
              G("toggle", d);break;case "input":
              Za(d, f);G("invalid", d);break;case "select":
              d._wrapperState = { wasMultiple: !!f.multiple };G("invalid", d);break;case "textarea":
              hb(d, f), G("invalid", d);}vb(c, f);a = null;for (var g in f) {
            f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
          }switch (c) {case "input":
              Va(d);cb(d, f, !0);break;case "textarea":
              Va(d);jb(d);break;case "select":case "option":
              break;default:
              "function" === typeof f.onClick && (d.onclick = jf);}d = a;b.updateQueue = d;null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;a === kb.html && (a = lb(c));a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);a[wf] = b;a[xf] = d;Bi(a, b, !1, !1);b.stateNode = a;g = wb(c, d);switch (c) {case "dialog":
              G("cancel", a);G("close", a);
              e = d;break;case "iframe":case "object":case "embed":
              G("load", a);e = d;break;case "video":case "audio":
              for (e = 0; e < Xe.length; e++) {
                G(Xe[e], a);
              }e = d;break;case "source":
              G("error", a);e = d;break;case "img":case "image":case "link":
              G("error", a);G("load", a);e = d;break;case "details":
              G("toggle", a);e = d;break;case "input":
              Za(a, d);e = Ya(a, d);G("invalid", a);break;case "option":
              e = eb(a, d);break;case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };e = m({}, d, { value: void 0 });G("invalid", a);break;case "textarea":
              hb(a, d);e = gb(a, d);G("invalid", a);break;default:
              e = d;}vb(c, e);var h = e;for (f in h) {
            if (h.hasOwnProperty(f)) {
              var k = h[f];"style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
            }
          }switch (c) {case "input":
              Va(a);cb(a, d, !1);
              break;case "textarea":
              Va(a);jb(a);break;case "option":
              null != d.value && a.setAttribute("value", "" + Sa(d.value));break;case "select":
              a.multiple = !!d.multiple;f = d.value;null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);break;default:
              "function" === typeof e.onClick && (a.onclick = jf);}mf(c, d) && (b.flags |= 4);
        }null !== b.ref && (b.flags |= 128);
      }return null;case 6:
      if (a && null != b.stateNode) Ei(a, b, a.memoizedProps, d);else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(y(166));
        c = dh(ch.current);dh(ah.current);rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }return null;case 13:
      H(P);d = b.memoizedState;if (0 !== (b.flags & 64)) return b.lanes = c, b;d = null !== d;c = !1;null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;if (d && !c && 0 !== (b.mode & 2)) if (null === a && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1)) 0 === V && (V = 3);else {
        if (0 === V || 3 === V) V = 4;null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
      }if (d || c) b.flags |= 4;return null;case 4:
      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;case 10:
      return rg(b), null;case 17:
      return Ff(b.type) && Gf(), null;case 19:
      H(P);d = b.memoizedState;if (null === d) return null;f = 0 !== (b.flags & 64);g = d.rendering;if (null === g) {
        if (f) Fi(d, !1);else {
          if (0 !== V || null !== a && 0 !== (a.flags & 64)) for (a = b.child; null !== a;) {
            g = ih(a);if (null !== g) {
              b.flags |= 64;Fi(d, !1);f = g.updateQueue;null !== f && (b.updateQueue = f, b.flags |= 4);
              null === d.lastEffect && (b.firstEffect = null);b.lastEffect = d.lastEffect;d = c;for (c = b.child; null !== c;) {
                f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              }I(P, P.current & 1 | 2);return b.child;
            }a = a.sibling;
          }null !== d.tail && O() > Ji && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
        }
      } else {
        if (!f) if (a = ih(g), null !== a) {
          if (b.flags |= 64, f = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, !0), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
        } else 2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
      }return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;case 23:case 24:
      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;}throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {case 1:
      Ff(a.type) && Gf();var b = a.flags;return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;case 3:
      fh();H(N);H(M);uh();b = a.flags;if (0 !== (b & 64)) throw Error(y(285));a.flags = b & -4097 | 64;return a;case 5:
      return hh(a), null;case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;case 19:
      return H(P), null;case 4:
      return fh(), null;case 10:
      return rg(a), null;case 23:case 24:
      return Ki(), null;default:
      return null;}
}
function Mi(a, b) {
  try {
    var c = "",
        d = b;do {
      c += Qa(d), d = d.return;
    } while (d);var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }return { value: a, source: b, stack: e };
}function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function () {
      throw c;
    });
  }
}var Oi = "function" === typeof WeakMap ? WeakMap : Map;function Pi(a, b, c) {
  c = zg(-1, c);c.tag = 3;c.payload = { element: null };var d = b.value;c.callback = function () {
    Qi || (Qi = !0, Ri = d);Ni(a, b);
  };return c;
}
function Si(a, b, c) {
  c = zg(-1, c);c.tag = 3;var d = a.type.getDerivedStateFromError;if ("function" === typeof d) {
    var e = b.value;c.payload = function () {
      Ni(a, b);return d(e);
    };
  }var f = a.stateNode;null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
    "function" !== typeof d && (null === Ti ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));var c = b.stack;this.componentDidCatch(b.value, { componentStack: null !== c ? c : "" });
  });return c;
}var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;if (null !== b) if ("function" === typeof b) try {
    b(null);
  } catch (c) {
    Wi(a, c);
  } else b.current = null;
}function Xi(a, b) {
  switch (b.tag) {case 0:case 11:case 15:case 22:
      return;case 1:
      if (b.flags & 256 && null !== a) {
        var c = a.memoizedProps,
            d = a.memoizedState;a = b.stateNode;b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);a.__reactInternalSnapshotBeforeUpdate = b;
      }return;case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:
      return;}throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {case 0:case 11:case 15:case 22:
      b = c.updateQueue;b = null !== b ? b.lastEffect : null;if (null !== b) {
        a = b = b.next;do {
          if (3 === (a.tag & 3)) {
            var d = a.create;a.destroy = d();
          }a = a.next;
        } while (a !== b);
      }b = c.updateQueue;b = null !== b ? b.lastEffect : null;if (null !== b) {
        a = b = b.next;do {
          var e = a;d = e.next;e = e.tag;0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));a = d;
        } while (a !== b);
      }return;case 1:
      a = c.stateNode;c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));b = c.updateQueue;null !== b && Eg(c, b, a);return;case 3:
      b = c.updateQueue;if (null !== b) {
        a = null;if (null !== c.child) switch (c.child.tag) {case 5:
            a = c.child.stateNode;break;case 1:
            a = c.child.stateNode;}Eg(c, b, a);
      }return;case 5:
      a = c.stateNode;null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();return;case 6:
      return;case 4:
      return;case 12:
      return;case 13:
      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
      return;case 19:case 17:case 20:case 21:case 23:case 24:
      return;}throw Error(y(163));
}
function aj(a, b) {
  for (var c = a;;) {
    if (5 === c.tag) {
      var d = c.stateNode;if (b) d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";else {
        d = c.stateNode;var e = c.memoizedProps.style;e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;d.style.display = sb("display", e);
      }
    } else if (6 === c.tag) c.stateNode.nodeValue = b ? "" : c.memoizedProps;else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
      c.child.return = c;c = c.child;continue;
    }if (c === a) break;for (; null === c.sibling;) {
      if (null === c.return || c.return === a) return;c = c.return;
    }c.sibling.return = c.return;c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount) try {
    Mf.onCommitFiberUnmount(Lf, b);
  } catch (f) {}switch (b.tag) {case 0:case 11:case 14:case 15:case 22:
      a = b.updateQueue;if (null !== a && (a = a.lastEffect, null !== a)) {
        var c = a = a.next;do {
          var d = c,
              e = d.destroy;d = d.tag;if (void 0 !== e) if (0 !== (d & 4)) Zi(b, c);else {
            d = b;try {
              e();
            } catch (f) {
              Wi(d, f);
            }
          }c = c.next;
        } while (c !== a);
      }break;case 1:
      Vi(b);a = b.stateNode;if ("function" === typeof a.componentWillUnmount) try {
        a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
      } catch (f) {
        Wi(b, f);
      }break;case 5:
      Vi(b);break;case 4:
      cj(a, b);}
}function dj(a) {
  a.alternate = null;a.child = null;a.dependencies = null;a.firstEffect = null;a.lastEffect = null;a.memoizedProps = null;a.memoizedState = null;a.pendingProps = null;a.return = null;a.updateQueue = null;
}function ej(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function fj(a) {
  a: {
    for (var b = a.return; null !== b;) {
      if (ej(b)) break a;b = b.return;
    }throw Error(y(160));
  }var c = b;b = c.stateNode;switch (c.tag) {case 5:
      var d = !1;break;case 3:
      b = b.containerInfo;d = !0;break;case 4:
      b = b.containerInfo;d = !0;break;default:
      throw Error(y(161));}c.flags & 16 && (pb(b, ""), c.flags &= -17);a: b: for (c = a;;) {
    for (; null === c.sibling;) {
      if (null === c.return || ej(c.return)) {
        c = null;break a;
      }c = c.return;
    }c.sibling.return = c.return;for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
      if (c.flags & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;
    }if (!(c.flags & 2)) {
      c = c.stateNode;break a;
    }
  }d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag,
      e = 5 === d || 6 === d;if (e) a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));else if (4 !== d && (a = a.child, null !== a)) for (gj(a, b, c), a = a.sibling; null !== a;) {
    gj(a, b, c), a = a.sibling;
  }
}
function hj(a, b, c) {
  var d = a.tag,
      e = 5 === d || 6 === d;if (e) a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (hj(a, b, c), a = a.sibling; null !== a;) {
    hj(a, b, c), a = a.sibling;
  }
}
function cj(a, b) {
  for (var c = b, d = !1, e, f;;) {
    if (!d) {
      d = c.return;a: for (;;) {
        if (null === d) throw Error(y(160));e = d.stateNode;switch (d.tag) {case 5:
            f = !1;break a;case 3:
            e = e.containerInfo;f = !0;break a;case 4:
            e = e.containerInfo;f = !0;break a;}d = d.return;
      }d = !0;
    }if (5 === c.tag || 6 === c.tag) {
      a: for (var g = a, h = c, k = h;;) {
        if (bj(g, k), null !== k.child && 4 !== k.tag) k.child.return = k, k = k.child;else {
          if (k === h) break a;for (; null === k.sibling;) {
            if (null === k.return || k.return === h) break a;k = k.return;
          }k.sibling.return = k.return;k = k.sibling;
        }
      }f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (4 === c.tag) {
      if (null !== c.child) {
        e = c.stateNode.containerInfo;f = !0;c.child.return = c;c = c.child;continue;
      }
    } else if (bj(a, c), null !== c.child) {
      c.child.return = c;c = c.child;continue;
    }if (c === b) break;for (; null === c.sibling;) {
      if (null === c.return || c.return === b) return;c = c.return;4 === c.tag && (d = !1);
    }c.sibling.return = c.return;c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {case 0:case 11:case 14:case 15:case 22:
      var c = b.updateQueue;c = null !== c ? c.lastEffect : null;if (null !== c) {
        var d = c = c.next;do {
          3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
        } while (d !== c);
      }return;case 1:
      return;case 5:
      c = b.stateNode;if (null != c) {
        d = b.memoizedProps;var e = null !== a ? a.memoizedProps : d;a = b.type;var f = b.updateQueue;b.updateQueue = null;if (null !== f) {
          c[xf] = d;"input" === a && "radio" === d.type && null != d.name && $a(c, d);wb(a, e);b = wb(a, d);for (e = 0; e < f.length; e += 2) {
            var g = f[e],
                h = f[e + 1];"style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
          }switch (a) {case "input":
              ab(c, d);break;case "textarea":
              ib(c, d);break;case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, !1) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, !0) : fb(c, !!d.multiple, d.multiple ? [] : "", !1));}
        }
      }return;case 6:
      if (null === b.stateNode) throw Error(y(162));b.stateNode.nodeValue = b.memoizedProps;return;case 3:
      c = b.stateNode;c.hydrate && (c.hydrate = !1, Cc(c.containerInfo));return;case 12:
      return;case 13:
      null !== b.memoizedState && (jj = O(), aj(b.child, !0));kj(b);return;case 19:
      kj(b);return;case 17:
      return;case 23:case 24:
      aj(b, null !== b.memoizedState);return;}throw Error(y(163));
}function kj(a) {
  var b = a.updateQueue;if (null !== b) {
    a.updateQueue = null;var c = a.stateNode;null === c && (c = a.stateNode = new Ui());b.forEach(function (b) {
      var d = lj.bind(null, a, b);c.has(b) || (c.add(b), b.then(d, d));
    });
  }
}
function mj(a, b) {
  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : !1;
}var nj = Math.ceil,
    oj = ra.ReactCurrentDispatcher,
    pj = ra.ReactCurrentOwner,
    X = 0,
    U = null,
    Y = null,
    W = 0,
    qj = 0,
    rj = Bf(0),
    V = 0,
    sj = null,
    tj = 0,
    Dg = 0,
    Hi = 0,
    uj = 0,
    vj = null,
    jj = 0,
    Ji = Infinity;function wj() {
  Ji = O() + 500;
}var Z = null,
    Qi = !1,
    Ri = null,
    Ti = null,
    xj = !1,
    yj = null,
    zj = 90,
    Aj = [],
    Bj = [],
    Cj = null,
    Dj = 0,
    Ej = null,
    Fj = -1,
    Gj = 0,
    Hj = 0,
    Ij = null,
    Jj = !1;function Hg() {
  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;if (0 === (a & 2)) return 1;if (0 === (a & 4)) return 99 === eg() ? 1 : 2;0 === Gj && (Gj = tj);if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);a = Gj;var b = 4186112 & ~Hj;b &= -b;0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));return b;
  }a = eg();0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));return a;
}
function Jg(a, b, c) {
  if (50 < Dj) throw Dj = 0, Ej = null, Error(y(185));a = Kj(a, b);if (null === a) return null;$c(a, b, c);a === U && (Hi |= b, 4 === V && Ii(a, W));var d = eg();1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));vj = a;
}function Kj(a, b) {
  a.lanes |= b;var c = a.alternate;null !== c && (c.lanes |= b);c = a;for (a = a.return; null !== a;) {
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  }return 3 === c.tag ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g;) {
    var h = 31 - Vc(g),
        k = 1 << h,
        l = f[h];if (-1 === l) {
      if (0 === (k & d) || 0 !== (k & e)) {
        l = b;Rc(k);var n = F;f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5E3 : -1;
      }
    } else l <= b && (a.expiredLanes |= k);g &= ~k;
  }d = Uc(a, a === U ? W : 0);b = F;if (0 === d) null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);else {
    if (null !== c) {
      if (a.callbackPriority === b) return;c !== Zf && Pf(c);
    }15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));a.callbackPriority = b;a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;Hj = Gj = 0;if (0 !== (X & 48)) throw Error(y(327));var b = a.callbackNode;if (Oj() && a.callbackNode !== b) return null;var c = Uc(a, a === U ? W : 0);if (0 === c) return null;var d = c;var e = X;X |= 16;var f = Pj();if (U !== a || W !== d) wj(), Qj(a, d);do {
    try {
      Rj();break;
    } catch (h) {
      Sj(a, h);
    }
  } while (1);qg();oj.current = f;X = e;null !== Y ? d = 0 : (U = null, W = 0, d = V);if (0 !== (tj & Hi)) Qj(a, 0);else if (0 !== d) {
    2 === d && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));if (1 === d) throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;a.finishedWork = a.current.alternate;a.finishedLanes = c;switch (d) {case 0:case 1:
        throw Error(y(345));case 2:
        Uj(a);break;case 3:
        Ii(a, c);if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (0 !== Uc(a, 0)) break;e = a.suspendedLanes;if ((e & c) !== c) {
            Hg();a.pingedLanes |= a.suspendedLanes & e;break;
          }a.timeoutHandle = of(Uj.bind(null, a), d);break;
        }Uj(a);break;case 4:
        Ii(a, c);if ((c & 4186112) === c) break;d = a.eventTimes;for (e = -1; 0 < c;) {
          var g = 31 - Vc(c);f = 1 << g;g = d[g];g > e && (e = g);c &= ~f;
        }c = e;c = O() - c;c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3E3 > c ? 3E3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);break;
        }Uj(a);break;case 5:
        Uj(a);break;default:
        throw Error(y(329));}
  }Mj(a, O());return a.callbackNode === b ? Nj.bind(null, a) : null;
}function Ii(a, b) {
  b &= ~uj;b &= ~Hi;a.suspendedLanes |= b;a.pingedLanes &= ~b;for (a = a.expirationTimes; 0 < b;) {
    var c = 31 - Vc(b),
        d = 1 << c;a[c] = -1;b &= ~d;
  }
}
function Lj(a) {
  if (0 !== (X & 48)) throw Error(y(327));Oj();if (a === U && 0 !== (a.expiredLanes & W)) {
    var b = W;var c = Tj(a, b);0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
  } else b = Uc(a, 0), c = Tj(a, b);0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));if (1 === c) throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;a.finishedWork = a.current.alternate;a.finishedLanes = b;Uj(a);Mj(a, O());return null;
}
function Vj() {
  if (null !== Cj) {
    var a = Cj;Cj = null;a.forEach(function (a) {
      a.expiredLanes |= 24 & a.pendingLanes;Mj(a, O());
    });
  }ig();
}function Wj(a, b) {
  var c = X;X |= 1;try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}function Xj(a, b) {
  var c = X;X &= -2;X |= 8;try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}function ni(a, b) {
  I(rj, qj);qj |= b;tj |= b;
}function Ki() {
  qj = rj.current;H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;a.finishedLanes = 0;var c = a.timeoutHandle;-1 !== c && (a.timeoutHandle = -1, pf(c));if (null !== Y) for (c = Y.return; null !== c;) {
    var d = c;switch (d.tag) {case 1:
        d = d.type.childContextTypes;null !== d && void 0 !== d && Gf();break;case 3:
        fh();H(N);H(M);uh();break;case 5:
        hh(d);break;case 4:
        fh();break;case 13:
        H(P);break;case 19:
        H(P);break;case 10:
        rg(d);break;case 23:case 24:
        Ki();}c = c.return;
  }U = a;Y = Tg(a.current, null);W = qj = tj = b;V = 0;sj = null;uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;try {
      qg();vh.current = Gh;if (yh) {
        for (var d = R.memoizedState; null !== d;) {
          var e = d.queue;null !== e && (e.pending = null);d = d.next;
        }yh = !1;
      }xh = 0;T = S = R = null;zh = !1;pj.current = null;if (null === c || null === c.return) {
        V = 1;sj = b;Y = null;break;
      }a: {
        var f = a,
            g = c.return,
            h = c,
            k = b;b = W;h.flags |= 2048;h.firstEffect = h.lastEffect = null;if (null !== k && "object" === (typeof k === "undefined" ? "undefined" : _typeof(k)) && "function" === typeof k.then) {
          var l = k;if (0 === (h.mode & 2)) {
            var n = h.alternate;n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }var A = 0 !== (P.current & 1),
              p = g;do {
            var C;if (C = 13 === p.tag) {
              var x = p.memoizedState;if (null !== x) C = null !== x.dehydrated ? !0 : !1;else {
                var w = p.memoizedProps;C = void 0 === w.fallback ? !1 : !0 !== w.unstable_avoidThisFallback ? !0 : A ? !1 : !0;
              }
            }if (C) {
              var z = p.updateQueue;if (null === z) {
                var u = new Set();u.add(l);p.updateQueue = u;
              } else z.add(l);if (0 === (p.mode & 2)) {
                p.flags |= 64;h.flags |= 16384;h.flags &= -2981;if (1 === h.tag) if (null === h.alternate) h.tag = 17;else {
                  var t = zg(-1, 1);t.tag = 2;Ag(h, t);
                }h.lanes |= 1;break a;
              }k = void 0;h = b;var q = f.pingCache;null === q ? (q = f.pingCache = new Oi(), k = new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = new Set(), q.set(l, k)));if (!k.has(h)) {
                k.add(h);var v = Yj.bind(null, f, l, h);l.then(v, v);
              }p.flags |= 4096;p.lanes = b;break a;
            }p = p.return;
          } while (null !== p);k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }5 !== V && (V = 2);k = Mi(k, h);p = g;do {
          switch (p.tag) {case 3:
              f = k;p.flags |= 4096;b &= -b;p.lanes |= b;var J = Pi(p, f, b);Bg(p, J);break a;case 1:
              f = k;var K = p.type,
                  Q = p.stateNode;if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                p.flags |= 4096;b &= -b;p.lanes |= b;var L = Si(p, f, b);Bg(p, L);break a;
              }}p = p.return;
        } while (null !== p);
      }Zj(c);
    } catch (va) {
      b = va;Y === c && null !== c && (Y = c = c.return);continue;
    }break;
  } while (1);
}
function Pj() {
  var a = oj.current;oj.current = Gh;return null === a ? Gh : a;
}function Tj(a, b) {
  var c = X;X |= 16;var d = Pj();U === a && W === b || Qj(a, b);do {
    try {
      ak();break;
    } catch (e) {
      Sj(a, e);
    }
  } while (1);qg();X = c;oj.current = d;if (null !== Y) throw Error(y(261));U = null;W = 0;return V;
}function ak() {
  for (; null !== Y;) {
    bk(Y);
  }
}function Rj() {
  for (; null !== Y && !Qf();) {
    bk(Y);
  }
}function bk(a) {
  var b = ck(a.alternate, a, qj);a.memoizedProps = a.pendingProps;null === b ? Zj(a) : Y = b;pj.current = null;
}
function Zj(a) {
  var b = a;do {
    var c = b.alternate;a = b.return;if (0 === (b.flags & 2048)) {
      c = Gi(c, b, qj);if (null !== c) {
        Y = c;return;
      }c = b;if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
        for (var d = 0, e = c.child; null !== e;) {
          d |= e.lanes | e.childLanes, e = e.sibling;
        }c.childLanes = d;
      }null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);if (null !== c) {
        c.flags &= 2047;Y = c;return;
      }null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }b = b.sibling;if (null !== b) {
      Y = b;return;
    }Y = b = a;
  } while (null !== b);0 === V && (V = 5);
}function Uj(a) {
  var b = eg();gg(99, dk.bind(null, a, b));return null;
}
function dk(a, b) {
  do {
    Oj();
  } while (null !== yj);if (0 !== (X & 48)) throw Error(y(327));var c = a.finishedWork;if (null === c) return null;a.finishedWork = null;a.finishedLanes = 0;if (c === a.current) throw Error(y(177));a.callbackNode = null;var d = c.lanes | c.childLanes,
      e = d,
      f = a.pendingLanes & ~e;a.pendingLanes = e;a.suspendedLanes = 0;a.pingedLanes = 0;a.expiredLanes &= e;a.mutableReadLanes &= e;a.entangledLanes &= e;e = a.entanglements;for (var g = a.eventTimes, h = a.expirationTimes; 0 < f;) {
    var k = 31 - Vc(f),
        l = 1 << k;e[k] = 0;g[k] = -1;h[k] = -1;f &= ~l;
  }null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);a === U && (Y = U = null, W = 0);1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;if (null !== d) {
    e = X;X |= 32;pj.current = null;kf = fd;g = Ne();if (Oe(g)) {
      if ("selectionStart" in g) h = { start: g.selectionStart, end: g.selectionEnd };else a: if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
        h = l.anchorNode;f = l.anchorOffset;k = l.focusNode;l = l.focusOffset;try {
          h.nodeType, k.nodeType;
        } catch (va) {
          h = null;
          break a;
        }var n = 0,
            A = -1,
            p = -1,
            C = 0,
            x = 0,
            w = g,
            z = null;b: for (;;) {
          for (var u;;) {
            w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);3 === w.nodeType && (n += w.nodeValue.length);if (null === (u = w.firstChild)) break;z = w;w = u;
          }for (;;) {
            if (w === g) break b;z === h && ++C === f && (A = n);z === k && ++x === l && (p = n);if (null !== (u = w.nextSibling)) break;w = z;z = w.parentNode;
          }w = u;
        }h = -1 === A || -1 === p ? null : { start: A, end: p };
      } else h = null;h = h || { start: 0, end: 0 };
    } else h = null;lf = { focusedElem: g, selectionRange: h };fd = !1;Ij = null;Jj = !1;Z = d;do {
      try {
        ek();
      } catch (va) {
        if (null === Z) throw Error(y(330));Wi(Z, va);Z = Z.nextEffect;
      }
    } while (null !== Z);Ij = null;Z = d;do {
      try {
        for (g = a; null !== Z;) {
          var t = Z.flags;t & 16 && pb(Z.stateNode, "");if (t & 128) {
            var q = Z.alternate;if (null !== q) {
              var v = q.ref;null !== v && ("function" === typeof v ? v(null) : v.current = null);
            }
          }switch (t & 1038) {case 2:
              fj(Z);Z.flags &= -3;break;case 6:
              fj(Z);Z.flags &= -3;ij(Z.alternate, Z);break;case 1024:
              Z.flags &= -1025;break;case 1028:
              Z.flags &= -1025;ij(Z.alternate, Z);break;case 4:
              ij(Z.alternate, Z);break;case 8:
              h = Z;cj(g, h);var J = h.alternate;dj(h);null !== J && dj(J);}Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z) throw Error(y(330));Wi(Z, va);Z = Z.nextEffect;
      }
    } while (null !== Z);v = lf;q = Ne();t = v.focusedElem;g = v.selectionRange;if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
      null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));q = [];for (v = t; v = v.parentNode;) {
        1 === v.nodeType && q.push({ element: v, left: v.scrollLeft, top: v.scrollTop });
      }"function" === typeof t.focus && t.focus();for (t = 0; t < q.length; t++) {
        v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
      }
    }fd = !!kf;lf = kf = null;a.current = c;Z = d;do {
      try {
        for (t = a; null !== Z;) {
          var K = Z.flags;K & 36 && Yi(t, Z.alternate, Z);if (K & 128) {
            q = void 0;var Q = Z.ref;if (null !== Q) {
              var L = Z.stateNode;switch (Z.tag) {case 5:
                  q = L;break;default:
                  q = L;}"function" === typeof Q ? Q(q) : Q.current = q;
            }
          }Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z) throw Error(y(330));Wi(Z, va);Z = Z.nextEffect;
      }
    } while (null !== Z);Z = null;$f();X = e;
  } else a.current = c;if (xj) xj = !1, yj = a, zj = b;else for (Z = d; null !== Z;) {
    b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
  }d = a.pendingLanes;0 === d && (Ti = null);1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;c = c.stateNode;if (Mf && "function" === typeof Mf.onCommitFiberRoot) try {
    Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
  } catch (va) {}Mj(a, O());if (Qi) throw Qi = !1, a = Ri, Ri = null, a;if (0 !== (X & 8)) return null;ig();return null;
}
function ek() {
  for (; null !== Z;) {
    var a = Z.alternate;Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = !0) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = !0));var b = Z.flags;0 !== (b & 256) && Xi(a, Z);0 === (b & 512) || xj || (xj = !0, hg(97, function () {
      Oj();return null;
    }));Z = Z.nextEffect;
  }
}function Oj() {
  if (90 !== zj) {
    var a = 97 < zj ? 97 : zj;zj = 90;return gg(a, fk);
  }return !1;
}function $i(a, b) {
  Aj.push(b, a);xj || (xj = !0, hg(97, function () {
    Oj();return null;
  }));
}function Zi(a, b) {
  Bj.push(b, a);xj || (xj = !0, hg(97, function () {
    Oj();return null;
  }));
}
function fk() {
  if (null === yj) return !1;var a = yj;yj = null;if (0 !== (X & 48)) throw Error(y(331));var b = X;X |= 32;var c = Bj;Bj = [];for (var d = 0; d < c.length; d += 2) {
    var e = c[d],
        f = c[d + 1],
        g = e.destroy;e.destroy = void 0;if ("function" === typeof g) try {
      g();
    } catch (k) {
      if (null === f) throw Error(y(330));Wi(f, k);
    }
  }c = Aj;Aj = [];for (d = 0; d < c.length; d += 2) {
    e = c[d];f = c[d + 1];try {
      var h = e.create;e.destroy = h();
    } catch (k) {
      if (null === f) throw Error(y(330));Wi(f, k);
    }
  }for (h = a.current.firstEffect; null !== h;) {
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  }X = b;ig();return !0;
}function gk(a, b, c) {
  b = Mi(c, b);b = Pi(a, b, 1);Ag(a, b);b = Hg();a = Kj(a, 1);null !== a && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (3 === a.tag) gk(a, a, b);else for (var c = a.return; null !== c;) {
    if (3 === c.tag) {
      gk(c, a, b);break;
    } else if (1 === c.tag) {
      var d = c.stateNode;if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
        a = Mi(b, a);var e = Si(c, a, 1);Ag(c, e);e = Hg();c = Kj(c, 1);if (null !== c) $c(c, 1, e), Mj(c, e);else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) try {
          d.componentDidCatch(b, a);
        } catch (f) {}break;
      }
    }c = c.return;
  }
}
function Yj(a, b, c) {
  var d = a.pingCache;null !== d && d.delete(b);b = Hg();a.pingedLanes |= a.suspendedLanes & c;U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);Mj(a, b);
}function lj(a, b) {
  var c = a.stateNode;null !== c && c.delete(b);b = 0;0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));c = Hg();a = Kj(a, b);null !== a && ($c(a, b, c), Mj(a, c));
}var ck;
ck = function ck(a, b, c) {
  var d = b.lanes;if (null !== a) {
    if (a.memoizedProps !== b.pendingProps || N.current) ug = !0;else if (0 !== (c & d)) ug = 0 !== (a.flags & 16384) ? !0 : !1;else {
      ug = !1;switch (b.tag) {case 3:
          ri(b);sh();break;case 5:
          gh(b);break;case 1:
          Ff(b.type) && Jf(b);break;case 4:
          eh(b, b.stateNode.containerInfo);break;case 10:
          d = b.memoizedProps.value;var e = b.type._context;I(mg, e._currentValue);e._currentValue = d;break;case 13:
          if (null !== b.memoizedState) {
            if (0 !== (c & b.child.childLanes)) return ti(a, b, c);I(P, P.current & 1);b = hi(a, b, c);return null !== b ? b.sibling : null;
          }I(P, P.current & 1);break;case 19:
          d = 0 !== (c & b.childLanes);if (0 !== (a.flags & 64)) {
            if (d) return Ai(a, b, c);b.flags |= 64;
          }e = b.memoizedState;null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);I(P, P.current);if (d) break;else return null;case 23:case 24:
          return b.lanes = 0, mi(a, b, c);}return hi(a, b, c);
    }
  } else ug = !1;b.lanes = 0;switch (b.tag) {case 2:
      d = b.type;null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);a = b.pendingProps;e = Ef(b, M.current);tg(b, c);e = Ch(null, b, d, a, e, c);b.flags |= 1;if ("object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
        b.tag = 1;b.memoizedState = null;b.updateQueue = null;if (Ff(d)) {
          var f = !0;Jf(b);
        } else f = !1;b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;xg(b);var g = d.getDerivedStateFromProps;"function" === typeof g && Gg(b, d, g, a);e.updater = Kg;b.stateNode = e;e._reactInternals = b;Og(b, d, a, c);b = qi(null, b, d, !0, f, c);
      } else b.tag = 0, fi(null, b, e, c), b = b.child;return b;case 16:
      e = b.elementType;a: {
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;f = e._init;e = f(e._payload);b.type = e;f = b.tag = hk(e);a = lg(e, a);switch (f) {case 0:
            b = li(null, b, e, a, c);break a;case 1:
            b = pi(null, b, e, a, c);break a;case 11:
            b = gi(null, b, e, a, c);break a;case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);break a;}throw Error(y(306, e, ""));
      }return b;case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);case 3:
      ri(b);d = b.updateQueue;if (null === a || null === d) throw Error(y(282));
      d = b.pendingProps;e = b.memoizedState;e = null !== e ? e.element : null;yg(a, b);Cg(b, d, null, c);d = b.memoizedState.element;if (d === e) sh(), b = hi(a, b, c);else {
        e = b.stateNode;if (f = e.hydrate) kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = !0;if (f) {
          a = e.mutableSourceEagerHydrationData;if (null != a) for (e = 0; e < a.length; e += 2) {
            f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          }c = Zg(b, null, d, c);for (b.child = c; c;) {
            c.flags = c.flags & -3 | 1024, c = c.sibling;
          }
        } else fi(a, b, d, c), sh();b = b.child;
      }return b;case 5:
      return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;case 6:
      return null === a && ph(b), null;case 13:
      return ti(a, b, c);case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);case 7:
      return fi(a, b, b.pendingProps, c), b.child;case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;case 10:
      a: {
        d = b.type._context;e = b.pendingProps;g = b.memoizedProps;f = e.value;var h = b.type._context;I(mg, h._currentValue);h._currentValue = f;if (null !== g) if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
          if (g.children === e.children && !N.current) {
            b = hi(a, b, c);break a;
          }
        } else for (h = b.child, null !== h && (h.return = b); null !== h;) {
          var k = h.dependencies;if (null !== k) {
            g = h.child;for (var l = k.firstContext; null !== l;) {
              if (l.context === d && 0 !== (l.observedBits & f)) {
                1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));h.lanes |= c;l = h.alternate;null !== l && (l.lanes |= c);sg(h.return, c);k.lanes |= c;break;
              }l = l.next;
            }
          } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;if (null !== g) g.return = h;else for (g = h; null !== g;) {
            if (g === b) {
              g = null;break;
            }h = g.sibling;if (null !== h) {
              h.return = g.return;g = h;break;
            }g = g.return;
          }h = g;
        }fi(a, b, e.children, c);b = b.child;
      }return b;case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;case 14:
      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = !0, Jf(b)) : a = !1, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, !0, a, c);case 19:
      return Ai(a, b, c);case 23:
      return mi(a, b, c);case 24:
      return mi(a, b, c);}throw Error(y(156, b.tag));
};function ik(a, b, c, d) {
  this.tag = a;this.key = c;this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;this.index = 0;this.ref = null;this.pendingProps = b;this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;this.mode = d;this.flags = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.childLanes = this.lanes = 0;this.alternate = null;
}function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}function ji(a) {
  a = a.prototype;return !(!a || !a.isReactComponent);
}
function hk(a) {
  if ("function" === typeof a) return ji(a) ? 1 : 0;if (void 0 !== a && null !== a) {
    a = a.$$typeof;if (a === Aa) return 11;if (a === Da) return 14;
  }return 2;
}
function Tg(a, b) {
  var c = a.alternate;null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);c.childLanes = a.childLanes;c.lanes = a.lanes;c.child = a.child;c.memoizedProps = a.memoizedProps;c.memoizedState = a.memoizedState;c.updateQueue = a.updateQueue;b = a.dependencies;c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;c.index = a.index;c.ref = a.ref;return c;
}
function Vg(a, b, c, d, e, f) {
  var g = 2;d = a;if ("function" === typeof a) ji(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {case ua:
      return Xg(c.children, e, f, b);case Ha:
      g = 8;e |= 16;break;case wa:
      g = 8;e |= 1;break;case xa:
      return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;case Ba:
      return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;case Ca:
      return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;case Ia:
      return vi(c, e, f, b);case Ja:
      return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;default:
      if ("object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a) switch (a.$$typeof) {case ya:
          g = 10;break a;case za:
          g = 9;break a;case Aa:
          g = 11;break a;case Da:
          g = 14;break a;case Ea:
          g = 16;d = null;break a;case Fa:
          g = 22;break a;}throw Error(y(130, null == a ? a : typeof a === "undefined" ? "undefined" : _typeof(a), ""));}b = nh(g, c, b, e);b.elementType = a;b.type = d;b.lanes = f;return b;
}function Xg(a, b, c, d) {
  a = nh(7, a, d, b);a.lanes = c;return a;
}function vi(a, b, c, d) {
  a = nh(23, a, d, b);a.elementType = Ia;a.lanes = c;return a;
}function Ug(a, b, c) {
  a = nh(6, a, null, b);a.lanes = c;return a;
}
function Wg(a, b, c) {
  b = nh(4, null !== a.children ? a.children : [], a.key, b);b.lanes = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}
function jk(a, b, c) {
  this.tag = b;this.containerInfo = a;this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;this.timeoutHandle = -1;this.pendingContext = this.context = null;this.hydrate = c;this.callbackNode = null;this.callbackPriority = 0;this.eventTimes = Zc(0);this.expirationTimes = Zc(-1);this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;this.entanglements = Zc(0);this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current,
      f = Hg(),
      g = Ig(e);a: if (c) {
    c = c._reactInternals;b: {
      if (Zb(c) !== c || 1 !== c.tag) throw Error(y(170));var h = c;do {
        switch (h.tag) {case 3:
            h = h.stateNode.context;break b;case 1:
            if (Ff(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }}h = h.return;
      } while (null !== h);throw Error(y(171));
    }if (1 === c.tag) {
      var k = c.type;if (Ff(k)) {
        c = If(c, k, h);break a;
      }
    }c = h;
  } else c = Cf;null === b.context ? b.context = c : b.pendingContext = c;b = zg(f, g);b.payload = { element: a };d = void 0 === d ? null : d;null !== d && (b.callback = d);Ag(e, b);Jg(e, g, f);return g;
}function mk(a) {
  a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
      return a.child.stateNode;default:
      return a.child.stateNode;}
}function nk(a, b) {
  a = a.memoizedState;if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;a.retryLane = 0 !== c && c < b ? c : b;
  }
}function ok(a, b) {
  nk(a, b);(a = a.alternate) && nk(a, b);
}function pk() {
  return null;
}
function qk(a, b, c) {
  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;c = new jk(a, b, null != c && !0 === c.hydrate);b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);c.current = b;b.stateNode = c;xg(b);a[ff] = c.current;cf(8 === a.nodeType ? a.parentNode : a);if (d) for (a = 0; a < d.length; a++) {
    b = d[a];var e = b._getVersion;e = e(b._source);null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
  }this._internalRoot = c;
}
qk.prototype.render = function (a) {
  lk(a, this._internalRoot, null, null);
};qk.prototype.unmount = function () {
  var a = this._internalRoot,
      b = a.containerInfo;lk(null, a, null, function () {
    b[ff] = null;
  });
};function rk(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function sk(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));if (!b) for (var c; c = a.lastChild;) {
    a.removeChild(c);
  }return new qk(a, 0, b ? { hydrate: !0 } : void 0);
}
function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;if (f) {
    var g = f._internalRoot;if ("function" === typeof e) {
      var h = e;e = function e() {
        var a = mk(g);h.call(a);
      };
    }lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);g = f._internalRoot;if ("function" === typeof e) {
      var k = e;e = function e() {
        var a = mk(g);k.call(a);
      };
    }Xj(function () {
      lk(b, g, a, e);
    });
  }return mk(g);
}ec = function ec(a) {
  if (13 === a.tag) {
    var b = Hg();Jg(a, 4, b);ok(a, 4);
  }
};fc = function fc(a) {
  if (13 === a.tag) {
    var b = Hg();Jg(a, 67108864, b);ok(a, 67108864);
  }
};
gc = function gc(a) {
  if (13 === a.tag) {
    var b = Hg(),
        c = Ig(a);Jg(a, c, b);ok(a, c);
  }
};hc = function hc(a, b) {
  return b();
};
yb = function yb(a, b, c) {
  switch (b) {case "input":
      ab(a, c);b = c.name;if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) {
          c = c.parentNode;
        }c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');for (b = 0; b < c.length; b++) {
          var d = c[b];if (d !== a && d.form === a.form) {
            var e = Db(d);if (!e) throw Error(y(90));Wa(d);ab(d, e);
          }
        }
      }break;case "textarea":
      ib(a, c);break;case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, !1);}
};Gb = Wj;
Hb = function Hb(a, b, c, d, e) {
  var f = X;X |= 4;try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, 0 === X && (wj(), ig());
  }
};Ib = function Ib() {
  0 === (X & 49) && (Vj(), Oj());
};Jb = function Jb(a, b) {
  var c = X;X |= 2;try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
};function uk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;if (!rk(b)) throw Error(y(200));return kk(a, b, null, c);
}var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: !1 }] },
    wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.1", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function findHostInstanceByFiber(a) {
    a = cc(a);return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (!yk.isDisabled && yk.supportsFiber) try {
    Lf = yk.inject(xk), Mf = yk;
  } catch (a) {}
}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;exports.createPortal = uk;
exports.findDOMNode = function (a) {
  if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternals;if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(y(188));throw Error(y(268, Object.keys(a)));
  }a = cc(b);a = null === a ? null : a.stateNode;return a;
};exports.flushSync = function (a, b) {
  var c = X;if (0 !== (c & 48)) return a(b);X |= 1;try {
    if (a) return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};exports.hydrate = function (a, b, c) {
  if (!rk(b)) throw Error(y(200));return tk(null, a, b, !0, c);
};
exports.render = function (a, b, c) {
  if (!rk(b)) throw Error(y(200));return tk(null, a, b, !1, c);
};exports.unmountComponentAtNode = function (a) {
  if (!rk(a)) throw Error(y(40));return a._reactRootContainer ? (Xj(function () {
    tk(null, null, a, !1, function () {
      a._reactRootContainer = null;a[ff] = null;
    });
  }), !0) : !1;
};exports.unstable_batchedUpdates = Wj;exports.unstable_createPortal = function (a, b) {
  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
  if (!rk(c)) throw Error(y(200));if (null == a || void 0 === a._reactInternals) throw Error(y(38));return tk(a, b, c, !1, d);
};exports.version = "17.0.1";

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(1);

    // TODO: this is special because it gets imported during build.
    var ReactVersion = '17.0.1';

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 0xeac7;
    var REACT_PORTAL_TYPE = 0xeaca;
    exports.Fragment = 0xeacb;
    exports.StrictMode = 0xeacc;
    exports.Profiler = 0xead2;
    var REACT_PROVIDER_TYPE = 0xeacd;
    var REACT_CONTEXT_TYPE = 0xeace;
    var REACT_FORWARD_REF_TYPE = 0xead0;
    exports.Suspense = 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = 0xead8;
    var REACT_MEMO_TYPE = 0xead3;
    var REACT_LAZY_TYPE = 0xead4;
    var REACT_BLOCK_TYPE = 0xead9;
    var REACT_SERVER_BLOCK_TYPE = 0xeada;
    var REACT_FUNDAMENTAL_TYPE = 0xead5;
    var REACT_SCOPE_TYPE = 0xead7;
    var REACT_OPAQUE_ID_TYPE = 0xeae0;
    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
    var REACT_OFFSCREEN_TYPE = 0xeae2;
    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

    if (typeof Symbol === 'function' && Symbol.for) {
      var symbolFor = Symbol.for;
      REACT_ELEMENT_TYPE = symbolFor('react.element');
      REACT_PORTAL_TYPE = symbolFor('react.portal');
      exports.Fragment = symbolFor('react.fragment');
      exports.StrictMode = symbolFor('react.strict_mode');
      exports.Profiler = symbolFor('react.profiler');
      REACT_PROVIDER_TYPE = symbolFor('react.provider');
      REACT_CONTEXT_TYPE = symbolFor('react.context');
      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
      exports.Suspense = symbolFor('react.suspense');
      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
      REACT_MEMO_TYPE = symbolFor('react.memo');
      REACT_LAZY_TYPE = symbolFor('react.lazy');
      REACT_BLOCK_TYPE = symbolFor('react.block');
      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
      REACT_SCOPE_TYPE = symbolFor('react.scope');
      REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || (typeof maybeIterable === 'undefined' ? 'undefined' : _typeof(maybeIterable)) !== 'object') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }

    /**
     * Keeps track of the current dispatcher.
     */
    var ReactCurrentDispatcher = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    /**
     * Keeps track of the current batch's configuration such as how long an update
     * should suspend for if it needs to.
     */
    var ReactCurrentBatchConfig = {
      transition: 0
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var ReactDebugCurrentFrame = {};
    var currentExtraStackFrame = null;
    function setExtraStackFrame(stack) {
      {
        currentExtraStackFrame = stack;
      }
    }

    {
      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
        {
          currentExtraStackFrame = stack;
        }
      }; // Stack implementation injected by the current renderer.


      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var stack = ''; // Add an extra top frame while an element is being validated

        if (currentExtraStackFrame) {
          stack += currentExtraStackFrame;
        } // Delegate to the injected renderer-specific implementation


        var impl = ReactDebugCurrentFrame.getCurrentStack;

        if (impl) {
          stack += impl() || '';
        }

        return stack;
      };
    }

    /**
     * Used by act() to track whether you're inside an act() scope.
     */
    var IsSomeRendererActing = {
      current: false
    };

    var ReactSharedInternals = {
      ReactCurrentDispatcher: ReactCurrentDispatcher,
      ReactCurrentBatchConfig: ReactCurrentBatchConfig,
      ReactCurrentOwner: ReactCurrentOwner,
      IsSomeRendererActing: IsSomeRendererActing,
      // Used by renderers to avoid bundling object-assign twice in UMD bundles:
      assign: _assign
    };

    {
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
    }

    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.

    function warn(format) {
      {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        printWarning('warn', format, args);
      }
    }
    function error(format) {
      {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        printWarning('error', format, args);
      }
    }

    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();

        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        }

        var argsWithFormat = args.map(function (item) {
          return '' + item;
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + "." + callerName;

        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }

        error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }
    /**
     * This is the abstract API for an update queue.
     */

    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    var emptyObject = {};

    {
      Object.freeze(emptyObject);
    }
    /**
     * Base class helpers for the updating state of a component.
     */

    function Component(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */

    Component.prototype.setState = function (partialState, callback) {
      if (!((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null)) {
        {
          throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        }
      }

      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */

    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */

    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };

      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

            return undefined;
          }
        });
      };

      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    function ComponentDummy() {}

    ComponentDummy.prototype = Component.prototype;
    /**
     * Convenience component with default shallow equality check for sCU.
     */

    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

    _assign(pureComponentPrototype, Component.prototype);

    pureComponentPrototype.isPureReactComponent = true;

    // an immutable object with a single mutable value
    function createRef() {
      var refObject = {
        current: null
      };

      {
        Object.seal(refObject);
      }

      return refObject;
    }

    function getWrappedName(outerType, innerType, wrapperName) {
      var functionName = innerType.displayName || innerType.name || '';
      return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }

    function getContextName(type) {
      return type.displayName || 'Context';
    }

    function getComponentName(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }

      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }

      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }

      if (typeof type === 'string') {
        return type;
      }

      switch (type) {
        case exports.Fragment:
          return 'Fragment';

        case REACT_PORTAL_TYPE:
          return 'Portal';

        case exports.Profiler:
          return 'Profiler';

        case exports.StrictMode:
          return 'StrictMode';

        case exports.Suspense:
          return 'Suspense';

        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';

          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';

          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');

          case REACT_MEMO_TYPE:
            return getComponentName(type.type);

          case REACT_BLOCK_TYPE:
            return getComponentName(type._render);

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                return getComponentName(init(payload));
              } catch (x) {
                return null;
              }
            }
        }
      }

      return null;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

    {
      didWarnAboutStringRefs = {};
    }

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }

      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }

      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;

            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        }
      };

      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;

            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        }
      };

      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    function warnIfStringRefCannotBeAutoConverted(config) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
          var componentName = getComponentName(ReactCurrentOwner.current.type);

          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */

    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };
    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */

    function createElement(type, config, children) {
      var propName; // Reserved names are extracted

      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;

          {
            warnIfStringRefCannotBeAutoConverted(config);
          }
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }

        props.children = childArray;
      } // Resolve default props


      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;

        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }

          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }

      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    }
    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */

    function cloneElement(element, config, children) {
      if (!!(element === null || element === undefined)) {
        {
          throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
      }

      var propName; // Original props are copied

      var props = _assign({}, element.props); // Reserved names are extracted


      var key = element.key;
      var ref = element.ref; // Self is preserved since the owner is preserved.

      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.

      var source = element._source; // Owner will be preserved, unless ref is overridden

      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        } // Remaining properties override existing props


        var defaultProps;

        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */

    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */

    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = key.replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });
      return '$' + escapedString;
    }
    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return text.replace(userProvidedKeyEscapeRegex, '$&/');
    }
    /**
     * Generate a key string that identifies a element within a set.
     *
     * @param {*} element A element that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */

    function getElementKey(element, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof element === 'undefined' ? 'undefined' : _typeof(element)) === 'object' && element !== null && element.key != null) {
        // Explicit key
        return escape('' + element.key);
      } // Implicit key determined by the index in the set


      return index.toString(36);
    }

    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;

          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }

        }
      }

      if (invokeCallback) {
        var _child = children;
        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows:

        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

        if (Array.isArray(mappedChild)) {
          var escapedChildKey = '';

          if (childKey != null) {
            escapedChildKey = escapeUserProvidedKey(childKey) + '/';
          }

          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
            return c;
          });
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
          }

          array.push(mappedChild);
        }

        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.

      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getElementKey(child, i);
          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var iterableChildren = children;

          {
            // Warn about using Maps as children
            if (iteratorFn === iterableChildren.entries) {
              if (!didWarnAboutMaps) {
                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
              }

              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(iterableChildren);
          var step;
          var ii = 0;

          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getElementKey(child, ii++);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          }
        } else if (type === 'object') {
          var childrenString = '' + children;

          {
            {
              throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
        }
      }

      return subtreeCount;
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
     *
     * The provided mapFunction(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }

      var result = [];
      var count = 0;
      mapIntoArray(children, result, '', '', function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrencount
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */

    function countChildren(children) {
      var n = 0;
      mapChildren(children, function () {
        n++; // Don't return anything
      });
      return n;
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      mapChildren(children, function () {
        forEachFunc.apply(this, arguments); // Don't return anything.
      }, forEachContext);
    }
    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
     */

    function toArray(children) {
      return mapChildren(children, function (child) {
        return child;
      }) || [];
    }
    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */

    function onlyChild(children) {
      if (!isValidElement(children)) {
        {
          throw Error("React.Children.only expected to receive a single React element child.");
        }
      }

      return children;
    }

    function createContext(defaultValue, calculateChangedBits) {
      if (calculateChangedBits === undefined) {
        calculateChangedBits = null;
      } else {
        {
          if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
            error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
          }
        }
      }

      var context = {
        $$typeof: REACT_CONTEXT_TYPE,
        _calculateChangedBits: calculateChangedBits,
        // As a workaround to support multiple concurrent renderers, we categorize
        // some renderers as primary and others as secondary. We only expect
        // there to be two concurrent renderers at most: React Native (primary) and
        // Fabric (secondary); React DOM (primary) and React ART (secondary).
        // Secondary renderers store their context values on separate fields.
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        // Used to track how many concurrent renderers this context currently
        // supports within in a single renderer. Such as parallel server rendering.
        _threadCount: 0,
        // These are circular
        Provider: null,
        Consumer: null
      };
      context.Provider = {
        $$typeof: REACT_PROVIDER_TYPE,
        _context: context
      };
      var hasWarnedAboutUsingNestedContextConsumers = false;
      var hasWarnedAboutUsingConsumerProvider = false;
      var hasWarnedAboutDisplayNameOnConsumer = false;

      {
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
          $$typeof: REACT_CONTEXT_TYPE,
          _context: context,
          _calculateChangedBits: context._calculateChangedBits
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

        Object.defineProperties(Consumer, {
          Provider: {
            get: function get() {
              if (!hasWarnedAboutUsingConsumerProvider) {
                hasWarnedAboutUsingConsumerProvider = true;

                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
              }

              return context.Provider;
            },
            set: function set(_Provider) {
              context.Provider = _Provider;
            }
          },
          _currentValue: {
            get: function get() {
              return context._currentValue;
            },
            set: function set(_currentValue) {
              context._currentValue = _currentValue;
            }
          },
          _currentValue2: {
            get: function get() {
              return context._currentValue2;
            },
            set: function set(_currentValue2) {
              context._currentValue2 = _currentValue2;
            }
          },
          _threadCount: {
            get: function get() {
              return context._threadCount;
            },
            set: function set(_threadCount) {
              context._threadCount = _threadCount;
            }
          },
          Consumer: {
            get: function get() {
              if (!hasWarnedAboutUsingNestedContextConsumers) {
                hasWarnedAboutUsingNestedContextConsumers = true;

                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
              }

              return context.Consumer;
            }
          },
          displayName: {
            get: function get() {
              return context.displayName;
            },
            set: function set(displayName) {
              if (!hasWarnedAboutDisplayNameOnConsumer) {
                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

                hasWarnedAboutDisplayNameOnConsumer = true;
              }
            }
          }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

        context.Consumer = Consumer;
      }

      {
        context._currentRenderer = null;
        context._currentRenderer2 = null;
      }

      return context;
    }

    var Uninitialized = -1;
    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;

    function lazyInitializer(payload) {
      if (payload._status === Uninitialized) {
        var ctor = payload._result;
        var thenable = ctor(); // Transition to the next state.

        var pending = payload;
        pending._status = Pending;
        pending._result = thenable;
        thenable.then(function (moduleObject) {
          if (payload._status === Pending) {
            var defaultExport = moduleObject.default;

            {
              if (defaultExport === undefined) {
                error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
                'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
              }
            } // Transition to the next state.


            var resolved = payload;
            resolved._status = Resolved;
            resolved._result = defaultExport;
          }
        }, function (error) {
          if (payload._status === Pending) {
            // Transition to the next state.
            var rejected = payload;
            rejected._status = Rejected;
            rejected._result = error;
          }
        });
      }

      if (payload._status === Resolved) {
        return payload._result;
      } else {
        throw payload._result;
      }
    }

    function lazy(ctor) {
      var payload = {
        // We use these fields to store the result.
        _status: -1,
        _result: ctor
      };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: payload,
        _init: lazyInitializer
      };

      {
        // In production, this would just set it on the object.
        var defaultProps;
        var propTypes; // $FlowFixMe

        Object.defineProperties(lazyType, {
          defaultProps: {
            configurable: true,
            get: function get() {
              return defaultProps;
            },
            set: function set(newDefaultProps) {
              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

              defaultProps = newDefaultProps; // Match production behavior more closely:
              // $FlowFixMe

              Object.defineProperty(lazyType, 'defaultProps', {
                enumerable: true
              });
            }
          },
          propTypes: {
            configurable: true,
            get: function get() {
              return propTypes;
            },
            set: function set(newPropTypes) {
              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

              propTypes = newPropTypes; // Match production behavior more closely:
              // $FlowFixMe

              Object.defineProperty(lazyType, 'propTypes', {
                enumerable: true
              });
            }
          }
        });
      }

      return lazyType;
    }

    function forwardRef(render) {
      {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
        } else if (typeof render !== 'function') {
          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render === 'undefined' ? 'undefined' : _typeof(render));
        } else {
          if (render.length !== 0 && render.length !== 2) {
            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
          }
        }

        if (render != null) {
          if (render.defaultProps != null || render.propTypes != null) {
            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
          }
        }
      }

      var elementType = {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: render
      };

      {
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
          enumerable: false,
          configurable: true,
          get: function get() {
            return ownName;
          },
          set: function set(name) {
            ownName = name;

            if (render.displayName == null) {
              render.displayName = name;
            }
          }
        });
      }

      return elementType;
    }

    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

    var enableScopeAPI = false; // Experimental Create Event Handle API.

    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


      if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
        return true;
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
          return true;
        }
      }

      return false;
    }

    function memo(type, compare) {
      {
        if (!isValidElementType(type)) {
          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type === 'undefined' ? 'undefined' : _typeof(type));
        }
      }

      var elementType = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: compare === undefined ? null : compare
      };

      {
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
          enumerable: false,
          configurable: true,
          get: function get() {
            return ownName;
          },
          set: function set(name) {
            ownName = name;

            if (type.displayName == null) {
              type.displayName = name;
            }
          }
        });
      }

      return elementType;
    }

    function resolveDispatcher() {
      var dispatcher = ReactCurrentDispatcher.current;

      if (!(dispatcher !== null)) {
        {
          throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
      }

      return dispatcher;
    }

    function useContext(Context, unstable_observedBits) {
      var dispatcher = resolveDispatcher();

      {
        if (unstable_observedBits !== undefined) {
          error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
        } // TODO: add a more generic warning for invalid values.


        if (Context._context !== undefined) {
          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
          // and nobody should be using this in existing code.

          if (realContext.Consumer === Context) {
            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
          } else if (realContext.Provider === Context) {
            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
          }
        }
      }

      return dispatcher.useContext(Context, unstable_observedBits);
    }
    function useState(initialState) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useState(initialState);
    }
    function useReducer(reducer, initialArg, init) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useReducer(reducer, initialArg, init);
    }
    function useRef(initialValue) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useRef(initialValue);
    }
    function useEffect(create, deps) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useEffect(create, deps);
    }
    function useLayoutEffect(create, deps) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useLayoutEffect(create, deps);
    }
    function useCallback(callback, deps) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useCallback(callback, deps);
    }
    function useMemo(create, deps) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useMemo(create, deps);
    }
    function useImperativeHandle(ref, create, deps) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useImperativeHandle(ref, create, deps);
    }
    function useDebugValue(value, formatterFn) {
      {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
      }
    }

    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;

    function disabledLog() {}

    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;

        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: _assign({}, props, {
              value: prevLog
            }),
            info: _assign({}, props, {
              value: prevInfo
            }),
            warn: _assign({}, props, {
              value: prevWarn
            }),
            error: _assign({}, props, {
              value: prevError
            }),
            group: _assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: _assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: _assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }

    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.


        return '\n' + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;

    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }

    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }

      {
        var frame = componentFrameCache.get(fn);

        if (frame !== undefined) {
          return frame;
        }
      }

      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;

      {
        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher$1.current = null;
        disableLogs();
      }

      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function Fake() {
            throw Error();
          }; // $FlowFixMe


          Object.defineProperty(Fake.prototype, 'props', {
            set: function set() {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });

          if ((typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }

            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }

            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }

          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;

          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }

          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.


                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }

              break;
            }
          }
        }
      } finally {
        reentry = false;

        {
          ReactCurrentDispatcher$1.current = previousDispatcher;
          reenableLogs();
        }

        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.


      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }

      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }

    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }

    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

      if (type == null) {
        return '';
      }

      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }

      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }

      switch (type) {
        case exports.Suspense:
          return describeBuiltInComponentFrame('Suspense');

        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);

          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

          case REACT_BLOCK_TYPE:
            return describeFunctionComponentFrame(type._render);

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }

      return '';
    }

    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }

    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);

        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }

              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }

            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);

              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1 === 'undefined' ? 'undefined' : _typeof(error$1));

              setCurrentlyValidatingElement(null);
            }

            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);

              error('Failed %s type: %s', location, error$1.message);

              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }

    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack);
        } else {
          setExtraStackFrame(null);
        }
      }
    }

    var propTypesMisspellWarningShown;

    {
      propTypesMisspellWarningShown = false;
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current.type);

        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }

      return '';
    }

    function getSourceInfoErrorAddendum(source) {
      if (source !== undefined) {
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }

      return '';
    }

    function getSourceInfoErrorAddendumForProps(elementProps) {
      if (elementProps !== null && elementProps !== undefined) {
        return getSourceInfoErrorAddendum(elementProps.__source);
      }

      return '';
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */

    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

        if (parentName) {
          info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
      }

      return info;
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */

    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }

      element._store.validated = true;
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.

      var childOwner = '';

      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
      }

      {
        setCurrentlyValidatingElement$1(element);

        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */

    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }

      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];

          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);

        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;

            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */

    function validatePropTypes(element) {
      {
        var type = element.type;

        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }

        var propTypes;

        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }

        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentName(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentName(type);

          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }

        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */

    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);

            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

            setCurrentlyValidatingElement$1(null);
            break;
          }
        }

        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);

          error('Invalid attribute `ref` supplied to `React.Fragment`.');

          setCurrentlyValidatingElement$1(null);
        }
      }
    }
    function createElementWithValidation(type, props, children) {
      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.

      if (!validType) {
        var info = '';

        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendumForProps(props);

        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        var typeString;

        if (type === null) {
          typeString = 'null';
        } else if (Array.isArray(type)) {
          typeString = 'array';
        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
          typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
          info = ' Did you accidentally export a JSX literal instead of a component?';
        } else {
          typeString = typeof type === 'undefined' ? 'undefined' : _typeof(type);
        }

        {
          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }
      }

      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.

      if (element == null) {
        return element;
      } // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)


      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (type === exports.Fragment) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }
    var didWarnAboutDeprecatedCreateFactory = false;
    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      validatedFactory.type = type;

      {
        if (!didWarnAboutDeprecatedCreateFactory) {
          didWarnAboutDeprecatedCreateFactory = true;

          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
        } // Legacy hook: remove it


        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }
    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    }

    {

      try {
        var frozenObject = Object.freeze({});
        /* eslint-disable no-new */

        new Map([[frozenObject, null]]);
        new Set([frozenObject]);
        /* eslint-enable no-new */
      } catch (e) {}
    }

    var createElement$1 = createElementWithValidation;
    var cloneElement$1 = cloneElementWithValidation;
    var createFactory = createFactoryWithValidation;
    var Children = {
      map: mapChildren,
      forEach: forEachChildren,
      count: countChildren,
      toArray: toArray,
      only: onlyChild
    };

    exports.Children = Children;
    exports.Component = Component;
    exports.PureComponent = PureComponent;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$1;
    exports.createContext = createContext;
    exports.createElement = createElement$1;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useEffect = useEffect;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.version = ReactVersion;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var l = __webpack_require__(1),
    n = 60103,
    p = 60106;exports.Fragment = 60107;exports.StrictMode = 60108;exports.Profiler = 60114;var q = 60109,
    r = 60110,
    t = 60112;exports.Suspense = 60113;var u = 60115,
    v = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;n = w("react.element");p = w("react.portal");exports.Fragment = w("react.fragment");exports.StrictMode = w("react.strict_mode");exports.Profiler = w("react.profiler");q = w("react.provider");r = w("react.context");t = w("react.forward_ref");exports.Suspense = w("react.suspense");u = w("react.memo");v = w("react.lazy");
}var x = "function" === typeof Symbol && Symbol.iterator;
function y(a) {
  if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) return null;a = x && a[x] || a["@@iterator"];return "function" === typeof a ? a : null;
}function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} },
    B = {};function C(a, b, c) {
  this.props = a;this.context = b;this.refs = B;this.updater = c || A;
}C.prototype.isReactComponent = {};C.prototype.setState = function (a, b) {
  if ("object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a) throw Error(z(85));this.updater.enqueueSetState(this, a, b, "setState");
};C.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D() {}D.prototype = C.prototype;function E(a, b, c) {
  this.props = a;this.context = b;this.refs = B;this.updater = c || A;
}var F = E.prototype = new D();F.constructor = E;l(F, C.prototype);F.isPureReactComponent = !0;var G = { current: null },
    H = Object.prototype.hasOwnProperty,
    I = { key: !0, ref: !0, __self: !0, __source: !0 };
function J(a, b, c) {
  var e,
      d = {},
      k = null,
      h = null;if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) {
    H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
  }var g = arguments.length - 2;if (1 === g) d.children = c;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) {
      f[m] = arguments[m + 2];
    }d.children = f;
  }if (a && a.defaultProps) for (e in g = a.defaultProps, g) {
    void 0 === d[e] && (d[e] = g[e]);
  }return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current };
}
function K(a, b) {
  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}function L(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === n;
}function escape(a) {
  var b = { "=": "=0", ":": "=2" };return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}var M = /\/+/g;function N(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function O(a, b, c, e, d) {
  var k = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === k || "boolean" === k) a = null;var h = !1;if (null === a) h = !0;else switch (k) {case "string":case "number":
      h = !0;break;case "object":
      switch (a.$$typeof) {case n:case p:
          h = !0;}}if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function (a) {
    return a;
  })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;h = 0;e = "" === e ? "." : e + ":";if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];var f = e + N(k, g);h += O(k, b, c, f, d);
  } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) {
    k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
  } else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));return h;
}function P(a, b, c) {
  if (null == a) return a;var e = [],
      d = 0;O(a, e, "", "", function (a) {
    return b.call(c, a, d++);
  });return e;
}
function Q(a) {
  if (-1 === a._status) {
    var b = a._result;b = b();a._status = 0;a._result = b;b.then(function (b) {
      0 === a._status && (b = b.default, a._status = 1, a._result = b);
    }, function (b) {
      0 === a._status && (a._status = 2, a._result = b);
    });
  }if (1 === a._status) return a._result;throw a._result;
}var R = { current: null };function S() {
  var a = R.current;if (null === a) throw Error(z(321));return a;
}var T = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G, IsSomeRendererActing: { current: !1 }, assign: l };
exports.Children = { map: P, forEach: function forEach(a, b, c) {
    P(a, function () {
      b.apply(this, arguments);
    }, c);
  }, count: function count(a) {
    var b = 0;P(a, function () {
      b++;
    });return b;
  }, toArray: function toArray(a) {
    return P(a, function (a) {
      return a;
    }) || [];
  }, only: function only(a) {
    if (!L(a)) throw Error(z(143));return a;
  } };exports.Component = C;exports.PureComponent = E;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error(z(267, a));var e = l({}, a.props),
      d = a.key,
      k = a.ref,
      h = a._owner;if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = G.current);void 0 !== b.key && (d = "" + b.key);if (a.type && a.type.defaultProps) var g = a.type.defaultProps;for (f in b) {
      H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
  }var f = arguments.length - 2;if (1 === f) e.children = c;else if (1 < f) {
    g = Array(f);for (var m = 0; m < f; m++) {
      g[m] = arguments[m + 2];
    }e.children = g;
  }return { $$typeof: n, type: a.type,
    key: d, ref: k, props: e, _owner: h };
};exports.createContext = function (a, b) {
  void 0 === b && (b = null);a = { $$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };a.Provider = { $$typeof: q, _context: a };return a.Consumer = a;
};exports.createElement = J;exports.createFactory = function (a) {
  var b = J.bind(null, a);b.type = a;return b;
};exports.createRef = function () {
  return { current: null };
};exports.forwardRef = function (a) {
  return { $$typeof: t, render: a };
};exports.isValidElement = L;
exports.lazy = function (a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};exports.memo = function (a, b) {
  return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
};exports.useCallback = function (a, b) {
  return S().useCallback(a, b);
};exports.useContext = function (a, b) {
  return S().useContext(a, b);
};exports.useDebugValue = function () {};exports.useEffect = function (a, b) {
  return S().useEffect(a, b);
};exports.useImperativeHandle = function (a, b, c) {
  return S().useImperativeHandle(a, b, c);
};
exports.useLayoutEffect = function (a, b) {
  return S().useLayoutEffect(a, b);
};exports.useMemo = function (a, b) {
  return S().useMemo(a, b);
};exports.useReducer = function (a, b, c) {
  return S().useReducer(a, b, c);
};exports.useRef = function (a) {
  return S().useRef(a);
};exports.useState = function (a) {
  return S().useState(a);
};exports.version = "17.0.1";

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v0.20.1
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

    var interactionIDCounter = 0;
    var threadIDCounter = 0; // Set of currently traced interactions.
    // Interactions "stack"–
    // Meaning that newly traced interactions are appended to the previously active set.
    // When an interaction goes out of scope, the previous set (if any) is restored.

    exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

    exports.__subscriberRef = null;

    {
      exports.__interactionsRef = {
        current: new Set()
      };
      exports.__subscriberRef = {
        current: null
      };
    }
    function unstable_clear(callback) {

      var prevInteractions = exports.__interactionsRef.current;
      exports.__interactionsRef.current = new Set();

      try {
        return callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;
      }
    }
    function unstable_getCurrent() {
      {
        return exports.__interactionsRef.current;
      }
    }
    function unstable_getThreadID() {
      return ++threadIDCounter;
    }
    function unstable_trace(name, timestamp, callback) {
      var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

      var interaction = {
        __count: 1,
        id: interactionIDCounter++,
        name: name,
        timestamp: timestamp
      };
      var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
      // To do that, clone the current interactions.
      // The previous set will be restored upon completion.

      var interactions = new Set(prevInteractions);
      interactions.add(interaction);
      exports.__interactionsRef.current = interactions;
      var subscriber = exports.__subscriberRef.current;
      var returnValue;

      try {
        if (subscriber !== null) {
          subscriber.onInteractionTraced(interaction);
        }
      } finally {
        try {
          if (subscriber !== null) {
            subscriber.onWorkStarted(interactions, threadID);
          }
        } finally {
          try {
            returnValue = callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;

            try {
              if (subscriber !== null) {
                subscriber.onWorkStopped(interactions, threadID);
              }
            } finally {
              interaction.__count--; // If no async work was scheduled for this interaction,
              // Notify subscribers that it's completed.

              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
      }

      return returnValue;
    }
    function unstable_wrap(callback) {
      var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

      var wrappedInteractions = exports.__interactionsRef.current;
      var subscriber = exports.__subscriberRef.current;

      if (subscriber !== null) {
        subscriber.onWorkScheduled(wrappedInteractions, threadID);
      } // Update the pending async work count for the current interactions.
      // Update after calling subscribers in case of error.


      wrappedInteractions.forEach(function (interaction) {
        interaction.__count++;
      });
      var hasRun = false;

      function wrapped() {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = wrappedInteractions;
        subscriber = exports.__subscriberRef.current;

        try {
          var returnValue;

          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(wrappedInteractions, threadID);
            }
          } finally {
            try {
              returnValue = callback.apply(undefined, arguments);
            } finally {
              exports.__interactionsRef.current = prevInteractions;

              if (subscriber !== null) {
                subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
          }

          return returnValue;
        } finally {
          if (!hasRun) {
            // We only expect a wrapped function to be executed once,
            // But in the event that it's executed more than once–
            // Only decrement the outstanding interaction counts once.
            hasRun = true; // Update pending async counts for all wrapped interactions.
            // If this was the last scheduled async work for any of them,
            // Mark them as completed.

            wrappedInteractions.forEach(function (interaction) {
              interaction.__count--;

              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        }
      }

      wrapped.cancel = function cancel() {
        subscriber = exports.__subscriberRef.current;

        try {
          if (subscriber !== null) {
            subscriber.onWorkCanceled(wrappedInteractions, threadID);
          }
        } finally {
          // Update pending async counts for all wrapped interactions.
          // If this was the last scheduled async work for any of them,
          // Mark them as completed.
          wrappedInteractions.forEach(function (interaction) {
            interaction.__count--;

            if (subscriber && interaction.__count === 0) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          });
        }
      };

      return wrapped;
    }

    var subscribers = null;

    {
      subscribers = new Set();
    }

    function unstable_subscribe(subscriber) {
      {
        subscribers.add(subscriber);

        if (subscribers.size === 1) {
          exports.__subscriberRef.current = {
            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
            onInteractionTraced: onInteractionTraced,
            onWorkCanceled: onWorkCanceled,
            onWorkScheduled: onWorkScheduled,
            onWorkStarted: onWorkStarted,
            onWorkStopped: onWorkStopped
          };
        }
      }
    }
    function unstable_unsubscribe(subscriber) {
      {
        subscribers.delete(subscriber);

        if (subscribers.size === 0) {
          exports.__subscriberRef.current = null;
        }
      }
    }

    function onInteractionTraced(interaction) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionTraced(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onInteractionScheduledWorkCompleted(interaction) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkScheduled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkScheduled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStarted(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStarted(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStopped(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStopped(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkCanceled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkCanceled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_trace = unstable_trace;
    exports.unstable_unsubscribe = unstable_unsubscribe;
    exports.unstable_wrap = unstable_wrap;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.20.1
 * scheduler-tracing.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b = 0;exports.__interactionsRef = null;exports.__subscriberRef = null;exports.unstable_clear = function (a) {
  return a();
};exports.unstable_getCurrent = function () {
  return null;
};exports.unstable_getThreadID = function () {
  return ++b;
};exports.unstable_subscribe = function () {};exports.unstable_trace = function (a, d, c) {
  return c();
};exports.unstable_unsubscribe = function () {};exports.unstable_wrap = function (a) {
  return a;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v0.20.1
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var enableSchedulerDebugging = false;
    var enableProfiling = true;

    var _requestHostCallback;
    var requestHostTimeout;
    var cancelHostTimeout;
    var requestPaint;
    var hasPerformanceNow = (typeof performance === 'undefined' ? 'undefined' : _typeof(performance)) === 'object' && typeof performance.now === 'function';

    if (hasPerformanceNow) {
      var localPerformance = performance;

      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      var initialTime = localDate.now();

      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    }

    if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
    // implementation using setTimeout.
    typeof window === 'undefined' || // Check if MessageChannel is supported, too.
    typeof MessageChannel !== 'function') {
      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
      // fallback to a naive implementation.
      var _callback = null;
      var _timeoutID = null;

      var _flushCallback = function _flushCallback() {
        if (_callback !== null) {
          try {
            var currentTime = exports.unstable_now();
            var hasRemainingTime = true;

            _callback(hasRemainingTime, currentTime);

            _callback = null;
          } catch (e) {
            setTimeout(_flushCallback, 0);
            throw e;
          }
        }
      };

      _requestHostCallback = function requestHostCallback(cb) {
        if (_callback !== null) {
          // Protect against re-entrancy.
          setTimeout(_requestHostCallback, 0, cb);
        } else {
          _callback = cb;
          setTimeout(_flushCallback, 0);
        }
      };

      requestHostTimeout = function requestHostTimeout(cb, ms) {
        _timeoutID = setTimeout(cb, ms);
      };

      cancelHostTimeout = function cancelHostTimeout() {
        clearTimeout(_timeoutID);
      };

      exports.unstable_shouldYield = function () {
        return false;
      };

      requestPaint = exports.unstable_forceFrameRate = function () {};
    } else {
      // Capture local references to native APIs, in case a polyfill overrides them.
      var _setTimeout = window.setTimeout;
      var _clearTimeout = window.clearTimeout;

      if (typeof console !== 'undefined') {
        // TODO: Scheduler no longer requires these methods to be polyfilled. But
        // maybe we want to continue warning if they don't exist, to preserve the
        // option to rely on it in the future?
        var requestAnimationFrame = window.requestAnimationFrame;
        var cancelAnimationFrame = window.cancelAnimationFrame;

        if (typeof requestAnimationFrame !== 'function') {
          // Using console['error'] to evade Babel and ESLint
          console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
        }

        if (typeof cancelAnimationFrame !== 'function') {
          // Using console['error'] to evade Babel and ESLint
          console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
        }
      }

      var isMessageLoopRunning = false;
      var scheduledHostCallback = null;
      var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
      // thread, like user events. By default, it yields multiple times per frame.
      // It does not attempt to align with frame boundaries, since most tasks don't
      // need to be frame aligned; for those that do, use requestAnimationFrame.

      var yieldInterval = 5;
      var deadline = 0; // TODO: Make this configurable

      {
        // `isInputPending` is not available. Since we have no way of knowing if
        // there's pending input, always yield at the end of the frame.
        exports.unstable_shouldYield = function () {
          return exports.unstable_now() >= deadline;
        }; // Since we yield every frame regardless, `requestPaint` has no effect.


        requestPaint = function requestPaint() {};
      }

      exports.unstable_forceFrameRate = function (fps) {
        if (fps < 0 || fps > 125) {
          // Using console['error'] to evade Babel and ESLint
          console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
          return;
        }

        if (fps > 0) {
          yieldInterval = Math.floor(1000 / fps);
        } else {
          // reset the framerate
          yieldInterval = 5;
        }
      };

      var performWorkUntilDeadline = function performWorkUntilDeadline() {
        if (scheduledHostCallback !== null) {
          var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
          // cycle. This means there's always time remaining at the beginning of
          // the message event.

          deadline = currentTime + yieldInterval;
          var hasTimeRemaining = true;

          try {
            var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

            if (!hasMoreWork) {
              isMessageLoopRunning = false;
              scheduledHostCallback = null;
            } else {
              // If there's more work, schedule the next message event at the end
              // of the preceding one.
              port.postMessage(null);
            }
          } catch (error) {
            // If a scheduler task throws, exit the current browser task so the
            // error can be observed.
            port.postMessage(null);
            throw error;
          }
        } else {
          isMessageLoopRunning = false;
        } // Yielding to the browser will give it a chance to paint, so we can
      };

      var channel = new MessageChannel();
      var port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;

      _requestHostCallback = function _requestHostCallback(callback) {
        scheduledHostCallback = callback;

        if (!isMessageLoopRunning) {
          isMessageLoopRunning = true;
          port.postMessage(null);
        }
      };

      requestHostTimeout = function requestHostTimeout(callback, ms) {
        taskTimeoutID = _setTimeout(function () {
          callback(exports.unstable_now());
        }, ms);
      };

      cancelHostTimeout = function cancelHostTimeout() {
        _clearTimeout(taskTimeoutID);

        taskTimeoutID = -1;
      };
    }

    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      siftUp(heap, node, index);
    }
    function peek(heap) {
      var first = heap[0];
      return first === undefined ? null : first;
    }
    function pop(heap) {
      var first = heap[0];

      if (first !== undefined) {
        var last = heap.pop();

        if (last !== first) {
          heap[0] = last;
          siftDown(heap, last, 0);
        }

        return first;
      } else {
        return null;
      }
    }

    function siftUp(heap, node, i) {
      var index = i;

      while (true) {
        var parentIndex = index - 1 >>> 1;
        var parent = heap[parentIndex];

        if (parent !== undefined && compare(parent, node) > 0) {
          // The parent is larger. Swap positions.
          heap[parentIndex] = node;
          heap[index] = parent;
          index = parentIndex;
        } else {
          // The parent is smaller. Exit.
          return;
        }
      }
    }

    function siftDown(heap, node, i) {
      var index = i;
      var length = heap.length;

      while (index < length) {
        var leftIndex = (index + 1) * 2 - 1;
        var left = heap[leftIndex];
        var rightIndex = leftIndex + 1;
        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

        if (left !== undefined && compare(left, node) < 0) {
          if (right !== undefined && compare(right, left) < 0) {
            heap[index] = right;
            heap[rightIndex] = node;
            index = rightIndex;
          } else {
            heap[index] = left;
            heap[leftIndex] = node;
            index = leftIndex;
          }
        } else if (right !== undefined && compare(right, node) < 0) {
          heap[index] = right;
          heap[rightIndex] = node;
          index = rightIndex;
        } else {
          // Neither child is smaller. Exit.
          return;
        }
      }
    }

    function compare(a, b) {
      // Compare sort index first, then task id.
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }

    // TODO: Use symbols?
    var NoPriority = 0;
    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5;

    var runIdCounter = 0;
    var mainThreadIdCounter = 0;
    var profilingStateSize = 4;
    var sharedProfilingBuffer = // $FlowFixMe Flow doesn't know about SharedArrayBuffer
    typeof SharedArrayBuffer === 'function' ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : // $FlowFixMe Flow doesn't know about ArrayBuffer
    typeof ArrayBuffer === 'function' ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null // Don't crash the init path on IE9
    ;
    var profilingState = sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : []; // We can't read this but it helps save bytes for null checks

    var PRIORITY = 0;
    var CURRENT_TASK_ID = 1;
    var CURRENT_RUN_ID = 2;
    var QUEUE_SIZE = 3;

    {
      profilingState[PRIORITY] = NoPriority; // This is maintained with a counter, because the size of the priority queue
      // array might include canceled tasks.

      profilingState[QUEUE_SIZE] = 0;
      profilingState[CURRENT_TASK_ID] = 0;
    } // Bytes per element is 4


    var INITIAL_EVENT_LOG_SIZE = 131072;
    var MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes

    var eventLogSize = 0;
    var eventLogBuffer = null;
    var eventLog = null;
    var eventLogIndex = 0;
    var TaskStartEvent = 1;
    var TaskCompleteEvent = 2;
    var TaskErrorEvent = 3;
    var TaskCancelEvent = 4;
    var TaskRunEvent = 5;
    var TaskYieldEvent = 6;
    var SchedulerSuspendEvent = 7;
    var SchedulerResumeEvent = 8;

    function logEvent(entries) {
      if (eventLog !== null) {
        var offset = eventLogIndex;
        eventLogIndex += entries.length;

        if (eventLogIndex + 1 > eventLogSize) {
          eventLogSize *= 2;

          if (eventLogSize > MAX_EVENT_LOG_SIZE) {
            // Using console['error'] to evade Babel and ESLint
            console['error']("Scheduler Profiling: Event log exceeded maximum size. Don't " + 'forget to call `stopLoggingProfilingEvents()`.');
            stopLoggingProfilingEvents();
            return;
          }

          var newEventLog = new Int32Array(eventLogSize * 4);
          newEventLog.set(eventLog);
          eventLogBuffer = newEventLog.buffer;
          eventLog = newEventLog;
        }

        eventLog.set(entries, offset);
      }
    }

    function startLoggingProfilingEvents() {
      eventLogSize = INITIAL_EVENT_LOG_SIZE;
      eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
      eventLog = new Int32Array(eventLogBuffer);
      eventLogIndex = 0;
    }
    function stopLoggingProfilingEvents() {
      var buffer = eventLogBuffer;
      eventLogSize = 0;
      eventLogBuffer = null;
      eventLog = null;
      eventLogIndex = 0;
      return buffer;
    }
    function markTaskStart(task, ms) {
      {
        profilingState[QUEUE_SIZE]++;

        if (eventLog !== null) {
          // performance.now returns a float, representing milliseconds. When the
          // event is logged, it's coerced to an int. Convert to microseconds to
          // maintain extra degrees of precision.
          logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);
        }
      }
    }
    function markTaskCompleted(task, ms) {
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = 0;
        profilingState[QUEUE_SIZE]--;

        if (eventLog !== null) {
          logEvent([TaskCompleteEvent, ms * 1000, task.id]);
        }
      }
    }
    function markTaskCanceled(task, ms) {
      {
        profilingState[QUEUE_SIZE]--;

        if (eventLog !== null) {
          logEvent([TaskCancelEvent, ms * 1000, task.id]);
        }
      }
    }
    function markTaskErrored(task, ms) {
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = 0;
        profilingState[QUEUE_SIZE]--;

        if (eventLog !== null) {
          logEvent([TaskErrorEvent, ms * 1000, task.id]);
        }
      }
    }
    function markTaskRun(task, ms) {
      {
        runIdCounter++;
        profilingState[PRIORITY] = task.priorityLevel;
        profilingState[CURRENT_TASK_ID] = task.id;
        profilingState[CURRENT_RUN_ID] = runIdCounter;

        if (eventLog !== null) {
          logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);
        }
      }
    }
    function markTaskYield(task, ms) {
      {
        profilingState[PRIORITY] = NoPriority;
        profilingState[CURRENT_TASK_ID] = 0;
        profilingState[CURRENT_RUN_ID] = 0;

        if (eventLog !== null) {
          logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);
        }
      }
    }
    function markSchedulerSuspended(ms) {
      {
        mainThreadIdCounter++;

        if (eventLog !== null) {
          logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);
        }
      }
    }
    function markSchedulerUnsuspended(ms) {
      {
        if (eventLog !== null) {
          logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);
        }
      }
    }

    /* eslint-disable no-var */
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111

    var maxSigned31BitInt = 1073741823; // Times out immediately

    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

    var taskQueue = [];
    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
    var currentTask = null;
    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;

    function advanceTimers(currentTime) {
      // Check for tasks that are no longer delayed and add them to the queue.
      var timer = peek(timerQueue);

      while (timer !== null) {
        if (timer.callback === null) {
          // Timer was cancelled.
          pop(timerQueue);
        } else if (timer.startTime <= currentTime) {
          // Timer fired. Transfer to the task queue.
          pop(timerQueue);
          timer.sortIndex = timer.expirationTime;
          push(taskQueue, timer);

          {
            markTaskStart(timer, currentTime);
            timer.isQueued = true;
          }
        } else {
          // Remaining timers are pending.
          return;
        }

        timer = peek(timerQueue);
      }
    }

    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);

      if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
          isHostCallbackScheduled = true;
          _requestHostCallback(flushWork);
        } else {
          var firstTimer = peek(timerQueue);

          if (firstTimer !== null) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
        }
      }
    }

    function flushWork(hasTimeRemaining, initialTime) {
      {
        markSchedulerUnsuspended(initialTime);
      } // We'll need a host callback the next time work is scheduled.


      isHostCallbackScheduled = false;

      if (isHostTimeoutScheduled) {
        // We scheduled a timeout but it's no longer needed. Cancel it.
        isHostTimeoutScheduled = false;
        cancelHostTimeout();
      }

      isPerformingWork = true;
      var previousPriorityLevel = currentPriorityLevel;

      try {
        if (enableProfiling) {
          try {
            return workLoop(hasTimeRemaining, initialTime);
          } catch (error) {
            if (currentTask !== null) {
              var currentTime = exports.unstable_now();
              markTaskErrored(currentTask, currentTime);
              currentTask.isQueued = false;
            }

            throw error;
          }
        } else {
          // No catch in prod code path.
          return workLoop(hasTimeRemaining, initialTime);
        }
      } finally {
        currentTask = null;
        currentPriorityLevel = previousPriorityLevel;
        isPerformingWork = false;

        {
          var _currentTime = exports.unstable_now();

          markSchedulerSuspended(_currentTime);
        }
      }
    }

    function workLoop(hasTimeRemaining, initialTime) {
      var currentTime = initialTime;
      advanceTimers(currentTime);
      currentTask = peek(taskQueue);

      while (currentTask !== null && !enableSchedulerDebugging) {
        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
          // This currentTask hasn't expired, and we've reached the deadline.
          break;
        }

        var callback = currentTask.callback;

        if (typeof callback === 'function') {
          currentTask.callback = null;
          currentPriorityLevel = currentTask.priorityLevel;
          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
          markTaskRun(currentTask, currentTime);
          var continuationCallback = callback(didUserCallbackTimeout);
          currentTime = exports.unstable_now();

          if (typeof continuationCallback === 'function') {
            currentTask.callback = continuationCallback;
            markTaskYield(currentTask, currentTime);
          } else {
            {
              markTaskCompleted(currentTask, currentTime);
              currentTask.isQueued = false;
            }

            if (currentTask === peek(taskQueue)) {
              pop(taskQueue);
            }
          }

          advanceTimers(currentTime);
        } else {
          pop(taskQueue);
        }

        currentTask = peek(taskQueue);
      } // Return whether there's additional work


      if (currentTask !== null) {
        return true;
      } else {
        var firstTimer = peek(timerQueue);

        if (firstTimer !== null) {
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }

        return false;
      }
    }

    function unstable_runWithPriority(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
        case LowPriority:
        case IdlePriority:
          break;

        default:
          priorityLevel = NormalPriority;
      }

      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    function unstable_next(eventHandler) {
      var priorityLevel;

      switch (currentPriorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
          // Shift down to normal priority
          priorityLevel = NormalPriority;
          break;

        default:
          // Anything lower than normal priority should remain at the current level.
          priorityLevel = currentPriorityLevel;
          break;
      }

      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    function unstable_wrapCallback(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        // This is a fork of runWithPriority, inlined for performance.
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;

        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    }

    function unstable_scheduleCallback(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      var startTime;

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options !== null) {
        var delay = options.delay;

        if (typeof delay === 'number' && delay > 0) {
          startTime = currentTime + delay;
        } else {
          startTime = currentTime;
        }
      } else {
        startTime = currentTime;
      }

      var timeout;

      switch (priorityLevel) {
        case ImmediatePriority:
          timeout = IMMEDIATE_PRIORITY_TIMEOUT;
          break;

        case UserBlockingPriority:
          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
          break;

        case IdlePriority:
          timeout = IDLE_PRIORITY_TIMEOUT;
          break;

        case LowPriority:
          timeout = LOW_PRIORITY_TIMEOUT;
          break;

        case NormalPriority:
        default:
          timeout = NORMAL_PRIORITY_TIMEOUT;
          break;
      }

      var expirationTime = startTime + timeout;
      var newTask = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: startTime,
        expirationTime: expirationTime,
        sortIndex: -1
      };

      {
        newTask.isQueued = false;
      }

      if (startTime > currentTime) {
        // This is a delayed task.
        newTask.sortIndex = startTime;
        push(timerQueue, newTask);

        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
          // All tasks are delayed, and this is the task with the earliest delay.
          if (isHostTimeoutScheduled) {
            // Cancel an existing timeout.
            cancelHostTimeout();
          } else {
            isHostTimeoutScheduled = true;
          } // Schedule a timeout.


          requestHostTimeout(handleTimeout, startTime - currentTime);
        }
      } else {
        newTask.sortIndex = expirationTime;
        push(taskQueue, newTask);

        {
          markTaskStart(newTask, currentTime);
          newTask.isQueued = true;
        } // Schedule a host callback, if needed. If we're already performing work,
        // wait until the next time we yield.


        if (!isHostCallbackScheduled && !isPerformingWork) {
          isHostCallbackScheduled = true;
          _requestHostCallback(flushWork);
        }
      }

      return newTask;
    }

    function unstable_pauseExecution() {}

    function unstable_continueExecution() {

      if (!isHostCallbackScheduled && !isPerformingWork) {
        isHostCallbackScheduled = true;
        _requestHostCallback(flushWork);
      }
    }

    function unstable_getFirstCallbackNode() {
      return peek(taskQueue);
    }

    function unstable_cancelCallback(task) {
      {
        if (task.isQueued) {
          var currentTime = exports.unstable_now();
          markTaskCanceled(task, currentTime);
          task.isQueued = false;
        }
      } // Null out the callback to indicate the task has been canceled. (Can't
      // remove from the queue because you can't remove arbitrary nodes from an
      // array based heap, only the first one.)


      task.callback = null;
    }

    function unstable_getCurrentPriorityLevel() {
      return currentPriorityLevel;
    }

    var unstable_requestPaint = requestPaint;
    var unstable_Profiling = {
      startLoggingProfilingEvents: startLoggingProfilingEvents,
      stopLoggingProfilingEvents: stopLoggingProfilingEvents,
      sharedProfilingBuffer: sharedProfilingBuffer
    };

    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_Profiling = unstable_Profiling;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_next = unstable_next;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_requestPaint = unstable_requestPaint;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.20.1
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _f, g, h, k;if ("object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now) {
  var l = performance;exports.unstable_now = function () {
    return l.now();
  };
} else {
  var p = Date,
      q = p.now();exports.unstable_now = function () {
    return p.now() - q;
  };
}
if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
  var t = null,
      u = null,
      w = function w() {
    if (null !== t) try {
      var a = exports.unstable_now();t(!0, a);t = null;
    } catch (b) {
      throw setTimeout(w, 0), b;
    }
  };_f = function f(a) {
    null !== t ? setTimeout(_f, 0, a) : (t = a, setTimeout(w, 0));
  };g = function g(a, b) {
    u = setTimeout(a, b);
  };h = function h() {
    clearTimeout(u);
  };exports.unstable_shouldYield = function () {
    return !1;
  };k = exports.unstable_forceFrameRate = function () {};
} else {
  var x = window.setTimeout,
      y = window.clearTimeout;if ("undefined" !== typeof console) {
    var z = window.cancelAnimationFrame;"function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");"function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
  }var A = !1,
      B = null,
      C = -1,
      D = 5,
      E = 0;exports.unstable_shouldYield = function () {
    return exports.unstable_now() >= E;
  };k = function k() {};exports.unstable_forceFrameRate = function (a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1E3 / a) : 5;
  };var F = new MessageChannel(),
      G = F.port2;F.port1.onmessage = function () {
    if (null !== B) {
      var a = exports.unstable_now();E = a + D;try {
        B(!0, a) ? G.postMessage(null) : (A = !1, B = null);
      } catch (b) {
        throw G.postMessage(null), b;
      }
    } else A = !1;
  };_f = function _f(a) {
    B = a;A || (A = !0, G.postMessage(null));
  };g = function g(a, b) {
    C = x(function () {
      a(exports.unstable_now());
    }, b);
  };h = function h() {
    y(C);C = -1;
  };
}function H(a, b) {
  var c = a.length;a.push(b);a: for (;;) {
    var d = c - 1 >>> 1,
        e = a[d];if (void 0 !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}function J(a) {
  a = a[0];return void 0 === a ? null : a;
}
function K(a) {
  var b = a[0];if (void 0 !== b) {
    var c = a.pop();if (c !== b) {
      a[0] = c;a: for (var d = 0, e = a.length; d < e;) {
        var m = 2 * (d + 1) - 1,
            n = a[m],
            v = m + 1,
            r = a[v];if (void 0 !== n && 0 > I(n, c)) void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;else break a;
      }
    }return b;
  }return null;
}function I(a, b) {
  var c = a.sortIndex - b.sortIndex;return 0 !== c ? c : a.id - b.id;
}var L = [],
    M = [],
    N = 1,
    O = null,
    P = 3,
    Q = !1,
    R = !1,
    S = !1;
function T(a) {
  for (var b = J(M); null !== b;) {
    if (null === b.callback) K(M);else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);else break;b = J(M);
  }
}function U(a) {
  S = !1;T(a);if (!R) if (null !== J(L)) R = !0, _f(V);else {
    var b = J(M);null !== b && g(U, b.startTime - a);
  }
}
function V(a, b) {
  R = !1;S && (S = !1, h());Q = !0;var c = P;try {
    T(b);for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield());) {
      var d = O.callback;if ("function" === typeof d) {
        O.callback = null;P = O.priorityLevel;var e = d(O.expirationTime <= b);b = exports.unstable_now();"function" === typeof e ? O.callback = e : O === J(L) && K(L);T(b);
      } else K(L);O = J(L);
    }if (null !== O) var m = !0;else {
      var n = J(M);null !== n && g(U, n.startTime - b);m = !1;
    }return m;
  } finally {
    O = null, P = c, Q = !1;
  }
}var W = k;exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;exports.unstable_LowPriority = 4;exports.unstable_NormalPriority = 3;exports.unstable_Profiling = null;exports.unstable_UserBlockingPriority = 2;exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};exports.unstable_continueExecution = function () {
  R || Q || (R = !0, _f(V));
};exports.unstable_getCurrentPriorityLevel = function () {
  return P;
};exports.unstable_getFirstCallbackNode = function () {
  return J(L);
};
exports.unstable_next = function (a) {
  switch (P) {case 1:case 2:case 3:
      var b = 3;break;default:
      b = P;}var c = P;P = b;try {
    return a();
  } finally {
    P = c;
  }
};exports.unstable_pauseExecution = function () {};exports.unstable_requestPaint = W;exports.unstable_runWithPriority = function (a, b) {
  switch (a) {case 1:case 2:case 3:case 4:case 5:
      break;default:
      a = 3;}var c = P;P = a;try {
    return b();
  } finally {
    P = c;
  }
};
exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();"object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;switch (a) {case 1:
      var e = -1;break;case 2:
      e = 250;break;case 5:
      e = 1073741823;break;case 4:
      e = 1E4;break;default:
      e = 5E3;}e = c + e;a = { id: N++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = !0, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = !0, _f(V)));return a;
};
exports.unstable_wrapCallback = function (a) {
  var b = P;return function () {
    var c = P;P = b;try {
      return a.apply(this, arguments);
    } finally {
      P = c;
    }
  };
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(16);
} else {
  module.exports = __webpack_require__(15);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }return arr2;
}

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert', 'disableTLSCerts'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }return _typeof(obj);
}

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = __webpack_require__(5);
/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(object) {
  if (object) return mixin(object);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(object) {
  for (var key in RequestBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key)) object[key] = RequestBase.prototype[key];
  }

  return object;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function (value) {
  this._responseType = value;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function (options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }

  for (var option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;

        case 'response':
          this._responseTimeout = options.response;
          break;

        case 'upload':
          this._uploadTimeout = options.upload;
          break;

        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
}; //
// NOTE: we do not include ESOCKETTIMEDOUT because that is from `request` package
//       <https://github.com/sindresorhus/got/pull/537>
//
// NOTE: we do not include EADDRINFO because it was removed from libuv in 2014
//       <https://github.com/libuv/libuv/commit/02e1ebd40b807be5af46343ea873331b2ee4e9c1>
//       <https://github.com/request/request/search?q=ESOCKETTIMEDOUT&unscoped_q=ESOCKETTIMEDOUT>
//
//
// TODO: expose these as configurable defaults
//


var ERROR_CODES = new Set(['ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN']);
var STATUS_CODES = new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]); // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)
// const METHODS = new Set(['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE']);

/**
 * Determine if a request should be retried.
 * (Inspired by https://github.com/sindresorhus/got#retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (err_) {
      console.error(err_);
    }
  } // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)

  /*
  if (
    this.req &&
    this.req.method &&
    !METHODS.has(this.req.method.toUpperCase())
  )
    return false;
  */

  if (res && res.status && STATUS_CODES.has(res.status)) return true;

  if (err) {
    if (err.code && ERROR_CODES.has(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code === 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  this.timedoutError = null;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function (resolve, reject) {
  var _this = this;

  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (resolve, reject) {
      self.on('abort', function () {
        if (_this._maxRetries && _this._maxRetries > _this._retries) {
          return;
        }

        if (_this.timedout && _this.timedoutError) {
          reject(_this.timedoutError);
          return;
        }

        var err = new Error('Aborted');
        err.code = 'ABORTED';
        err.status = _this.status;
        err.method = _this.method;
        err.url = _this.url;
        reject(err);
      });
      self.end(function (err, res) {
        if (err) reject(err);else resolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */

RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, value) {
  if (isObject(field)) {
    for (var key in field) {
      if (Object.prototype.hasOwnProperty.call(field, key)) this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = value;
  this.header[field] = value;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */

RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.field = function (name, value) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      if (Object.prototype.hasOwnProperty.call(name, key)) this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(value)) {
    for (var i in value) {
      if (Object.prototype.hasOwnProperty.call(value, i)) this.field(name, value[i]);
    }

    return this;
  } // val should be defined now


  if (value === null || undefined === value) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof value === 'boolean') {
    value = String(value);
  }

  this._getFormData().append(name, value);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */

RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser

  if (this.req) this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;

    default:
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */

RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */
// eslint-disable-next-line complexity


RequestBase.prototype.send = function (data) {
  var isObject_ = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject_ && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObject_ && isObject(this._data)) {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if (type) type = type.toLowerCase().trim();

    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObject_ || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.includes('?') ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArray = this.url.slice(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArray.sort(this._sort);
      } else {
        queryArray.sort();
      }

      this.url = this.url.slice(0, index) + '?' + queryArray.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.warn('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.timedoutError = err;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var utils = __webpack_require__(23);
/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key)) obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (_unused) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type; // basics

  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false; // sugar

  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {
          if (i >= o.length) return { done: true };return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
    }throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }var normalCompletion = true,
      didErr = false,
      err;return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();normalCompletion = step.done;return step;
    }, e: function e(_e2) {
      didErr = true;err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    } };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }return arr2;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */
exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function (val) {
  var obj = {};

  var _iterator = _createForOfIteratorHelper(val.split(/ *; */)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var str = _step.value;
      var parts = str.split(/ *= */);
      var key = parts.shift();

      var _val = parts.shift();

      if (key && _val) obj[key] = _val;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return obj;
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function (val) {
  var obj = {};

  var _iterator2 = _createForOfIteratorHelper(val.split(/ *, */)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var str = _step2.value;
      var parts = str.split(/ *; */);
      var url = parts[0].slice(1, -1);
      var rel = parts[1].split(/ *= */)[1].slice(1, -1);
      obj[rel] = url;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return obj;
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(26);
var parse = __webpack_require__(25);
var formats = __webpack_require__(6);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function interpretNumericEntities(str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function parseArrayValue(val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
                return options.decoder(encodedVal, defaults.decoder, charset, 'value');
            });
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function parseObject(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj; // eslint-disable-line no-param-reassign
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = __webpack_require__(3);
var formats = __webpack_require__(6);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function pushToArray(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'symbol' || typeof v === 'bigint';
};

var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        }).join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? '.' + key : '[' + key + ']');

        pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(2);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(7);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _superagent = __webpack_require__(8);

var _superagent2 = _interopRequireDefault(_superagent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BBSForm = function (_React$Component) {
    _inherits(BBSForm, _React$Component);

    function BBSForm(props) {
        _classCallCheck(this, BBSForm);

        var _this = _possibleConstructorReturn(this, (BBSForm.__proto__ || Object.getPrototypeOf(BBSForm)).call(this, props));

        _this.state = {
            name: '',
            body: ''
        };
        return _this;
    }

    _createClass(BBSForm, [{
        key: 'nameChanged',
        value: function nameChanged(e) {
            this.setState({ name: e.target.value });
        }
    }, {
        key: 'bodyChanged',
        value: function bodyChanged(e) {
            this.setState({ body: e.target.value });
        }
    }, {
        key: 'post',
        value: function post(e) {
            var _this2 = this;

            _superagent2.default.get('/api/write').query({
                name: this.state.name,
                body: this.state.body
            }).end(function (err, data) {
                if (err) {
                    console.error(err);
                }
                _this2.setState({ body: '' });
                if (_this2.props.onPost) {
                    _this2.props.onPost();
                }
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            return _react2.default.createElement(
                'div',
                { style: styles.form },
                '\uC774\uB984:',
                _react2.default.createElement('br', null),
                _react2.default.createElement('input', { type: 'text', value: this.state.name,
                    onChange: function onChange(e) {
                        return _this3.nameChanged(e);
                    } }),
                _react2.default.createElement('br', null),
                '\uBCF8\uBB38:',
                _react2.default.createElement('br', null),
                _react2.default.createElement('input', { type: 'text', value: this.state.body, size: '60',
                    onChange: function onChange(e) {
                        return _this3.bodyChanged(e);
                    } }),
                _react2.default.createElement('br', null),
                _react2.default.createElement(
                    'button',
                    { onClick: function onClick(e) {
                            return _this3.post();
                        } },
                    '\uC804\uC1A1'
                )
            );
        }
    }]);

    return BBSForm;
}(_react2.default.Component);

var BBSApp = function (_React$Component2) {
    _inherits(BBSApp, _React$Component2);

    function BBSApp(props) {
        _classCallCheck(this, BBSApp);

        var _this4 = _possibleConstructorReturn(this, (BBSApp.__proto__ || Object.getPrototypeOf(BBSApp)).call(this, props));

        _this4.state = {
            items: []
        };
        return _this4;
    }

    _createClass(BBSApp, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            this.loadLogs();
        }
    }, {
        key: 'loadLogs',
        value: function loadLogs() {
            var _this5 = this;

            _superagent2.default.get('/api/getItems').end(function (err, data) {
                if (err) {
                    console.error(err);
                    return;
                }
                _this5.setState({ items: data.body.logs });
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this6 = this;

            var itemsHtml = this.state.items.map(function (e) {
                return _react2.default.createElement(
                    'li',
                    { key: e._id },
                    e.name,
                    ' - ',
                    e.body
                );
            });

            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                    'h1',
                    { style: styles.h1 },
                    '\uAC8C\uC2DC\uD310'
                ),
                _react2.default.createElement(BBSForm, { onPost: function onPost(e) {
                        return _this6.loadLogs();
                    } }),
                _react2.default.createElement(
                    'p',
                    { style: styles.right },
                    _react2.default.createElement(
                        'button',
                        { onClick: function onClick(e) {
                                return _this6.loadLogs();
                            } },
                        '\uB2E4\uC2DC \uBD88\uB7EC\uC624\uAE30 '
                    )
                ),
                _react2.default.createElement(
                    'ul',
                    null,
                    itemsHtml
                )
            );
        }
    }]);

    return BBSApp;
}(_react2.default.Component);

var styles = {
    h1: {
        backgroundColor: 'blue',
        color: 'white',
        fontSize: 24,
        padding: 12
    },

    form: {
        padding: 12,
        border: '1px solid silver',
        backgroundColor: '#F0F0F0'
    },
    right: {
        textAlign: 'right'
    }
};

_reactDom2.default.render(_react2.default.createElement(BBSApp, null), document.getElementById('root'));

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTUwN2E3MDE5NTFkYjdlZTdjYjIiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdXBlcmFnZW50L34vcXMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vc2NoZWR1bGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zcmMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vc3VwZXJhZ2VudC9+L3FzL2xpYi9mb3JtYXRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9zcmMvY2xpZW50LmpzIiwid2VicGFjazovLy8uL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL34vc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NjaGVkdWxlci90cmFjaW5nLmpzIiwid2VicGFjazovLy8uLi9zcmMvYWdlbnQtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL3JlcXVlc3QtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL3Jlc3BvbnNlLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3N1cGVyYWdlbnQvfi9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdXBlcmFnZW50L34vcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL34vc3VwZXJhZ2VudC9+L3FzL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibWFwIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwiZm9yRWFjaCIsImxldHRlciIsImtleXMiLCJlcnIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImtleSIsIk5PREVfRU5WIiwicmVxdWlyZSIsImhhcyIsImlzQXJyYXkiLCJoZXhUYWJsZSIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJjb21wYWN0UXVldWUiLCJpdGVtIiwicG9wIiwib2JqIiwicHJvcCIsImNvbXBhY3RlZCIsImoiLCJhcnJheVRvT2JqZWN0Iiwib3B0aW9ucyIsInBsYWluT2JqZWN0cyIsImNyZWF0ZSIsIm1lcmdlIiwiYWxsb3dQcm90b3R5cGVzIiwibWVyZ2VUYXJnZXQiLCJ0YXJnZXRJdGVtIiwicmVkdWNlIiwiYWNjIiwidmFsdWUiLCJhc3NpZ25TaW5nbGVTb3VyY2UiLCJkZWNvZGUiLCJzdHIiLCJkZWNvZGVyIiwiY2hhcnNldCIsInN0cldpdGhvdXRQbHVzIiwicmVwbGFjZSIsInVuZXNjYXBlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlIiwiZGVmYXVsdEVuY29kZXIiLCJzdHJpbmciLCJTeW1ib2wiLCJlc2NhcGUiLCIkMCIsInBhcnNlSW50Iiwic2xpY2UiLCJvdXQiLCJjIiwiY2hhckNvZGVBdCIsImNoYXJBdCIsImNvbXBhY3QiLCJvIiwicmVmcyIsImluZGV4T2YiLCJpc1JlZ0V4cCIsImlzQnVmZmVyIiwiY29uc3RydWN0b3IiLCJjb21iaW5lIiwiYSIsImIiLCJtYXliZU1hcCIsImZuIiwibWFwcGVkIiwicGVyY2VudFR3ZW50aWVzIiwidXRpbCIsIkZvcm1hdCIsIlJGQzE3MzgiLCJSRkMzOTg2IiwiZm9ybWF0dGVycyIsImNoZWNrRENFIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiY29uc29sZSIsImVycm9yIiwicm9vdCIsIkVtaXR0ZXIiLCJzYWZlU3RyaW5naWZ5IiwicXMiLCJSZXF1ZXN0QmFzZSIsImlzT2JqZWN0IiwiUmVzcG9uc2VCYXNlIiwiQWdlbnQiLCJyZXF1ZXN0IiwidHJpbSIsInBhaXJzIiwicHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJwYWlyIiwicG9zIiwiaHRtbCIsImpzb24iLCJ4bWwiLCJ1cmxlbmNvZGVkIiwiZm9ybSIsIkpTT04iLCJwYXJzZSIsImxpbmVzIiwiZmllbGRzIiwibGluZSIsImluZGV4IiwiZmllbGQiLCJzdGF0dXMiLCJwYXJzZUhlYWRlciIsInJlcSIsIlJlc3BvbnNlIiwiaXNKU09OIiwibXNnIiwic2VsZiIsInJlcyIsIm5ld19lcnIiLCJSZXF1ZXN0IiwicGFzcyIsInR5cGUiLCJlbmNvZGVyIiwiYnRvYSIsInNlcmlhbGl6ZSIsImZpbGUiLCJkYXRhIiwieGhyIiwicmVhZHlTdGF0ZSIsImhhbmRsZVByb2dyZXNzIiwiY29udGVudFR5cGUiLCJtZXRob2QiLCJtaXhpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIl9jYWxsYmFja3MiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FsbGJhY2tzIiwiY2IiLCJzcGxpY2UiLCJoYXNMaXN0ZW5lcnMiLCJzdHJpbmdpZnkiLCJkZWZhdWx0Iiwic3RhYmxlIiwiZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSIsInN0YWJsZVN0cmluZ2lmeSIsImFyciIsInJlcGxhY2VyU3RhY2siLCJyZXBsYWNlciIsInNwYWNlciIsImRlY2lyYyIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJwYXJ0IiwiZGVmaW5lUHJvcGVydHkiLCJrIiwic3RhY2siLCJwYXJlbnQiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXQiLCJjb25maWd1cmFibGUiLCJjb21wYXJlRnVuY3Rpb24iLCJ0bXAiLCJkZXRlcm1pbmlzdGljRGVjaXJjIiwidG9KU09OIiwic29ydCIsInYiLCJSZWFjdCIsIl9hc3NpZ24iLCJTY2hlZHVsZXIiLCJ0cmFjaW5nIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIndhcm4iLCJmb3JtYXQiLCJfbGVuIiwiX2tleSIsInByaW50V2FybmluZyIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRTdGFja0FkZGVuZHVtIiwiYXJnc1dpdGhGb3JtYXQiLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJGdW5jdGlvbkNvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50IiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkZyYWdtZW50IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkZvcndhcmRSZWYiLCJQcm9maWxlciIsIlN1c3BlbnNlQ29tcG9uZW50IiwiTWVtb0NvbXBvbmVudCIsIlNpbXBsZU1lbW9Db21wb25lbnQiLCJMYXp5Q29tcG9uZW50IiwiSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IiwiRGVoeWRyYXRlZEZyYWdtZW50IiwiU3VzcGVuc2VMaXN0Q29tcG9uZW50IiwiRnVuZGFtZW50YWxDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIkJsb2NrIiwiT2Zmc2NyZWVuQ29tcG9uZW50IiwiTGVnYWN5SGlkZGVuQ29tcG9uZW50IiwiZW5hYmxlUHJvZmlsZXJUaW1lciIsImVuYWJsZUZ1bmRhbWVudGFsQVBJIiwiZW5hYmxlTmV3UmVjb25jaWxlciIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJhbGxOYXRpdmVFdmVudHMiLCJTZXQiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsInJlZ2lzdGVyVHdvUGhhc2VFdmVudCIsInJlZ2lzdHJhdGlvbk5hbWUiLCJkZXBlbmRlbmNpZXMiLCJyZWdpc3RlckRpcmVjdEV2ZW50IiwibG93ZXJDYXNlZE5hbWUiLCJ0b0xvd2VyQ2FzZSIsIm9uZGJsY2xpY2siLCJhZGQiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJSRVNFUlZFRCIsIlNUUklORyIsIkJPT0xFQU5JU0hfU1RSSU5HIiwiQk9PTEVBTiIsIk9WRVJMT0FERURfQk9PTEVBTiIsIk5VTUVSSUMiLCJQT1NJVElWRV9OVU1FUklDIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsImF0dHJpYnV0ZU5hbWUiLCJ0ZXN0Iiwic2hvdWxkSWdub3JlQXR0cmlidXRlIiwicHJvcGVydHlJbmZvIiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyIsImFjY2VwdHNCb29sZWFucyIsInByZWZpeCIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZSIsImlzTmFOIiwiZ2V0UHJvcGVydHlJbmZvIiwicHJvcGVydGllcyIsIlByb3BlcnR5SW5mb1JlY29yZCIsIm11c3RVc2VQcm9wZXJ0eSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsInNhbml0aXplVVJMIiwicmVtb3ZlRW1wdHlTdHJpbmciLCJwcm9wZXJ0eU5hbWUiLCJyZXNlcnZlZFByb3BzIiwiX3JlZiIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwieGxpbmtIcmVmIiwiaXNKYXZhU2NyaXB0UHJvdG9jb2wiLCJkaWRXYXJuIiwidXJsIiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsIm5vZGUiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJpc09wYXF1ZUh5ZHJhdGluZ09iamVjdCIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJfYXR0cmlidXRlTmFtZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl90eXBlIiwiYXR0cmlidXRlVmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX1NFUlZFUl9CTE9DS19UWVBFIiwiUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9PUEFRVUVfSURfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJmb3IiLCJzeW1ib2xGb3IiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJvd25lckZuIiwieCIsIm1hdGNoIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJGYWtlIiwic2V0IiwiUmVmbGVjdCIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwiY29udHJvbExpbmVzIiwiX2ZyYW1lIiwiZGlzcGxheU5hbWUiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZSIsImN0b3IiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiJCR0eXBlb2YiLCJyZW5kZXIiLCJfcmVuZGVyIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsImRlc2NyaWJlRmliZXIiLCJmaWJlciIsIm93bmVyIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJ0YWciLCJnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QiLCJ3b3JrSW5Qcm9ncmVzcyIsInJldHVybiIsIm1lc3NhZ2UiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJpc1JlbmRlcmluZyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJlc2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwic2V0Q3VycmVudEZpYmVyIiwic2V0SXNSZW5kZXJpbmciLCJyZW5kZXJpbmciLCJnZXRJc1JlbmRlcmluZyIsImdldFRvU3RyaW5nVmFsdWUiLCJoYXNSZWFkT25seVZhbHVlIiwiYnV0dG9uIiwiY2hlY2tib3giLCJpbWFnZSIsImhpZGRlbiIsInJhZGlvIiwicmVzZXQiLCJzdWJtaXQiLCJjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzIiwidGFnTmFtZSIsIm9uQ2hhbmdlIiwib25JbnB1dCIsInJlYWRPbmx5IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiaXNDaGVja2FibGUiLCJlbGVtIiwibm9kZU5hbWUiLCJnZXRUcmFja2VyIiwiX3ZhbHVlVHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwidHJhY2tWYWx1ZU9uTm9kZSIsInZhbHVlRmllbGQiLCJkZXNjcmlwdG9yIiwiY3VycmVudFZhbHVlIiwidHJhY2tlciIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJ0cmFjayIsInVwZGF0ZVZhbHVlSWZDaGFuZ2VkIiwibGFzdFZhbHVlIiwibmV4dFZhbHVlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJlbGVtZW50IiwiaG9zdFByb3BzIiwiZGVmYXVsdENoZWNrZWQiLCJkZWZhdWx0VmFsdWUiLCJfd3JhcHBlclN0YXRlIiwiaW5pdGlhbENoZWNrZWQiLCJpbml0V3JhcHBlclN0YXRlIiwiaW5pdGlhbFZhbHVlIiwiY29udHJvbGxlZCIsInVwZGF0ZUNoZWNrZWQiLCJ1cGRhdGVXcmFwcGVyIiwic2V0RGVmYXVsdFZhbHVlIiwicG9zdE1vdW50V3JhcHBlciIsImlzSHlkcmF0aW5nIiwiaXNCdXR0b24iLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlIiwidXBkYXRlTmFtZWRDb3VzaW5zIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJwYXJlbnROb2RlIiwicXVlcnlTZWxlY3RvckFsbCIsIm90aGVyTm9kZSIsIm90aGVyUHJvcHMiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwib3duZXJEb2N1bWVudCIsImRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIiwiZGlkV2FybkludmFsaWRDaGlsZCIsImZsYXR0ZW5DaGlsZHJlbiIsImNoaWxkcmVuIiwiY29udGVudCIsIkNoaWxkcmVuIiwiY2hpbGQiLCJ2YWxpZGF0ZVByb3BzIiwic2VsZWN0ZWQiLCJwb3N0TW91bnRXcmFwcGVyJDEiLCJnZXRIb3N0UHJvcHMkMSIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwib3duZXJOYW1lIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInByb3BOYW1lIiwibXVsdGlwbGUiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX2kiLCJkZWZhdWx0U2VsZWN0ZWQiLCJfc2VsZWN0ZWRWYWx1ZSIsIl9pMiIsImdldEhvc3RQcm9wcyQyIiwiaW5pdFdyYXBwZXJTdGF0ZSQxIiwid2FzTXVsdGlwbGUiLCJwb3N0TW91bnRXcmFwcGVyJDIiLCJwb3N0VXBkYXRlV3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiZ2V0SG9zdFByb3BzJDMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImluaXRXcmFwcGVyU3RhdGUkMiIsInVwZGF0ZVdyYXBwZXIkMSIsIm5ld1ZhbHVlIiwicG9zdE1vdW50V3JhcHBlciQzIiwidGV4dENvbnRlbnQiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIiLCJIVE1MX05BTUVTUEFDRSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJtYXRobWwiLCJzdmciLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJmdW5jIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsIm5hbWVzcGFjZVVSSSIsImlubmVySFRNTCIsInZhbHVlT2YiLCJzdmdOb2RlIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJDT01NRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsInNldFRleHRDb250ZW50IiwidGV4dCIsImxhc3RDaGlsZCIsIm5vZGVUeXBlIiwibm9kZVZhbHVlIiwic2hvcnRoYW5kVG9Mb25naGFuZCIsImFuaW1hdGlvbiIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJib3JkZXIiLCJib3JkZXJCbG9ja0VuZCIsImJvcmRlckJsb2NrU3RhcnQiLCJib3JkZXJCb3R0b20iLCJib3JkZXJDb2xvciIsImJvcmRlckltYWdlIiwiYm9yZGVySW5saW5lRW5kIiwiYm9yZGVySW5saW5lU3RhcnQiLCJib3JkZXJMZWZ0IiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJTdHlsZSIsImJvcmRlclRvcCIsImJvcmRlcldpZHRoIiwiY29sdW1uUnVsZSIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEZsb3ciLCJmb250IiwiZm9udFZhcmlhbnQiLCJnYXAiLCJncmlkIiwiZ3JpZEFyZWEiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkdhcCIsImdyaWRHYXAiLCJncmlkUm93IiwiZ3JpZFJvd0dhcCIsImdyaWRUZW1wbGF0ZSIsImxpc3RTdHlsZSIsIm1hcmdpbiIsIm1hc2siLCJtYXNrUG9zaXRpb24iLCJvdXRsaW5lIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwicGxhY2VDb250ZW50IiwicGxhY2VJdGVtcyIsInBsYWNlU2VsZiIsInRleHREZWNvcmF0aW9uIiwidGV4dEVtcGhhc2lzIiwidHJhbnNpdGlvbiIsIndvcmRXcmFwIiwiaXNVbml0bGVzc051bWJlciIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsImZvbnRXZWlnaHQiLCJsaW5lQ2xhbXAiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsIm9yZGVyIiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwicHJlZml4S2V5Iiwic3Vic3RyaW5nIiwicHJlZml4ZXMiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaXNDdXN0b21Qcm9wZXJ0eSIsImlzRW1wdHkiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJtc1BhdHRlcm4kMSIsImh5cGhlblBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJjYW1lbGl6ZSIsIl8iLCJjaGFyYWN0ZXIiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImlzVmFsdWVFbXB0eSIsImV4cGFuZFNob3J0aGFuZE1hcCIsImV4cGFuZGVkIiwibG9uZ2hhbmRzIiwidmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2Iiwic3R5bGVVcGRhdGVzIiwibmV4dFN0eWxlcyIsImV4cGFuZGVkVXBkYXRlcyIsImV4cGFuZGVkU3R5bGVzIiwid2FybmVkQWJvdXQiLCJvcmlnaW5hbEtleSIsImNvcnJlY3RPcmlnaW5hbEtleSIsIndhcm5pbmdLZXkiLCJvbWl0dGVkQ2xvc2VUYWdzIiwiYXJlYSIsImJhc2UiLCJiciIsImNvbCIsImVtYmVkIiwiaHIiLCJpbWciLCJpbnB1dCIsImtleWdlbiIsImxpbmsiLCJtZXRhIiwicGFyYW0iLCJ3YnIiLCJ2b2lkRWxlbWVudFRhZ3MiLCJtZW51aXRlbSIsIkhUTUwiLCJhc3NlcnRWYWxpZFByb3BzIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiaXNDdXN0b21Db21wb25lbnQiLCJpcyIsInBvc3NpYmxlU3RhbmRhcmROYW1lcyIsImFjY2VwdCIsImFjY2VwdGNoYXJzZXQiLCJhY2Nlc3NrZXkiLCJhY3Rpb24iLCJhbGxvd2Z1bGxzY3JlZW4iLCJhbHQiLCJhcyIsImFzeW5jIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjYXB0dXJlIiwiY2VsbHBhZGRpbmciLCJjZWxsc3BhY2luZyIsImNoYWxsZW5nZSIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGF0ZXRpbWUiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmb3JtbWV0aG9kIiwiZm9ybWFjdGlvbiIsImZvcm1lbmN0eXBlIiwiZm9ybW5vdmFsaWRhdGUiLCJmb3JtdGFyZ2V0IiwiZnJhbWVib3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlnaCIsImhyZWYiLCJocmVmbGFuZyIsImh0bWxmb3IiLCJodHRwZXF1aXYiLCJpY29uIiwiaWQiLCJpbm5lcmh0bWwiLCJpbnB1dG1vZGUiLCJpbnRlZ3JpdHkiLCJpdGVtaWQiLCJpdGVtcHJvcCIsIml0ZW1yZWYiLCJpdGVtc2NvcGUiLCJpdGVtdHlwZSIsImtleXBhcmFtcyIsImtleXR5cGUiLCJraW5kIiwibGFiZWwiLCJsYW5nIiwibGlzdCIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbndpZHRoIiwibWFyZ2luaGVpZ2h0IiwibWF4IiwibWF4bGVuZ3RoIiwibWVkaWEiLCJtZWRpYWdyb3VwIiwibWluIiwibWlubGVuZ3RoIiwibXV0ZWQiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93c3BhbiIsInNhbmRib3giLCJzY29wZSIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdW1tYXJ5IiwidGFiaW5kZXgiLCJ1c2VtYXAiLCJ3aWR0aCIsIndtb2RlIiwid3JhcCIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3IiLCJjb2xvcmludGVycG9sYXRpb24iLCJjb2xvcmludGVycG9sYXRpb25maWx0ZXJzIiwiY29sb3Jwcm9maWxlIiwiY29sb3JyZW5kZXJpbmciLCJjb250ZW50c2NyaXB0dHlwZSIsImNvbnRlbnRzdHlsZXR5cGUiLCJjdXJzb3IiLCJjeCIsImN5IiwiZCIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbiIsImlubGlzdCIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrY29udGVudHVuaXRzIiwibWFza3VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bW9jdGF2ZXMiLCJvZmZzZXQiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwiciIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRyYW5zZm9ybSIsInR5cGVvZiIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZhbHVlcyIsInZlY3RvcmVmZmVjdCIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInkiLCJ5Y2hhbm5lbHNlbGVjdG9yIiwieiIsInpvb21hbmRwYW4iLCJhcmlhUHJvcGVydGllcyIsIndhcm5lZFByb3BlcnRpZXMiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJoYXNPd25Qcm9wZXJ0eSQxIiwidmFsaWRhdGVQcm9wZXJ0eSIsImFyaWFOYW1lIiwiY29ycmVjdE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJ3YXJuSW52YWxpZEFSSUFQcm9wcyIsImludmFsaWRQcm9wcyIsImlzVmFsaWQiLCJ1bmtub3duUHJvcFN0cmluZyIsInZhbGlkYXRlUHJvcGVydGllcyIsImRpZFdhcm5WYWx1ZU51bGwiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMSIsInZhbGlkYXRlUHJvcGVydHkkMSIsIndhcm5lZFByb3BlcnRpZXMkMSIsIl9oYXNPd25Qcm9wZXJ0eSIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwiZXZlbnRSZWdpc3RyeSIsImlzUmVzZXJ2ZWQiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMiIsIklTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIiwiSVNfTk9OX0RFTEVHQVRFRCIsIklTX0NBUFRVUkVfUEhBU0UiLCJJU19SRVBMQVlFRCIsIlNIT1VMRF9OT1RfUFJPQ0VTU19QT0xZRklMTF9FVkVOVF9QTFVHSU5TIiwiZ2V0RXZlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsInNyY0VsZW1lbnQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsInJlc3RvcmVJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJzdGF0ZU5vZGUiLCJfcHJvcHMiLCJzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24iLCJpbXBsIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsIm5lZWRzU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJxdWV1ZWRUYXJnZXRzIiwiYmF0Y2hlZFVwZGF0ZXNJbXBsIiwiYm9va2tlZXBpbmciLCJkaXNjcmV0ZVVwZGF0ZXNJbXBsIiwiZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsIiwiYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwiLCJpc0luc2lkZUV2ZW50SGFuZGxlciIsImlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMiLCJmaW5pc2hFdmVudEhhbmRsZXIiLCJjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwiYmF0Y2hlZEV2ZW50VXBkYXRlcyIsImRpc2NyZXRlVXBkYXRlcyIsInByZXZJc0luc2lkZUV2ZW50SGFuZGxlciIsImZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQiLCJ0aW1lU3RhbXAiLCJzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uIiwiX2JhdGNoZWRVcGRhdGVzSW1wbCIsIl9kaXNjcmV0ZVVwZGF0ZXNJbXBsIiwiX2ZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCIsIl9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImdldExpc3RlbmVyIiwiaW5zdCIsImxpc3RlbmVyIiwicGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kIiwiZiIsImZ1bmNBcmdzIiwib25FcnJvciIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsImRpZENhbGwiLCJkaWRFcnJvciIsIndpbmRvd0V2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwicmVzdG9yZUFmdGVyRGlzcGF0Y2giLCJldnRUeXBlIiwiY2FsbENhbGxiYWNrIiwiZGlkU2V0RXJyb3IiLCJpc0Nyb3NzT3JpZ2luRXJyb3IiLCJoYW5kbGVXaW5kb3dFcnJvciIsImNvbG5vIiwibGluZW5vIiwiZGVmYXVsdFByZXZlbnRlZCIsIl9zdXBwcmVzc0xvZ2dpbmciLCJpbm5lciIsImluaXRFdmVudCIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSIsImhhc0Vycm9yIiwiY2F1Z2h0RXJyb3IiLCJoYXNSZXRocm93RXJyb3IiLCJyZXRocm93RXJyb3IiLCJyZXBvcnRlciIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJoYXNDYXVnaHRFcnJvciIsIl9yZWFjdEludGVybmFscyIsIk5vRmxhZ3MiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkRpZENhcHR1cmUiLCJSZWYiLCJTbmFwc2hvdCIsIlBhc3NpdmUiLCJQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXYiLCJIeWRyYXRpbmciLCJIeWRyYXRpbmdBbmRVcGRhdGUiLCJMaWZlY3ljbGVFZmZlY3RNYXNrIiwiSG9zdEVmZmVjdE1hc2siLCJJbmNvbXBsZXRlIiwiU2hvdWxkQ2FwdHVyZSIsIkZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UiLCJSZWFjdEN1cnJlbnRPd25lciIsImdldE5lYXJlc3RNb3VudGVkRmliZXIiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyIiwic3VzcGVuc2VTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJkZWh5ZHJhdGVkIiwiZ2V0Q29udGFpbmVyRnJvbUZpYmVyIiwiY29udGFpbmVySW5mbyIsImlzRmliZXJNb3VudGVkIiwiaXNNb3VudGVkIiwiY29tcG9uZW50Iiwib3duZXJGaWJlciIsImluc3RhbmNlIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsIm5leHRQYXJlbnQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZG9lc0ZpYmVyQ29udGFpbiIsInBhcmVudEZpYmVyIiwiY2hpbGRGaWJlciIsInBhcmVudEZpYmVyQWx0ZXJuYXRlIiwiYXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbiIsInNldEF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24iLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsInNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5Iiwic2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkiLCJzZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eSIsImhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQiLCJxdWV1ZWREaXNjcmV0ZUV2ZW50cyIsInF1ZXVlZEZvY3VzIiwicXVldWVkRHJhZyIsInF1ZXVlZE1vdXNlIiwicXVldWVkUG9pbnRlcnMiLCJxdWV1ZWRQb2ludGVyQ2FwdHVyZXMiLCJxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMiLCJoYXNRdWV1ZWREaXNjcmV0ZUV2ZW50cyIsImRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyIsImlzUmVwbGF5YWJsZURpc2NyZXRlRXZlbnQiLCJldmVudFR5cGUiLCJjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQiLCJibG9ja2VkT24iLCJkb21FdmVudE5hbWUiLCJldmVudFN5c3RlbUZsYWdzIiwidGFyZ2V0Q29udGFpbmVyIiwidGFyZ2V0Q29udGFpbmVycyIsInF1ZXVlRGlzY3JldGVFdmVudCIsInF1ZXVlZEV2ZW50IiwiY2xlYXJJZkNvbnRpbnVvdXNFdmVudCIsInBvaW50ZXJJZCIsImRlbGV0ZSIsIl9wb2ludGVySWQiLCJhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50IiwiZXhpc3RpbmdRdWV1ZWRFdmVudCIsIl9maWJlcjIiLCJxdWV1ZUlmQ29udGludW91c0V2ZW50IiwiZm9jdXNFdmVudCIsImRyYWdFdmVudCIsIm1vdXNlRXZlbnQiLCJwb2ludGVyRXZlbnQiLCJfcG9pbnRlckV2ZW50IiwiX3BvaW50ZXJJZDIiLCJhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQiLCJxdWV1ZWRUYXJnZXQiLCJ0YXJnZXRJbnN0IiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJsYW5lUHJpb3JpdHkiLCJ1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkiLCJwcmlvcml0eSIsImh5ZHJhdGUiLCJhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50IiwibmV4dEJsb2NrZWRPbiIsImF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQiLCJfZmliZXIzIiwic2hpZnQiLCJhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAiLCJyZXBsYXlVbmJsb2NrZWRFdmVudHMiLCJuZXh0RGlzY3JldGVFdmVudCIsIl9maWJlcjQiLCJzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQiLCJ1bmJsb2NrZWQiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJyZXRyeUlmQmxvY2tlZE9uIiwidW5ibG9jayIsIm5leHRFeHBsaWNpdFRhcmdldCIsIkRpc2NyZXRlRXZlbnQiLCJVc2VyQmxvY2tpbmdFdmVudCIsIkNvbnRpbnVvdXNFdmVudCIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJldmVudE5hbWUiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwiQU5JTUFUSU9OX0VORCIsIkFOSU1BVElPTl9JVEVSQVRJT04iLCJBTklNQVRJT05fU1RBUlQiLCJUUkFOU0lUSU9OX0VORCIsInRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzIiwiZXZlbnRQcmlvcml0aWVzIiwiZGlzY3JldGVFdmVudFBhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4iLCJvdGhlckRpc2NyZXRlRXZlbnRzIiwidXNlckJsb2NraW5nUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiIsImNvbnRpbnVvdXNQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luIiwicmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMiLCJldmVudFR5cGVzIiwidG9wRXZlbnQiLCJjYXBpdGFsaXplZEV2ZW50IiwicmVhY3ROYW1lIiwic2V0RXZlbnRQcmlvcml0aWVzIiwiZ2V0RXZlbnRQcmlvcml0eUZvclBsdWdpblN5c3RlbSIsInJlZ2lzdGVyU2ltcGxlRXZlbnRzIiwiU2NoZWR1bGVyX25vdyIsInVuc3RhYmxlX25vdyIsIl9faW50ZXJhY3Rpb25zUmVmIiwiSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5IiwiTG93UHJpb3JpdHkiLCJJZGxlUHJpb3JpdHkiLCJOb1ByaW9yaXR5IiwiaW5pdGlhbFRpbWVNcyIsIlN5bmNMYW5lUHJpb3JpdHkiLCJTeW5jQmF0Y2hlZExhbmVQcmlvcml0eSIsIklucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHkiLCJJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5IiwiSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5IiwiSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5IiwiRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eSIsIkRlZmF1bHRMYW5lUHJpb3JpdHkiLCJUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHkiLCJUcmFuc2l0aW9uUHJpb3JpdHkiLCJSZXRyeUxhbmVQcmlvcml0eSIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eSIsIklkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHkiLCJJZGxlTGFuZVByaW9yaXR5IiwiT2Zmc2NyZWVuTGFuZVByaW9yaXR5IiwiTm9MYW5lUHJpb3JpdHkiLCJUb3RhbExhbmVzIiwiTm9MYW5lcyIsIk5vTGFuZSIsIlN5bmNMYW5lIiwiU3luY0JhdGNoZWRMYW5lIiwiSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmUiLCJJbnB1dERpc2NyZXRlTGFuZXMiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZXMiLCJEZWZhdWx0SHlkcmF0aW9uTGFuZSIsIkRlZmF1bHRMYW5lcyIsIlRyYW5zaXRpb25IeWRyYXRpb25MYW5lIiwiVHJhbnNpdGlvbkxhbmVzIiwiUmV0cnlMYW5lcyIsIlNvbWVSZXRyeUxhbmUiLCJTZWxlY3RpdmVIeWRyYXRpb25MYW5lIiwiTm9uSWRsZUxhbmVzIiwiSWRsZUh5ZHJhdGlvbkxhbmUiLCJJZGxlTGFuZXMiLCJPZmZzY3JlZW5MYW5lIiwiTm9UaW1lc3RhbXAiLCJzZXRDdXJyZW50VXBkYXRlTGFuZVByaW9yaXR5IiwibmV3TGFuZVByaW9yaXR5IiwicmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImxhbmVzIiwiaW5wdXREaXNjcmV0ZUxhbmVzIiwiaW5wdXRDb250aW51b3VzTGFuZXMiLCJkZWZhdWx0TGFuZXMiLCJ0cmFuc2l0aW9uTGFuZXMiLCJyZXRyeUxhbmVzIiwiaWRsZUxhbmVzIiwic2NoZWR1bGVyUHJpb3JpdHlUb0xhbmVQcmlvcml0eSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJsYW5lUHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5IiwiZ2V0TmV4dExhbmVzIiwid2lwTGFuZXMiLCJwZW5kaW5nTGFuZXMiLCJuZXh0TGFuZXMiLCJuZXh0TGFuZVByaW9yaXR5IiwiZXhwaXJlZExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJub25JZGxlVW5ibG9ja2VkTGFuZXMiLCJub25JZGxlUGluZ2VkTGFuZXMiLCJ1bmJsb2NrZWRMYW5lcyIsImdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzIiwid2lwTGFuZVByaW9yaXR5IiwiZW50YW5nbGVkTGFuZXMiLCJlbnRhbmdsZW1lbnRzIiwicGlja0FyYml0cmFyeUxhbmVJbmRleCIsImxhbmUiLCJnZXRNb3N0UmVjZW50RXZlbnRUaW1lIiwiZXZlbnRUaW1lcyIsIm1vc3RSZWNlbnRFdmVudFRpbWUiLCJldmVudFRpbWUiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsIm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQiLCJleHBpcmF0aW9uVGltZXMiLCJleHBpcmF0aW9uVGltZSIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsInJldHVybk5leHRMYW5lc1ByaW9yaXR5IiwiaW5jbHVkZXNOb25JZGxlV29yayIsImluY2x1ZGVzT25seVJldHJpZXMiLCJpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyIsImZpbmRVcGRhdGVMYW5lIiwiX2xhbmUiLCJwaWNrQXJiaXRyYXJ5TGFuZSIsIl9sYW5lMiIsIl9sYW5lMyIsImZpbmRUcmFuc2l0aW9uTGFuZSIsImZpbmRSZXRyeUxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TG93ZXN0UHJpb3JpdHlMYW5lIiwiY2x6MzIiLCJsYW5lVG9JbmRleCIsImluY2x1ZGVzU29tZUxhbmUiLCJpc1N1YnNldE9mTGFuZXMiLCJzdWJzZXQiLCJtZXJnZUxhbmVzIiwicmVtb3ZlTGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCIsInVwZGF0ZUxhbmUiLCJoaWdoZXJQcmlvcml0eUxhbmVzIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFBpbmdlZCIsIm1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkIiwiaGFzRGlzY3JldGVMYW5lcyIsIm1hcmtSb290TXV0YWJsZVJlYWQiLCJtdXRhYmxlUmVhZExhbmVzIiwibWFya1Jvb3RGaW5pc2hlZCIsInJlbWFpbmluZ0xhbmVzIiwibm9Mb25nZXJQZW5kaW5nTGFuZXMiLCJtYXJrUm9vdEVudGFuZ2xlZCIsIk1hdGgiLCJjbHozMkZhbGxiYWNrIiwiTE4yIiwiVXNlckJsb2NraW5nUHJpb3JpdHkkMSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwicnVuV2l0aFByaW9yaXR5IiwiX2VuYWJsZWQiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5IiwiZXZlbnRQcmlvcml0eSIsImxpc3RlbmVyV3JhcHBlciIsImRpc3BhdGNoRGlzY3JldGVFdmVudCIsImRpc3BhdGNoVXNlckJsb2NraW5nVXBkYXRlIiwiYmluZCIsImNvbnRhaW5lciIsImFsbG93UmVwbGF5IiwiZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyIiwiYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIiLCJhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyIsInBhc3NpdmUiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnIiwic3RhcnRUZXh0IiwiZmFsbGJhY2tUZXh0IiwiaW5pdGlhbGl6ZSIsImdldFRleHQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUiLCJmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UiLCJjcmVhdGVTeW50aGV0aWNFdmVudCIsIkludGVyZmFjZSIsIlN5bnRoZXRpY0Jhc2VFdmVudCIsInJlYWN0RXZlbnRUeXBlIiwiX3JlYWN0TmFtZSIsIl90YXJnZXRJbnN0IiwiY3VycmVudFRhcmdldCIsIl9wcm9wTmFtZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJpc1BlcnNpc3RlbnQiLCJFdmVudEludGVyZmFjZSIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsIkRhdGUiLCJub3ciLCJpc1RydXN0ZWQiLCJTeW50aGV0aWNFdmVudCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwiZGV0YWlsIiwiU3ludGhldGljVUlFdmVudCIsImxhc3RNb3ZlbWVudFgiLCJsYXN0TW92ZW1lbnRZIiwibGFzdE1vdXNlRXZlbnQiLCJ1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiTW91c2VFdmVudEludGVyZmFjZSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsImxvY2F0aW9uIiwicmVwZWF0IiwibG9jYWxlIiwid2hpY2giLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiUG9pbnRlckV2ZW50SW50ZXJmYWNlIiwicHJlc3N1cmUiLCJ0YW5nZW50aWFsUHJlc3N1cmUiLCJ0aWx0WCIsInRpbHRZIiwidHdpc3QiLCJwb2ludGVyVHlwZSIsImlzUHJpbWFyeSIsIlN5bnRoZXRpY1BvaW50ZXJFdmVudCIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImRvY3VtZW50TW9kZSIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsInJlZ2lzdGVyRXZlbnRzIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJpc1VzaW5nS29yZWFuSU1FIiwiaXNDb21wb3NpbmciLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImRpc3BhdGNoUXVldWUiLCJmYWxsYmFja0RhdGEiLCJhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiY2hhciIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwiZXh0cmFjdEV2ZW50cyIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJkYXRlIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInBhc3N3b3JkIiwicmFuZ2UiLCJzZWFyY2giLCJ0ZWwiLCJ0aW1lIiwid2VlayIsImlzVGV4dElucHV0RWxlbWVudCIsImlzRXZlbnRTdXBwb3J0ZWQiLCJldmVudE5hbWVTdWZmaXgiLCJpc1N1cHBvcnRlZCIsInJlZ2lzdGVyRXZlbnRzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInByb2Nlc3NEaXNwYXRjaFF1ZXVlIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJhdHRhY2hFdmVudCIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJkZXRhY2hFdmVudCIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJzaG91bGRVc2VDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50IiwiaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1ciIsInN0YXRlIiwiZXh0cmFjdEV2ZW50cyQxIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJyZWdpc3RlckV2ZW50cyQyIiwiZXh0cmFjdEV2ZW50cyQyIiwiaXNPdmVyRXZlbnQiLCJpc091dEV2ZW50IiwicmVsYXRlZCIsImlzQ29udGFpbmVyTWFya2VkQXNSb290Iiwid2luIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJfcmVsYXRlZCIsIlN5bnRoZXRpY0V2ZW50Q3RvciIsImxlYXZlRXZlbnRUeXBlIiwiZW50ZXJFdmVudFR5cGUiLCJldmVudFR5cGVQcmVmaXgiLCJmcm9tTm9kZSIsInRvTm9kZSIsImxlYXZlIiwiZW50ZXIiLCJuYXRpdmVUYXJnZXRJbnN0IiwiZW50ZXJFdmVudCIsImFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMiLCJvYmplY3RJcyIsImhhc093blByb3BlcnR5JDIiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwibmV4dFNpYmxpbmciLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Iiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsImdldE9mZnNldHMiLCJvdXRlck5vZGUiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsIm5leHQiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImlzVGV4dE5vZGUiLCJjb250YWluc05vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNJbkRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaXNTYW1lT3JpZ2luRnJhbWUiLCJpZnJhbWUiLCJjb250ZW50V2luZG93IiwiZ2V0QWN0aXZlRWxlbWVudERlZXAiLCJIVE1MSUZyYW1lRWxlbWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImFuY2VzdG9ycyIsImFuY2VzdG9yIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJmb2N1cyIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwicmVnaXN0ZXJFdmVudHMkMyIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiZ2V0U2VsZWN0aW9uJDEiLCJnZXRFdmVudFRhcmdldERvY3VtZW50IiwiZXZlbnRUYXJnZXQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJleHRyYWN0RXZlbnRzJDMiLCJleHRyYWN0RXZlbnRzJDQiLCJpbkNhcHR1cmVQaGFzZSIsImFjY3VtdWxhdGVUYXJnZXRPbmx5IiwiX2xpc3RlbmVycyIsImFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyIsIl9ldmVudCIsImV4dHJhY3RFdmVudHMkNSIsInNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMiLCJtZWRpYUV2ZW50VHlwZXMiLCJub25EZWxlZ2F0ZWRFdmVudHMiLCJleGVjdXRlRGlzcGF0Y2giLCJwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlciIsImRpc3BhdGNoTGlzdGVuZXJzIiwicHJldmlvdXNJbnN0YW5jZSIsIl9kaXNwYXRjaExpc3RlbmVycyRpIiwiX2Rpc3BhdGNoTGlzdGVuZXJzJF9pIiwiX2luc3RhbmNlIiwiX2N1cnJlbnRUYXJnZXQiLCJfbGlzdGVuZXIiLCJfZGlzcGF0Y2hRdWV1ZSRpIiwiZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zIiwibGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCIsInRhcmdldEVsZW1lbnQiLCJpc0NhcHR1cmVQaGFzZUxpc3RlbmVyIiwibGlzdGVuZXJTZXQiLCJnZXRFdmVudExpc3RlbmVyU2V0IiwibGlzdGVuZXJTZXRLZXkiLCJnZXRMaXN0ZW5lclNldEtleSIsImFkZFRyYXBwZWRFdmVudExpc3RlbmVyIiwibGlzdGVuaW5nTWFya2VyIiwicmFuZG9tIiwibGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMiLCJyb290Q29udGFpbmVyRWxlbWVudCIsImxpc3RlblRvTmF0aXZlRXZlbnQiLCJpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQiLCJpc1Bhc3NpdmVMaXN0ZW5lciIsInVuc3Vic2NyaWJlTGlzdGVuZXIiLCJpc01hdGNoaW5nUm9vdENvbnRhaW5lciIsImdyYW5kQ29udGFpbmVyIiwiYW5jZXN0b3JJbnN0IiwidGFyZ2V0Q29udGFpbmVyTm9kZSIsIm1haW5Mb29wIiwibm9kZVRhZyIsImdyYW5kTm9kZSIsImdyYW5kVGFnIiwicGFyZW50VGFnIiwiY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lciIsInRhcmdldEZpYmVyIiwibmF0aXZlRXZlbnRUeXBlIiwiY2FwdHVyZU5hbWUiLCJyZWFjdEV2ZW50TmFtZSIsImxhc3RIb3N0Q29tcG9uZW50IiwiX2luc3RhbmNlMiIsIl9pbnN0YW5jZTMiLCJjYXB0dXJlTGlzdGVuZXIiLCJidWJibGVMaXN0ZW5lciIsImdldFBhcmVudCIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaW5zdEEiLCJpbnN0QiIsIm5vZGVBIiwibm9kZUIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50IiwiY29tbW9uIiwiX2luc3RhbmNlNCIsImxlYXZlRXZlbnQiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkciLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFIiwiSFRNTCQxIiwiSFRNTF9OQU1FU1BBQ0UkMSIsIndhcm5lZFVua25vd25UYWdzIiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwidmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCIsIndhcm5Gb3JUZXh0RGlmZmVyZW5jZSIsIndhcm5Gb3JQcm9wRGlmZmVyZW5jZSIsIndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMiLCJ3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIiLCJjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwibm9ybWFsaXplSFRNTCIsImRpYWxvZyIsIndlYnZpZXciLCJOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgiLCJOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgiLCJtYXJrdXAiLCJtYXJrdXBTdHJpbmciLCJzZXJ2ZXJUZXh0IiwiY2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRDbGllbnRUZXh0Iiwibm9ybWFsaXplZFNlcnZlclRleHQiLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZENsaWVudFZhbHVlIiwibm9ybWFsaXplZFNlcnZlclZhbHVlIiwiYXR0cmlidXRlTmFtZXMiLCJuYW1lcyIsInRlc3RFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyIiwidHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQiLCJvbmNsaWNrIiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwibmV4dFByb3BzIiwicHJvcEtleSIsIm5leHRQcm9wIiwiZnJlZXplIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ1cGRhdGVQYXlsb2FkIiwid2FzQ3VzdG9tQ29tcG9uZW50VGFnIiwiZGl2IiwiY3JlYXRlVGV4dE5vZGUiLCJzZXRJbml0aWFsUHJvcGVydGllcyIsInJhd1Byb3BzIiwib25DbGljayIsImRpZmZQcm9wZXJ0aWVzIiwibGFzdFJhd1Byb3BzIiwibmV4dFJhd1Byb3BzIiwibGFzdFByb3BzIiwibGFzdFN0eWxlIiwibGFzdFByb3AiLCJsYXN0SHRtbCIsInVwZGF0ZVByb3BlcnRpZXMiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwiaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nIiwib3duTmFtZXNwYWNlIiwiZGlmZkh5ZHJhdGVkVGV4dCIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0IiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwidmFsaWRhdGVET01OZXN0aW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiQxIiwiY2hpbGRUYWciLCJjaGlsZFRleHQiLCJwYXJlbnRJbmZvIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsImludmFsaWRQYXJlbnRPckFuY2VzdG9yIiwiYW5jZXN0b3JUYWciLCJ3YXJuS2V5IiwidGFnRGlzcGxheU5hbWUiLCJ3aGl0ZXNwYWNlSW5mbyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJTVVNQRU5TRV9TVEFSVF9EQVRBIiwiU1VTUEVOU0VfRU5EX0RBVEEiLCJTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEiLCJTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIiwiU1RZTEUkMSIsImV2ZW50c0VuYWJsZWQiLCJzZWxlY3Rpb25JbmZvcm1hdGlvbiIsInNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQiLCJhdXRvRm9jdXMiLCJnZXRSb290SG9zdENvbnRleHQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJuYW1lc3BhY2UiLCJ2YWxpZGF0ZWRUYWciLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dERldiIsImdldFB1YmxpY0luc3RhbmNlIiwicHJlcGFyZUZvckNvbW1pdCIsImFjdGl2ZUluc3RhbmNlIiwicmVzZXRBZnRlckNvbW1pdCIsImNyZWF0ZUluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJwcmVjYWNoZUZpYmVyTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIl9faHRtbCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJub1RpbWVvdXQiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwidGV4dEluc3RhbmNlIiwib2xkVGV4dCIsIm5ld1RleHQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwicmVhY3RSb290Q29udGFpbmVyIiwiX3JlYWN0Um9vdENvbnRhaW5lciIsImJlZm9yZUNoaWxkIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJnZXROZXh0SHlkcmF0YWJsZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UiLCJzdXNwZW5zZUluc3RhbmNlIiwiZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSIsInRhcmdldEluc3RhbmNlIiwicHJldmlvdXNTaWJsaW5nIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwicGFyZW50Q29udGFpbmVyIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsInBhcmVudFR5cGUiLCJwYXJlbnRQcm9wcyIsImRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSIsImNsaWVudElkIiwibWFrZUNsaWVudElkSW5ERVYiLCJ3YXJuT25BY2Nlc3NJbkRFViIsIm1ha2VPcGFxdWVIeWRyYXRpbmdPYmplY3QiLCJhdHRlbXB0VG9SZWFkVmFsdWUiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJwb3J0YWxJbnN0YW5jZSIsInJhbmRvbUtleSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbFByb3BzS2V5IiwiaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsImhvc3RJbnN0IiwibWFya0NvbnRhaW5lckFzUm9vdCIsImhvc3RSb290IiwidW5tYXJrQ29udGFpbmVyQXNSb290IiwidGFyZ2V0U3VzcGVuc2VJbnN0IiwiZWxlbWVudExpc3RlbmVyU2V0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJfb3duZXIiLCJfc291cmNlIiwic2V0RXh0cmFTdGFja0ZyYW1lIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJjb21wb25lbnROYW1lIiwidHlwZVNwZWNOYW1lIiwiZXJyb3IkMSIsImV4IiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yIiwicHJldmlvdXNDb250ZXh0IiwiZ2V0VW5tYXNrZWRDb250ZXh0IiwiZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyIiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsImhhc0NvbnRleHRDaGFuZ2VkIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwb3BDb250ZXh0IiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIkxlZ2FjeVJvb3QiLCJCbG9ja2luZ1Jvb3QiLCJDb25jdXJyZW50Um9vdCIsInJlbmRlcmVySUQiLCJpbmplY3RlZEhvb2siLCJoYXNMb2dnZWRFcnJvciIsImlzRGV2VG9vbHNQcmVzZW50IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiaW5qZWN0Iiwib25TY2hlZHVsZVJvb3QiLCJvblNjaGVkdWxlRmliZXJSb290Iiwib25Db21taXRSb290IiwicHJpb3JpdHlMZXZlbCIsIm9uQ29tbWl0RmliZXJSb290Iiwib25Db21taXRVbm1vdW50Iiwib25Db21taXRGaWJlclVubW91bnQiLCJTY2hlZHVsZXJfcnVuV2l0aFByaW9yaXR5IiwiU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2siLCJTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsIlNjaGVkdWxlcl9zaG91bGRZaWVsZCIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwiU2NoZWR1bGVyX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsIlNjaGVkdWxlcl9ub3ckMSIsIlNjaGVkdWxlcl9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwiU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJTY2hlZHVsZXJfTm9ybWFsUHJpb3JpdHkiLCJTY2hlZHVsZXJfTG93UHJpb3JpdHkiLCJ1bnN0YWJsZV9Mb3dQcmlvcml0eSIsIlNjaGVkdWxlcl9JZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJmYWtlQ2FsbGJhY2tOb2RlIiwiSW1tZWRpYXRlUHJpb3JpdHkkMSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5JDIiLCJOb3JtYWxQcmlvcml0eSQxIiwiTG93UHJpb3JpdHkkMSIsIklkbGVQcmlvcml0eSQxIiwiTm9Qcmlvcml0eSQxIiwic2hvdWxkWWllbGQiLCJyZXF1ZXN0UGFpbnQiLCJzeW5jUXVldWUiLCJpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSIsImlzRmx1c2hpbmdTeW5jUXVldWUiLCJpbml0aWFsVGltZU1zJDEiLCJnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCIsInJlYWN0UHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5IiwicmVhY3RQcmlvcml0eUxldmVsIiwicnVuV2l0aFByaW9yaXR5JDEiLCJzY2hlZHVsZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJzY2hlZHVsZVN5bmNDYWxsYmFjayIsImZsdXNoU3luY0NhbGxiYWNrUXVldWVJbXBsIiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja05vZGUiLCJmbHVzaFN5bmNDYWxsYmFja1F1ZXVlIiwiX2lzU3luYzIiLCJfcXVldWUiLCJSZWFjdFZlcnNpb24iLCJOb01vZGUiLCJTdHJpY3RNb2RlIiwiQmxvY2tpbmdNb2RlIiwiQ29uY3VycmVudE1vZGUiLCJQcm9maWxlTW9kZSIsIkRlYnVnVHJhY2luZ01vZGUiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyIsIk5vVHJhbnNpdGlvbiIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsInNldFRvU29ydGVkU3RyaW5nIiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lczIiLCJfc29ydGVkTmFtZXMzIiwiX3NvcnRlZE5hbWVzNCIsIl9zb3J0ZWROYW1lczUiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsIndhcm5pbmdzRm9yUm9vdCIsImZpYmVyQXJyYXkiLCJmaXJzdEZpYmVyIiwidW5pcXVlTmFtZXMiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwiTUFYX1NJR05FRF8zMV9CSVRfSU5UIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlciIsInBvcFByb3ZpZGVyIiwiY2FsY3VsYXRlQ2hhbmdlZEJpdHMiLCJvbGRWYWx1ZSIsImNoYW5nZWRCaXRzIiwiX2NhbGN1bGF0ZUNoYW5nZWRCaXRzIiwic2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoIiwicmVuZGVyTGFuZXMiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsIm5leHRGaWJlciIsImRlcGVuZGVuY3kiLCJmaXJzdENvbnRleHQiLCJvYnNlcnZlZEJpdHMiLCJ1cGRhdGUiLCJjcmVhdGVVcGRhdGUiLCJGb3JjZVVwZGF0ZSIsImVucXVldWVVcGRhdGUiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsIm1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlIiwicmVhZENvbnRleHQiLCJyZXNvbHZlZE9ic2VydmVkQml0cyIsImNvbnRleHRJdGVtIiwicmVzcG9uZGVycyIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwicGVuZGluZyIsImVmZmVjdHMiLCJ1cGRhdGVRdWV1ZSIsImNsb25lVXBkYXRlUXVldWUiLCJjbG9uZSIsInNoYXJlZFF1ZXVlIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJwZW5kaW5nUXVldWUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsImN1cnJlbnRMYXN0QmFzZVVwZGF0ZSIsIm5ld1N0YXRlIiwibmV3TGFuZXMiLCJuZXdCYXNlU3RhdGUiLCJuZXdGaXJzdEJhc2VVcGRhdGUiLCJuZXdMYXN0QmFzZVVwZGF0ZSIsInVwZGF0ZUV2ZW50VGltZSIsIl9jbG9uZSIsIl9sYXN0UGVuZGluZ1VwZGF0ZSIsIl9maXJzdFBlbmRpbmdVcGRhdGUiLCJtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzIiwicmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmciLCJjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nIiwiY29tbWl0VXBkYXRlUXVldWUiLCJmaW5pc2hlZFdvcmsiLCJmaW5pc2hlZFF1ZXVlIiwiZWZmZWN0IiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJlbXB0eVJlZnNPYmplY3QiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsImNhbGxlck5hbWUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsInJlcXVlc3RFdmVudFRpbWUiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFN0YXRlIiwibmV4dENvbnRleHQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJzaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIiLCJhZGRlbmR1bSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZXN1bWVNb3VudENsYXNzSW5zdGFuY2UiLCJtZW1vaXplZFByb3BzIiwib2xkQ29udGV4dCIsIm5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQiLCJoYXNOZXdMaWZlY3ljbGVzIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsInVucmVzb2x2ZWRPbGRQcm9wcyIsImVsZW1lbnRUeXBlIiwidW5yZXNvbHZlZE5ld1Byb3BzIiwicGVuZGluZ1Byb3BzIiwibmV4dFVubWFza2VkQ29udGV4dCIsImRpZFdhcm5BYm91dE1hcHMiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwicmV0dXJuRmliZXIiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJpc0FycmF5JDEiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInJlZiIsIl9zZWxmIiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImxhc3QiLCJsYXN0RWZmZWN0IiwibmV4dEVmZmVjdCIsImZpcnN0RWZmZWN0IiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwiaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsInVwZGF0ZVBvcnRhbCIsInBvcnRhbCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwidXBkYXRlRnJhZ21lbnQiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9uZXdGaWJlcjIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJ0b1N0cmluZ1RhZyIsImVudHJpZXMiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJfbmV3RmliZXIzIiwiX25ld0ZpYmVyNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9leGlzdGluZzMiLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJfaXNNb2NrRnVuY3Rpb24iLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiTk9fQ09OVEVYVCIsImNvbnRleHRTdGFja0N1cnNvciQxIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJEZWZhdWx0U3VzcGVuc2VDb250ZXh0IiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiaGFzU3VzcGVuc2VDb250ZXh0IiwiZmxhZyIsInNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0Iiwic2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dCIsInNoYWxsb3dDb250ZXh0IiwiYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dCIsInN1YnRyZWVDb250ZXh0IiwicHVzaFN1c3BlbnNlQ29udGV4dCIsIm5ld0NvbnRleHQiLCJwb3BTdXNwZW5zZUNvbnRleHQiLCJzaG91bGRDYXB0dXJlU3VzcGVuc2UiLCJoYXNJbnZpc2libGVQYXJlbnQiLCJmYWxsYmFjayIsInVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIiwiZmluZEZpcnN0U3VzcGVuZGVkIiwicm93IiwicmV2ZWFsT3JkZXIiLCJkaWRTdXNwZW5kIiwiTm9GbGFncyQxIiwiSGFzRWZmZWN0IiwiTGF5b3V0IiwiUGFzc2l2ZSQxIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsIl90ZXh0IiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwiZ2V0SXNIeWRyYXRpbmciLCJ3b3JrSW5Qcm9ncmVzc1NvdXJjZXMiLCJyZW5kZXJlclNpZ2lsJDEiLCJtYXJrU291cmNlQXNEaXJ0eSIsIm11dGFibGVTb3VyY2UiLCJyZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMiLCJfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSIsImdldFdvcmtJblByb2dyZXNzVmVyc2lvbiIsInNldFdvcmtJblByb2dyZXNzVmVyc2lvbiIsIndhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWIiwiX2N1cnJlbnRQcmltYXJ5UmVuZGVyZXIiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxIiwiZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllciIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwidXBkYXRlSG9va1R5cGVzRGV2Iiwid2Fybk9uSG9va01pc21hdGNoSW5EZXYiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJjdXJyZW50SG9va05hbWUiLCJ0YWJsZSIsInNlY29uZENvbHVtblN0YXJ0Iiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJuZXh0UmVuZGVyTGFuZXMiLCJfZGVidWdIb29rVHlwZXMiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIm51bWJlck9mUmVSZW5kZXJzIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzQWZ0ZXJUaHJvdyIsImlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXdIb29rIiwiY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSIsImJhc2ljU3RhdGVSZWR1Y2VyIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsImZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwiZWFnZXJSZWR1Y2VyIiwiZWFnZXJTdGF0ZSIsInJlcmVuZGVyUmVkdWNlciIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsImZpcnN0UmVuZGVyUGhhc2VVcGRhdGUiLCJyZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZSIsImdldFNuYXBzaG90IiwiZ2V0VmVyc2lvbiIsIl9nZXRWZXJzaW9uIiwiaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSIsImN1cnJlbnRSZW5kZXJWZXJzaW9uIiwic25hcHNob3QiLCJ1c2VNdXRhYmxlU291cmNlIiwic3Vic2NyaWJlIiwiZ2V0V29ya0luUHJvZ3Jlc3NSb290IiwiZGlzcGF0Y2hlciIsIl9kaXNwYXRjaGVyJHVzZVN0YXRlIiwidXNlU3RhdGUiLCJjdXJyZW50U25hcHNob3QiLCJzZXRTbmFwc2hvdCIsInN0YXRlSG9vayIsInByZXZHZXRTbmFwc2hvdCIsInByZXZTb3VyY2UiLCJwcmV2U3Vic2NyaWJlIiwidXNlRWZmZWN0IiwibWF5YmVOZXdWZXJzaW9uIiwibWF5YmVOZXdTbmFwc2hvdCIsImhhbmRsZUNoYW5nZSIsImxhdGVzdEdldFNuYXBzaG90IiwibGF0ZXN0U2V0U25hcHNob3QiLCJ1bnN1YnNjcmliZSIsIm5ld1F1ZXVlIiwibW91bnRNdXRhYmxlU291cmNlIiwidXBkYXRlTXV0YWJsZVNvdXJjZSIsIm1vdW50U3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInJlcmVuZGVyU3RhdGUiLCJwdXNoRWZmZWN0IiwiZGVzdHJveSIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwibW91bnRSZWYiLCJzZWFsIiwidXBkYXRlUmVmIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsInVwZGF0ZUVmZmVjdEltcGwiLCJwcmV2RWZmZWN0IiwibW91bnRFZmZlY3QiLCJqZXN0Iiwid2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWIiwidXBkYXRlRWZmZWN0IiwibW91bnRMYXlvdXRFZmZlY3QiLCJ1cGRhdGVMYXlvdXRFZmZlY3QiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2FsbGJhY2siLCJfaW5zdCIsInJlZk9iamVjdCIsIl9pbnN0MiIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsImVmZmVjdERlcHMiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnREZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1cGRhdGVEZWJ1Z1ZhbHVlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJfbW91bnRTdGF0ZSIsInByZXZWYWx1ZSIsInByZXZUcmFuc2l0aW9uIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsIl91cGRhdGVTdGF0ZSIsInJlcmVuZGVyRGVmZXJyZWRWYWx1ZSIsIl9yZXJlbmRlclN0YXRlIiwic3RhcnRUcmFuc2l0aW9uIiwic2V0UGVuZGluZyIsIm1vdW50VHJhbnNpdGlvbiIsIl9tb3VudFN0YXRlMiIsImlzUGVuZGluZyIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwic3RhcnRSZWYiLCJyZXJlbmRlclRyYW5zaXRpb24iLCJfcmVyZW5kZXJTdGF0ZTIiLCJnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYiLCJ3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYiLCJtb3VudE9wYXF1ZUlkZW50aWZpZXIiLCJtYWtlSWQiLCJkaWRVcGdyYWRlIiwicmVhZFZhbHVlIiwic2V0SWQiLCJfaWQiLCJ1cGRhdGVPcGFxdWVJZGVudGlmaWVyIiwicmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyIiwicHJldkRpc3BhdGNoZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsImN1cnJlbnRTdGF0ZSIsIndhcm5JZk5vdFNjb3BlZFdpdGhNYXRjaGluZ0FjdCIsIndhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRldiIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZU9wYXF1ZUlkZW50aWZpZXIiLCJ1bnN0YWJsZV9pc05ld1JlY29uY2lsZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsIm5vdyQxIiwiY29tbWl0VGltZSIsInByb2ZpbGVyU3RhcnRUaW1lIiwiZ2V0Q29tbWl0VGltZSIsInJlY29yZENvbW1pdFRpbWUiLCJzdGFydFByb2ZpbGVyVGltZXIiLCJhY3R1YWxTdGFydFRpbWUiLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEiLCJvdmVycmlkZUJhc2VUaW1lIiwiYWN0dWFsRHVyYXRpb24iLCJzZWxmQmFzZUR1cmF0aW9uIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJkaWRSZWNlaXZlVXBkYXRlIiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciIsImRpZFdhcm5BYm91dFRhaWxPcHRpb25zIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlIiwidXBkYXRlRm9yd2FyZFJlZiIsImlubmVyUHJvcFR5cGVzIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJ1cGRhdGVMYW5lcyIsImlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQiLCJjb21wYXJlIiwicmVzb2x2ZWRUeXBlIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsIl9pbm5lclByb3BUeXBlcyIsInByZXZQcm9wcyIsIm91dGVyTWVtb1R5cGUiLCJvdXRlclByb3BUeXBlcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwiYmFzZUxhbmVzIiwicHVzaFJlbmRlckxhbmVzIiwibmV4dEJhc2VMYW5lcyIsInByZXZCYXNlTGFuZXMiLCJtYXJrU3Bhd25lZFdvcmsiLCJfbmV4dFN0YXRlIiwiX25leHRTdGF0ZTIiLCJzdWJ0cmVlUmVuZGVyTGFuZXMiLCJfc3VidHJlZVJlbmRlckxhbmVzIiwidXBkYXRlTGVnYWN5SGlkZGVuQ29tcG9uZW50IiwidXBkYXRlTW9kZSIsInVwZGF0ZVByb2ZpbGVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJtYXJrUmVmIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJwZW5kaW5nQ29udGV4dCIsInVwZGF0ZUhvc3RSb290IiwicHJldkNoaWxkcmVuIiwibXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwibW91bnRMYXp5Q29tcG9uZW50IiwiX2N1cnJlbnQiLCJyZXNvbHZlZFRhZyIsInJlc29sdmVMYXp5Q29tcG9uZW50VGFnIiwicmVzb2x2ZWRQcm9wcyIsInJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyIsInJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nIiwiaGludCIsIm1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IiwibW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50IiwiX2NvbXBvbmVudE5hbWUyIiwiX2RlYnVnSUQiLCJkZWJ1Z1NvdXJjZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsIlNVU1BFTkRFRF9NQVJLRVIiLCJyZXRyeUxhbmUiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJ1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwicHJldk9mZnNjcmVlblN0YXRlIiwic2hvdWxkUmVtYWluT25GYWxsYmFjayIsInN1c3BlbnNlQ29udGV4dCIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG91bGRTdXNwZW5kIiwic2hvd0ZhbGxiYWNrIiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2tGcmFnbWVudCIsIm1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuIiwicHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJ1bnN0YWJsZV9leHBlY3RlZExvYWRUaW1lIiwiX2ZhbGxiYWNrRnJhZ21lbnQiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX25leHRGYWxsYmFja0NoaWxkcmVuMiIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuMiIsIl9mYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJ1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQzIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4zIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50NCIsInVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX25leHRGYWxsYmFja0NoaWxkcmVuMyIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuNCIsIl9mYWxsYmFja0NoaWxkRnJhZ21lbnQyIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50NSIsIl9wcmV2T2Zmc2NyZWVuU3RhdGUiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjUiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ2IiwicHJpbWFyeUNoaWxkcmVuIiwicHJpbWFyeUNoaWxkUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJmYWxsYmFja0NoaWxkcmVuIiwicHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCIsImZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInRyZWVCYXNlRHVyYXRpb24iLCJjcmVhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwib2Zmc2NyZWVuUHJvcHMiLCJjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50IiwicHJvZ3Jlc3NlZExhc3RFZmZlY3QiLCJzY2hlZHVsZVdvcmtPbkZpYmVyIiwicHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInZhbGlkYXRlVGFpbE9wdGlvbnMiLCJ0YWlsTW9kZSIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUiLCJpc0JhY2t3YXJkcyIsInRhaWwiLCJsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nIiwicmVuZGVyU3RhdGUiLCJyZW5kZXJpbmdTdGFydFRpbWUiLCJ1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJzaG91bGRGb3JjZUZhbGxiYWNrIiwiZGlkU3VzcGVuZEJlZm9yZSIsIl90YWlsIiwibmV4dFJvdyIsInVwZGF0ZVBvcnRhbENvbXBvbmVudCIsImhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIiwidXBkYXRlQ29udGV4dFByb3ZpZGVyIiwicHJvdmlkZXJUeXBlIiwicHJvdmlkZXJQcm9wVHlwZXMiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsInVuc3RhYmxlX29ic2VydmVkQml0cyIsInJlbW91bnRGaWJlciIsIm9sZFdvcmtJblByb2dyZXNzIiwibmV3V29ya0luUHJvZ3Jlc3MiLCJwcmV2U2libGluZyIsImJlZ2luV29yayIsIl9kZWJ1Z05lZWRzUmVtb3VudCIsImhhc0NoaWxkV29yayIsInByaW1hcnlDaGlsZExhbmVzIiwiX2hhc0NoaWxkV29yayIsIl9Db21wb25lbnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfQ29tcG9uZW50MiIsIl91bnJlc29sdmVkUHJvcHMiLCJfcmVzb2x2ZWRQcm9wcyIsIl91bnJlc29sdmVkUHJvcHMyIiwiX3Jlc29sdmVkUHJvcHMyIiwiX3R5cGUyIiwiX3VucmVzb2x2ZWRQcm9wczMiLCJfcmVzb2x2ZWRQcm9wczMiLCJfQ29tcG9uZW50MyIsIl91bnJlc29sdmVkUHJvcHM0IiwiX3Jlc29sdmVkUHJvcHM0IiwibWFya1VwZGF0ZSIsIm1hcmtSZWYkMSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQkMSIsInVwZGF0ZUhvc3RUZXh0JDEiLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJpc0hpZGRlbiIsImN1cnJlbnRIb3N0Q29udGV4dCIsImN1dE9mZlRhaWxJZk5lZWRlZCIsImhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayIsInRhaWxOb2RlIiwibGFzdFRhaWxOb2RlIiwiX3RhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImNvbXBsZXRlV29yayIsImZpYmVyUm9vdCIsIndhc0h5ZHJhdGVkIiwiX3dhc0h5ZHJhdGVkIiwiX3Jvb3RDb250YWluZXJJbnN0YW5jZSIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJfd2FzSHlkcmF0ZWQyIiwibmV4dERpZFRpbWVvdXQiLCJwcmV2RGlkVGltZW91dCIsImhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCIsInJlbmRlckRpZFN1c3BlbmQiLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwiZGlkU3VzcGVuZEFscmVhZHkiLCJyZW5kZXJlZFRhaWwiLCJjYW5ub3RCZVN1c3BlbmRlZCIsInJlbmRlckhhc05vdFN1c3BlbmRlZFlldCIsInN1c3BlbmRlZCIsIm5ld1RoZW5uYWJsZXMiLCJnZXRSZW5kZXJUYXJnZXRUaW1lIiwiX3N1c3BlbmRlZCIsIl9uZXdUaGVubmFibGVzIiwicG9wUmVuZGVyTGFuZXMiLCJfcHJldlN0YXRlIiwicHJldklzSGlkZGVuIiwibmV4dElzSGlkZGVuIiwidW53aW5kV29yayIsIl9mbGFncyIsIl9mbGFnczIiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJjcmVhdGVDYXB0dXJlZFZhbHVlIiwic2hvd0Vycm9yRGlhbG9nIiwiYm91bmRhcnkiLCJlcnJvckluZm8iLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnRTdGFjayIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TmFtZSIsImNvbWJpbmVkTWVzc2FnZSIsIlBvc3NpYmx5V2Vha01hcCQxIiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwib25VbmNhdWdodEVycm9yIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkIiwiYXR0YWNoUGluZ0xpc3RlbmVyIiwid2FrZWFibGUiLCJwaW5nQ2FjaGUiLCJ0aHJlYWRJRHMiLCJwaW5nIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJ0aGVuIiwidGhyb3dFeGNlcHRpb24iLCJzb3VyY2VGaWJlciIsInJvb3RSZW5kZXJMYW5lcyIsImN1cnJlbnRTb3VyY2UiLCJoYXNJbnZpc2libGVQYXJlbnRCb3VuZGFyeSIsIl93b3JrSW5Qcm9ncmVzcyIsIndha2VhYmxlcyIsImN1cnJlbnRTb3VyY2VGaWJlciIsInJlbmRlckRpZEVycm9yIiwiX2Vycm9ySW5mbyIsIl91cGRhdGUiLCJpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5IiwiX3VwZGF0ZTIiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIlBvc3NpYmx5V2Vha1NldCIsIldlYWtTZXQiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJzYWZlbHlDYWxsRGVzdHJveSIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJzY2hlZHVsZVBhc3NpdmVFZmZlY3RzIiwiX2VmZmVjdCIsImVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50IiwiZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50IiwiY29tbWl0TGlmZUN5Y2xlcyIsImZpbmlzaGVkUm9vdCIsImNvbW1pdHRlZExhbmVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJtZW1vaXplZEludGVyYWN0aW9ucyIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwiaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4iLCJjb21taXRBdHRhY2hSZWYiLCJpbnN0YW5jZVRvVXNlIiwiY29tbWl0RGV0YWNoUmVmIiwiY3VycmVudFJlZiIsImNvbW1pdFVubW91bnQiLCJyZW5kZXJQcmlvcml0eUxldmVsIiwiX2VmZmVjdDIiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJjb21taXROZXN0ZWRVbm1vdW50cyIsImRldGFjaEZpYmVyTXV0YXRpb24iLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwiY29tbWl0UGxhY2VtZW50IiwiaXNDb250YWluZXIiLCJwYXJlbnRTdGF0ZU5vZGUiLCJiZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiaXNIb3N0IiwiY3VycmVudFBhcmVudElzVmFsaWQiLCJjdXJyZW50UGFyZW50SXNDb250YWluZXIiLCJmaW5kUGFyZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwiX3Jvb3QiLCJjb21taXRTdXNwZW5zZUNvbXBvbmVudCIsImF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMiLCJtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2siLCJwcmltYXJ5Q2hpbGRQYXJlbnQiLCJyZXRyeUNhY2hlIiwicmV0cnkiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsIl9fcmVhY3REb05vdFRyYWNlSW50ZXJhY3Rpb25zIiwidW5zdGFibGVfd3JhcCIsImlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuIiwiY29tbWl0UmVzZXRUZXh0Q29udGVudCIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwiUk9MRV9UWVBFIiwiVEVTVF9OQU1FX1RZUEUiLCJURVhUX1RZUEUiLCJzeW1ib2xGb3IkMSIsImNvbW1pdEhvb2tzIiwib25Db21taXRSb290JDEiLCJjb21taXRIb29rIiwiY2VpbCIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiIsIlJlYWN0Q3VycmVudE93bmVyJDIiLCJJc1NvbWVSZW5kZXJlckFjdGluZyIsIk5vQ29udGV4dCIsIkJhdGNoZWRDb250ZXh0IiwiRXZlbnRDb250ZXh0IiwiRGlzY3JldGVFdmVudENvbnRleHQiLCJMZWdhY3lVbmJhdGNoZWRDb250ZXh0IiwiUmVuZGVyQ29udGV4dCIsIkNvbW1pdENvbnRleHQiLCJSZXRyeUFmdGVyRXJyb3IiLCJSb290SW5jb21wbGV0ZSIsIlJvb3RGYXRhbEVycm9yZWQiLCJSb290RXJyb3JlZCIsIlJvb3RTdXNwZW5kZWQiLCJSb290U3VzcGVuZGVkV2l0aERlbGF5IiwiUm9vdENvbXBsZXRlZCIsImV4ZWN1dGlvbkNvbnRleHQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyIsInN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciIsIndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yIiwid29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwibW9zdFJlY2VudGx5VXBkYXRlZFJvb3QiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwiSW5maW5pdHkiLCJSRU5ERVJfVElNRU9VVF9NUyIsInJlc2V0UmVuZGVyVGltZXIiLCJoYXNVbmNhdWdodEVycm9yIiwiZmlyc3RVbmNhdWdodEVycm9yIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyIsInJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudCIsInBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNVbm1vdW50Iiwicm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIm5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCIsInNwYXduZWRXb3JrRHVyaW5nUmVuZGVyIiwiY3VycmVudEV2ZW50VGltZSIsImN1cnJlbnRFdmVudFdpcExhbmVzIiwiY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzIiwiaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzIiwiZm9jdXNlZEluc3RhbmNlSGFuZGxlIiwic2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiaXNUcmFuc2l0aW9uIiwic2NoZWR1bGVyUHJpb3JpdHkiLCJzY2hlZHVsZXJMYW5lUHJpb3JpdHkiLCJyZXF1ZXN0UmV0cnlMYW5lIiwiY2hlY2tGb3JOZXN0ZWRVcGRhdGVzIiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsIndhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkRmliZXJJbkRFViIsIm1hcmtSb290U3VzcGVuZGVkJDEiLCJzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMiLCJwZXJmb3JtU3luY1dvcmtPblJvb3QiLCJlbnN1cmVSb290SXNTY2hlZHVsZWQiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwiZXhpc3RpbmdDYWxsYmFja05vZGUiLCJuZXdDYWxsYmFja1ByaW9yaXR5IiwiY2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsIm5ld0NhbGxiYWNrTm9kZSIsInBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwiZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJleGl0U3RhdHVzIiwicmVuZGVyUm9vdENvbmN1cnJlbnQiLCJwcmVwYXJlRnJlc2hTdGFjayIsInJlbmRlclJvb3RTeW5jIiwiZmF0YWxFcnJvciIsImZpbmlzaGVkTGFuZXMiLCJmaW5pc2hDb25jdXJyZW50UmVuZGVyIiwiY29tbWl0Um9vdCIsInNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFViIsIm1zVW50aWxUaW1lb3V0IiwidGltZW91dEhhbmRsZSIsImV2ZW50VGltZU1zIiwidGltZUVsYXBzZWRNcyIsIl9tc1VudGlsVGltZW91dCIsImpuZCIsImZsdXNoRGlzY3JldGVVcGRhdGVzIiwiZmx1c2hQZW5kaW5nRGlzY3JldGVVcGRhdGVzIiwicm9vdHMiLCJiYXRjaGVkVXBkYXRlcyQxIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJiYXRjaGVkRXZlbnRVcGRhdGVzJDEiLCJkaXNjcmV0ZVVwZGF0ZXMkMSIsInVuYmF0Y2hlZFVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJoYW5kbGVFcnJvciIsInRocm93blZhbHVlIiwiZXJyb3JlZFdvcmsiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJ5ZXRBbm90aGVyVGhyb3duVmFsdWUiLCJwdXNoRGlzcGF0Y2hlciIsInBvcERpc3BhdGNoZXIiLCJwdXNoSW50ZXJhY3Rpb25zIiwicHJldkludGVyYWN0aW9ucyIsInBvcEludGVyYWN0aW9ucyIsInN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyIsIndvcmtMb29wU3luYyIsInBlcmZvcm1Vbml0T2ZXb3JrIiwid29ya0xvb3BDb25jdXJyZW50IiwidW5pdE9mV29yayIsImJlZ2luV29yayQxIiwiY29tcGxldGVkV29yayIsInJlc2V0Q2hpbGRMYW5lcyIsIl9uZXh0Iiwic2libGluZ0ZpYmVyIiwibmV3Q2hpbGRMYW5lcyIsInNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucyIsImlzVGltZWRPdXRTdXNwZW5zZSIsImNvbW1pdFJvb3RJbXBsIiwiZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiX2Vycm9yIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsIl9lcnJvcjIiLCJyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIiwibmV4dE5leHRFZmZlY3QiLCJkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyIsInNjaGVkdWxlSW50ZXJhY3Rpb25zIiwiZmluaXNoUGVuZGluZ0ludGVyYWN0aW9ucyIsIl9lcnJvcjMiLCJwcmltYXJ5RmxhZ3MiLCJfY3VycmVudDIiLCJfY3VycmVudDMiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsImludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUiLCJ1bm1vdW50RWZmZWN0cyIsIm1vdW50RWZmZWN0cyIsIl9maWJlciIsIl9lcnJvcjQiLCJwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsImVycm9yVG9JZ25vcmUiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwidGltZUVsYXBzZWQiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50IiwicHJldmlvdXNGaWJlciIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsImR1bW15RmliZXIiLCJvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSIsImFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWIiwib3JpZ2luYWxFcnJvciIsInJlcGxheUVycm9yIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJyZW5kZXJpbmdDb21wb25lbnROYW1lIiwiZGVkdXBlS2V5Iiwic2V0U3RhdGVDb21wb25lbnROYW1lIiwiSXNUaGlzUmVuZGVyZXJBY3RpbmciLCJ3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdVcGRhdGVzSW5ERVYiLCJkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciIsIndhcm5JZlVubW9ja2VkU2NoZWR1bGVyIiwidW5zdGFibGVfZmx1c2hBbGxXaXRob3V0QXNzZXJ0aW5nIiwiY29tcHV0ZVRocmVhZElEIiwiaW50ZXJhY3Rpb25UaHJlYWRJRCIsImludGVyYWN0aW9ucyIsInBlbmRpbmdJbnRlcmFjdGlvbk1hcCIsInBlbmRpbmdJbnRlcmFjdGlvbnMiLCJpbnRlcmFjdGlvbiIsIl9fY291bnQiLCJzdWJzY3JpYmVyIiwiX19zdWJzY3JpYmVyUmVmIiwidGhyZWFkSUQiLCJvbldvcmtTY2hlZHVsZWQiLCJzY2hlZHVsZWRJbnRlcmFjdGlvbnMiLCJzY2hlZHVsZWRMYW5lIiwib25Xb3JrU3RhcnRlZCIsInJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQiLCJvbldvcmtTdG9wcGVkIiwib25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQiLCJhY3RpbmdVcGRhdGVzU2NvcGVEZXB0aCIsInJlc29sdmVGYW1pbHkiLCJmYWlsZWRCb3VuZGFyaWVzIiwic2V0UmVmcmVzaEhhbmRsZXIiLCJoYW5kbGVyIiwiZmFtaWx5IiwiY3VycmVudFJlbmRlciIsInN5bnRoZXRpY1R5cGUiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwibmVlZHNDb21wYXJlRmFtaWxpZXMiLCIkJHR5cGVvZk5leHRUeXBlIiwicHJldkZhbWlseSIsInNjaGVkdWxlUmVmcmVzaCIsInN0YWxlRmFtaWxpZXMiLCJ1cGRhdGVkRmFtaWxpZXMiLCJzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5Iiwic2NoZWR1bGVSb290IiwidXBkYXRlQ29udGFpbmVyIiwiY2FuZGlkYXRlVHlwZSIsIm5lZWRzUmVuZGVyIiwibmVlZHNSZW1vdW50IiwiZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoIiwiZmFtaWxpZXMiLCJob3N0SW5zdGFuY2VzIiwidHlwZXMiLCJmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkiLCJkaWRNYXRjaCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkiLCJmb3VuZEhvc3RJbnN0YW5jZXMiLCJmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsIk51bWJlciIsIk5hTiIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0JDEiLCJjdXJyZW50RGVwZW5kZW5jaWVzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsImNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbiIsImVsZW1lbnRzIiwicGVuZGluZ0NoaWxkcmVuIiwiRmliZXJSb290Tm9kZSIsInVuc3RhYmxlX2dldFRocmVhZElEIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJoeWRyYXRpb25DYWxsYmFja3MiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJyZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyIsIm1ldGhvZE5hbWUiLCJob3N0RmliZXIiLCJjcmVhdGVDb250YWluZXIiLCJjdXJyZW50JDEiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsIm1hcmtSZXRyeUxhbmVJbXBsIiwibWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQiLCJhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEiLCJydW5XaXRoUHJpb3JpdHkkMiIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwic2hvdWxkU3VzcGVuZEltcGwiLCJvdmVycmlkZUhvb2tTdGF0ZSIsIm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCIsIm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCIsIm92ZXJyaWRlUHJvcHMiLCJvdmVycmlkZVByb3BzRGVsZXRlUGF0aCIsIm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoIiwic2NoZWR1bGVVcGRhdGUiLCJzZXRTdXNwZW5zZUhhbmRsZXIiLCJjb3B5V2l0aERlbGV0ZUltcGwiLCJwYXRoIiwidXBkYXRlZCIsImNvcHlXaXRoRGVsZXRlIiwiY29weVdpdGhSZW5hbWVJbXBsIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRLZXkiLCJuZXdLZXkiLCJjb3B5V2l0aFJlbmFtZSIsImNvcHlXaXRoU2V0SW1wbCIsImNvcHlXaXRoU2V0IiwiZmluZEhvb2siLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGV2VG9vbHNDb25maWciLCJmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwicmVuZGVyZXJDb25maWciLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsImdldEN1cnJlbnRGaWJlciIsIlJlYWN0RE9NUm9vdCIsIl9pbnRlcm5hbFJvb3QiLCJjcmVhdGVSb290SW1wbCIsIlJlYWN0RE9NQmxvY2tpbmdSb290IiwiaG9zdEluc3RhbmNlIiwidW5tb3VudCIsImh5ZHJhdGlvbk9wdGlvbnMiLCJtdXRhYmxlU291cmNlcyIsImNvbnRhaW5lck5vZGVUeXBlIiwiY3JlYXRlTGVnYWN5Um9vdCIsImlzVmFsaWRDb250YWluZXIiLCJSZWFjdEN1cnJlbnRPd25lciQzIiwidG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyIsIndhcm5lZEFib3V0SHlkcmF0ZUFQSSIsImlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QiLCJyb290RWwiLCJnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50IiwibGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJzaG91bGRIeWRyYXRlIiwid2FybmVkIiwicm9vdFNpYmxpbmciLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2skMSIsImxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwib3JpZ2luYWxDYWxsYmFjayIsIl9vcmlnaW5hbENhbGxiYWNrIiwiZmluZERPTU5vZGUiLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImlzTW9kZXJuUm9vdCIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiY29udGFpbmVyTm9kZSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QiLCJfcm9vdEVsIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCIsImNsZWFyIiwiY3JlYXRlUG9ydGFsJDEiLCJyZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsIkludGVybmFscyIsIkV2ZW50cyIsImZvdW5kRGV2VG9vbHMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJwcm90b2NvbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiYWEiLCJtIiwiYmEiLCJjYSIsImRhIiwiZWEiLCJmYSIsImhhIiwiaWEiLCJqYSIsImthIiwibGEiLCJtYSIsIm5hIiwiQiIsImciLCJEIiwib2EiLCJwYSIsInFhIiwicmEiLCJzYSIsInRhIiwidWEiLCJ3YSIsInhhIiwieWEiLCJ6YSIsIkFhIiwiQmEiLCJDYSIsIkRhIiwiRWEiLCJGYSIsIkdhIiwiSGEiLCJJYSIsIkphIiwiRSIsIkthIiwiTGEiLCJNYSIsIk5hIiwiT2EiLCJQYSIsImgiLCJRYSIsIlJhIiwiU2EiLCJUYSIsIlVhIiwiVmEiLCJXYSIsIlhhIiwiWWEiLCJaYSIsIiRhIiwiYWIiLCJiYiIsImRiIiwiZWIiLCJmYiIsImdiIiwiaGIiLCJpYiIsImpiIiwia2IiLCJsYiIsIm1iIiwibmIiLCJvYiIsInBiIiwicWIiLCJyYiIsInNiIiwidGIiLCJ1YiIsInZiIiwid2IiLCJ4YiIsInliIiwiemIiLCJBYiIsIkJiIiwiQ2IiLCJEYiIsIkViIiwiRmIiLCJHYiIsIkhiIiwiSWIiLCJKYiIsIktiIiwiTGIiLCJNYiIsIk5iIiwiT2IiLCJQYiIsIlFiIiwiUmIiLCJsIiwiU2IiLCJUYiIsIlViIiwiVmIiLCJXYiIsIlhiIiwiWWIiLCJaYiIsIiRiIiwiYWMiLCJiYyIsImNjIiwiZGMiLCJlYyIsImZjIiwiZ2MiLCJoYyIsImljIiwiamMiLCJrYyIsImxjIiwibWMiLCJuYyIsIm9jIiwicGMiLCJxYyIsInJjIiwic2MiLCJ0YyIsInVjIiwidmMiLCJ3YyIsInhjIiwieWMiLCJ6YyIsIkFjIiwiQmMiLCJDYyIsIkRjIiwiRWMiLCJGYyIsIkdjIiwiSGMiLCJJYyIsIkpjIiwiS2MiLCJMYyIsIk1jIiwiTmMiLCJPYyIsIlBjIiwiUWMiLCJGIiwiUmMiLCJTYyIsIlRjIiwiVWMiLCJWYyIsIldjIiwiWGMiLCJZYyIsIlpjIiwiJGMiLCJhZCIsImJkIiwiY2QiLCJkZCIsImVkIiwiZmQiLCJnZCIsImhkIiwia2QiLCJsZCIsIm1kIiwibmQiLCJvZCIsInBkIiwicWQiLCJyZCIsInNkIiwidGQiLCJ1ZCIsInZkIiwid2QiLCJ4ZCIsInlkIiwiQWQiLCJ6ZCIsIkJkIiwiQ2QiLCJEZCIsIkVkIiwiRmQiLCJHZCIsIkhkIiwiSWQiLCJKZCIsIktkIiwiTGQiLCJNZCIsIk5kIiwiT2QiLCJQZCIsIlFkIiwiUmQiLCJTZCIsIlRkIiwiVWQiLCJWZCIsIldkIiwiWGQiLCJZZCIsIlpkIiwiJGQiLCJhZSIsImJlIiwiY2UiLCJkZSIsImVlIiwiZmUiLCJnZSIsImhlIiwiaWUiLCJqZSIsImtlIiwibGUiLCJtZSIsIm5lIiwib2UiLCJwZSIsInFlIiwicmUiLCJzZSIsInRlIiwidWUiLCJ2ZSIsIndlIiwieGUiLCJ5ZSIsInplIiwib25pbnB1dCIsIkFlIiwiQmUiLCJDZSIsIkRlIiwiRWUiLCJGZSIsIkdlIiwiSGUiLCJJZSIsIkplIiwiS2UiLCJMZSIsIk1lIiwiTmUiLCJPZSIsIlBlIiwiUWUiLCJSZSIsIlNlIiwiVGUiLCJVZSIsIlZlIiwiV2UiLCJYZSIsIlllIiwiWmUiLCJHIiwiJGUiLCJhZiIsImJmIiwiY2YiLCJkZiIsImpkIiwidyIsInUiLCJ0IiwicSIsImVmIiwiZmYiLCJnZiIsImhmIiwiSiIsIksiLCJRIiwiTCIsImpmIiwia2YiLCJsZiIsIm1mIiwibmYiLCJvZiIsInBmIiwicWYiLCJyZiIsInNmIiwidGYiLCJ1ZiIsInZmIiwid2YiLCJ4ZiIsInlmIiwiemYiLCJBZiIsIkJmIiwiSCIsIkkiLCJDZiIsIk0iLCJOIiwiRGYiLCJFZiIsIkZmIiwiR2YiLCJIZiIsIklmIiwiSmYiLCJLZiIsIkxmIiwiTWYiLCJOZiIsIk9mIiwiUGYiLCJRZiIsIlJmIiwiU2YiLCJUZiIsIlVmIiwiVmYiLCJXZiIsIlhmIiwiWWYiLCJaZiIsIiRmIiwiYWciLCJiZyIsImNnIiwiZGciLCJPIiwiZWciLCJmZyIsImdnIiwiaGciLCJpZyIsImpnIiwia2ciLCJsZyIsIm1nIiwibmciLCJvZyIsInBnIiwicWciLCJyZyIsInNnIiwidGciLCJ1ZyIsInZnIiwid2ciLCJ4ZyIsInlnIiwiemciLCJBZyIsIkJnIiwiQ2ciLCJBIiwicCIsIkMiLCJEZyIsIkVnIiwiRmciLCJHZyIsIktnIiwiSGciLCJJZyIsIkpnIiwiTGciLCJNZyIsIk5nIiwiT2ciLCJQZyIsIlFnIiwiUmciLCJTZyIsIlRnIiwiVWciLCJWZyIsIldnIiwiWGciLCJZZyIsIlpnIiwiJGciLCJhaCIsImJoIiwiY2giLCJkaCIsImVoIiwiZmgiLCJnaCIsImhoIiwiUCIsImloIiwiamgiLCJraCIsImxoIiwibWgiLCJuaCIsIm9oIiwicGgiLCJxaCIsInJoIiwic2giLCJ0aCIsInVoIiwidmgiLCJ3aCIsInhoIiwiUiIsIlMiLCJUIiwieWgiLCJ6aCIsIkFoIiwiQmgiLCJDaCIsIkRoIiwiRWgiLCJGaCIsIkdoIiwiSGgiLCJJaCIsIkpoIiwiS2giLCJMaCIsIk1oIiwiTmgiLCJVIiwiT2giLCJQaCIsIlFoIiwiUmgiLCJTaCIsIlRoIiwiVWgiLCJWaCIsIldoIiwiWGgiLCJZaCIsIlpoIiwiJGgiLCJhaSIsImJpIiwiY2kiLCJkaSIsImVpIiwiZmkiLCJnaSIsImhpIiwiaWkiLCJqaSIsImtpIiwibGkiLCJtaSIsIm5pIiwib2kiLCJwaSIsInFpIiwicmkiLCJzaSIsInRpIiwidWkiLCJ2aSIsIndpIiwieGkiLCJ5aSIsInppIiwiQWkiLCJCaSIsIkNpIiwiRGkiLCJFaSIsIkZpIiwiR2kiLCJWIiwiSGkiLCJJaSIsIlciLCJKaSIsIktpIiwiTGkiLCJNaSIsIk5pIiwiT2kiLCJQaSIsIlFpIiwiUmkiLCJTaSIsIlRpIiwiVWkiLCJWaSIsIldpIiwiWGkiLCJZaSIsIlppIiwiJGkiLCJhaiIsImJqIiwiY2oiLCJkaiIsImVqIiwiZmoiLCJnaiIsImhqIiwiaWoiLCJqaiIsImtqIiwibGoiLCJtaiIsIm5qIiwib2oiLCJwaiIsIlgiLCJZIiwicWoiLCJyaiIsInNqIiwidGoiLCJ1aiIsInZqIiwid2oiLCJaIiwieGoiLCJ5aiIsInpqIiwiQWoiLCJCaiIsIkNqIiwiRGoiLCJFaiIsIkZqIiwiR2oiLCJIaiIsIklqIiwiSmoiLCJLaiIsIkxqIiwiTWoiLCJOaiIsIk9qIiwiUGoiLCJRaiIsIlJqIiwiU2oiLCJUaiIsIlVqIiwiVmoiLCJXaiIsIlhqIiwiWWoiLCJ2YSIsImFrIiwiYmsiLCJjayIsIlpqIiwiZGsiLCJlayIsImZrIiwiZ2siLCJoayIsImlrIiwiamsiLCJrayIsImxrIiwibWsiLCJuayIsIm9rIiwicGsiLCJxayIsInJrIiwic2siLCJ0ayIsInVrIiwidmsiLCJ3ayIsInhrIiwieWsiLCJTdXNwZW5zZSIsImN1cnJlbnRFeHRyYVN0YWNrRnJhbWUiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiX2NvbnN0cnVjdG9yIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJjb21wbGV0ZVN0YXRlIiwiZW1wdHlPYmplY3QiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJmbk5hbWUiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiY3JlYXRlUmVmIiwiUkVTRVJWRURfUFJPUFMiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwiUmVhY3RFbGVtZW50IiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0VsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsImdldEVsZW1lbnRLZXkiLCJtYXBJbnRvQXJyYXkiLCJlc2NhcGVkUHJlZml4IiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJtYXBwZWRDaGlsZCIsImNoaWxkS2V5IiwiZXNjYXBlZENoaWxkS2V5IiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhYmxlQ2hpbGRyZW4iLCJjaGlsZHJlblN0cmluZyIsIm1hcENoaWxkcmVuIiwiY291bnQiLCJjb3VudENoaWxkcmVuIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsInRvQXJyYXkiLCJvbmx5Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiX2N1cnJlbnRWYWx1ZTIiLCJfdGhyZWFkQ291bnQiLCJQcm92aWRlciIsImhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIiLCJoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciIsIl9Qcm92aWRlciIsIl9jdXJyZW50UmVuZGVyZXIyIiwiVW5pbml0aWFsaXplZCIsIlBlbmRpbmciLCJSZXNvbHZlZCIsIlJlamVjdGVkIiwibGF6eUluaXRpYWxpemVyIiwiX3N0YXR1cyIsIl9yZXN1bHQiLCJ0aGVuYWJsZSIsIm1vZHVsZU9iamVjdCIsImRlZmF1bHRFeHBvcnQiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwibGF6eSIsImxhenlUeXBlIiwibmV3RGVmYXVsdFByb3BzIiwibmV3UHJvcFR5cGVzIiwiZm9yd2FyZFJlZiIsIm93bk5hbWUiLCJlbmFibGVTY29wZUFQSSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIm1lbW8iLCJyZXNvbHZlRGlzcGF0Y2hlciIsIkNvbnRleHQiLCJyZWFsQ29udGV4dCIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyIsImVsZW1lbnRQcm9wcyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsIlByb3BUeXBlcyIsIl9uYW1lIiwidmFsaWRhdGVGcmFnbWVudFByb3BzIiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInR5cGVTdHJpbmciLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsImZyb3plbk9iamVjdCIsImNyZWF0ZUVsZW1lbnQkMSIsImNsb25lRWxlbWVudCQxIiwiY3JlYXRlRmFjdG9yeSIsIm9ubHkiLCJERUZBVUxUX1RIUkVBRF9JRCIsImludGVyYWN0aW9uSURDb3VudGVyIiwidGhyZWFkSURDb3VudGVyIiwidW5zdGFibGVfY2xlYXIiLCJ1bnN0YWJsZV9nZXRDdXJyZW50IiwidW5zdGFibGVfdHJhY2UiLCJ0aW1lc3RhbXAiLCJvbkludGVyYWN0aW9uVHJhY2VkIiwid3JhcHBlZEludGVyYWN0aW9ucyIsImhhc1J1biIsIndyYXBwZWQiLCJjYW5jZWwiLCJvbldvcmtDYW5jZWxlZCIsInN1YnNjcmliZXJzIiwidW5zdGFibGVfc3Vic2NyaWJlIiwidW5zdGFibGVfdW5zdWJzY3JpYmUiLCJkaWRDYXRjaEVycm9yIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZW5hYmxlUHJvZmlsaW5nIiwicmVxdWVzdEhvc3RDYWxsYmFjayIsInJlcXVlc3RIb3N0VGltZW91dCIsImNhbmNlbEhvc3RUaW1lb3V0IiwiaGFzUGVyZm9ybWFuY2VOb3ciLCJwZXJmb3JtYW5jZSIsImxvY2FsUGVyZm9ybWFuY2UiLCJsb2NhbERhdGUiLCJpbml0aWFsVGltZSIsIk1lc3NhZ2VDaGFubmVsIiwiX2NhbGxiYWNrIiwiX3RpbWVvdXRJRCIsIl9mbHVzaENhbGxiYWNrIiwiaGFzUmVtYWluaW5nVGltZSIsIm1zIiwidW5zdGFibGVfZm9yY2VGcmFtZVJhdGUiLCJfc2V0VGltZW91dCIsIl9jbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlzTWVzc2FnZUxvb3BSdW5uaW5nIiwic2NoZWR1bGVkSG9zdENhbGxiYWNrIiwidGFza1RpbWVvdXRJRCIsInlpZWxkSW50ZXJ2YWwiLCJkZWFkbGluZSIsImZwcyIsImZsb29yIiwicGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiaGFzVGltZVJlbWFpbmluZyIsImhhc01vcmVXb3JrIiwicG9ydCIsInBvc3RNZXNzYWdlIiwiY2hhbm5lbCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJoZWFwIiwic2lmdFVwIiwicGVlayIsInNpZnREb3duIiwicGFyZW50SW5kZXgiLCJsZWZ0SW5kZXgiLCJyaWdodEluZGV4IiwicmlnaHQiLCJkaWZmIiwic29ydEluZGV4IiwicnVuSWRDb3VudGVyIiwibWFpblRocmVhZElkQ291bnRlciIsInByb2ZpbGluZ1N0YXRlU2l6ZSIsInNoYXJlZFByb2ZpbGluZ0J1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiSW50MzJBcnJheSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiQXJyYXlCdWZmZXIiLCJwcm9maWxpbmdTdGF0ZSIsIlBSSU9SSVRZIiwiQ1VSUkVOVF9UQVNLX0lEIiwiQ1VSUkVOVF9SVU5fSUQiLCJRVUVVRV9TSVpFIiwiSU5JVElBTF9FVkVOVF9MT0dfU0laRSIsIk1BWF9FVkVOVF9MT0dfU0laRSIsImV2ZW50TG9nU2l6ZSIsImV2ZW50TG9nQnVmZmVyIiwiZXZlbnRMb2ciLCJldmVudExvZ0luZGV4IiwiVGFza1N0YXJ0RXZlbnQiLCJUYXNrQ29tcGxldGVFdmVudCIsIlRhc2tFcnJvckV2ZW50IiwiVGFza0NhbmNlbEV2ZW50IiwiVGFza1J1bkV2ZW50IiwiVGFza1lpZWxkRXZlbnQiLCJTY2hlZHVsZXJTdXNwZW5kRXZlbnQiLCJTY2hlZHVsZXJSZXN1bWVFdmVudCIsImxvZ0V2ZW50Iiwic3RvcExvZ2dpbmdQcm9maWxpbmdFdmVudHMiLCJuZXdFdmVudExvZyIsImJ1ZmZlciIsInN0YXJ0TG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cyIsIm1hcmtUYXNrU3RhcnQiLCJ0YXNrIiwibWFya1Rhc2tDb21wbGV0ZWQiLCJtYXJrVGFza0NhbmNlbGVkIiwibWFya1Rhc2tFcnJvcmVkIiwibWFya1Rhc2tSdW4iLCJtYXJrVGFza1lpZWxkIiwibWFya1NjaGVkdWxlclN1c3BlbmRlZCIsIm1hcmtTY2hlZHVsZXJVbnN1c3BlbmRlZCIsIm1heFNpZ25lZDMxQml0SW50IiwiSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQiLCJVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQiLCJOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCIsIkxPV19QUklPUklUWV9USU1FT1VUIiwiSURMRV9QUklPUklUWV9USU1FT1VUIiwidGFza1F1ZXVlIiwidGltZXJRdWV1ZSIsInRhc2tJZENvdW50ZXIiLCJjdXJyZW50VGFzayIsImN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNQZXJmb3JtaW5nV29yayIsImlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIiwiaXNIb3N0VGltZW91dFNjaGVkdWxlZCIsImFkdmFuY2VUaW1lcnMiLCJ0aW1lciIsInN0YXJ0VGltZSIsImlzUXVldWVkIiwiaGFuZGxlVGltZW91dCIsImZsdXNoV29yayIsImZpcnN0VGltZXIiLCJwcmV2aW91c1ByaW9yaXR5TGV2ZWwiLCJ3b3JrTG9vcCIsIl9jdXJyZW50VGltZSIsImRpZFVzZXJDYWxsYmFja1RpbWVvdXQiLCJjb250aW51YXRpb25DYWxsYmFjayIsImV2ZW50SGFuZGxlciIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwiZGVsYXkiLCJuZXdUYXNrIiwidW5zdGFibGVfcGF1c2VFeGVjdXRpb24iLCJ1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlIiwidW5zdGFibGVfUHJvZmlsaW5nIiwiZGVmIiwiRVJST1JfQ09ERVMiLCJTVEFUVVNfQ09ERVMiLCJvdmVycmlkZSIsInJlamVjdCIsInJlc29sdmUiLCJiYXNlNjRFbmNvZGVyIiwiX2hlYWRlciIsImlzT2JqZWN0XyIsInF1ZXJ5IiwicXVlcnlBcnJheSIsInJlYXNvbiIsInV0aWxzIiwiY3QiLCJoZWFkZXIiLCJwYXJhbXMiLCJwYXJ0cyIsImZvcm1hdHMiLCJkZWZhdWx0cyIsImFsbG93RG90cyIsImFycmF5TGltaXQiLCJjaGFyc2V0U2VudGluZWwiLCJjb21tYSIsImlnbm9yZVF1ZXJ5UHJlZml4IiwiaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzIiwicGFyYW1ldGVyTGltaXQiLCJwYXJzZUFycmF5cyIsInN0cmljdE51bGxIYW5kbGluZyIsIm51bWJlclN0ciIsInBhcnNlQXJyYXlWYWx1ZSIsImlzb1NlbnRpbmVsIiwicGFyc2VWYWx1ZXMiLCJwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzIiwiY2xlYW5TdHIiLCJsaW1pdCIsInNraXBJbmRleCIsImJyYWNrZXRFcXVhbHNQb3MiLCJlbmNvZGVkVmFsIiwicGFyc2VPYmplY3QiLCJjaGFpbiIsInZhbHVlc1BhcnNlZCIsImxlYWYiLCJjbGVhblJvb3QiLCJwYXJzZUtleXMiLCJwYXJzZVF1ZXJ5U3RyaW5nS2V5cyIsImdpdmVuS2V5IiwiYnJhY2tldHMiLCJzZWdtZW50IiwiZXhlYyIsIm5vcm1hbGl6ZVBhcnNlT3B0aW9ucyIsIm9wdHMiLCJ0ZW1wT2JqIiwibmV3T2JqIiwiYXJyYXlQcmVmaXhHZW5lcmF0b3JzIiwiaW5kaWNlcyIsInB1c2hUb0FycmF5IiwidmFsdWVPckFycmF5IiwidG9JU08iLCJ0b0lTT1N0cmluZyIsImRlZmF1bHRGb3JtYXQiLCJhZGRRdWVyeVByZWZpeCIsImVuY29kZVZhbHVlc09ubHkiLCJmb3JtYXR0ZXIiLCJzZXJpYWxpemVEYXRlIiwic2tpcE51bGxzIiwiaXNOb25OdWxsaXNoUHJpbWl0aXZlIiwiZ2VuZXJhdGVBcnJheVByZWZpeCIsImtleVZhbHVlIiwib2JqS2V5cyIsImtleVByZWZpeCIsIm5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMiLCJhcnJheUZvcm1hdCIsImpvaW5lZCIsIkJCU0Zvcm0iLCJvblBvc3QiLCJuYW1lQ2hhbmdlZCIsImJvZHlDaGFuZ2VkIiwicG9zdCIsIkJCU0FwcCIsIml0ZW1zIiwibG9hZExvZ3MiLCJsb2dzIiwiaXRlbXNIdG1sIiwiaDEiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmb250U2l6ZSIsInRleHRBbGlnbiIsIlJlYWN0RE9NIiwiZ2V0RWxlbWVudEJ5SWQiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0EsMkNBQTJDLGNBQWM7O1FBRXpEO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7O1FBRUE7UUFDQTs7Ozs7Ozs7OztBQ2hF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UUFBTCxFQUFMO0FBQUEsNkJBQWpCO0FBQUE7QUFBQTtBQURKLGlCQUhKO0FBTVE7QUFBQTtBQUFBO0FBQUtFO0FBQUw7QUFOUixhQURKO0FBVUg7Ozs7RUF2Q2dCdnBJLGdCQUFNeU0sUzs7QUEwQzNCLElBQU0rUyxTQUFTO0FBQ1hncUgsUUFBSTtBQUNBQyx5QkFBaUIsTUFEakI7QUFFQTk5RyxlQUFPLE9BRlA7QUFHQSs5RyxrQkFBVSxFQUhWO0FBSUE3dUgsaUJBQVM7QUFKVCxLQURPOztBQVFYOWUsVUFBTTtBQUNGOGUsaUJBQVMsRUFEUDtBQUVGbkMsZ0JBQVEsa0JBRk47QUFHRit3SCx5QkFBaUI7QUFIZixLQVJLO0FBYVhwSyxXQUFPO0FBQ0hzSyxtQkFBVztBQURSO0FBYkksQ0FBZjs7QUFrQkFDLG1CQUFTLzhILE1BQVQsQ0FDSSw4QkFBQyxNQUFELE9BREosRUFFSS9JLFNBQVMrbEksY0FBVCxDQUF3QixNQUF4QixDQUZKLEUiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZTUwN2E3MDE5NTFkYjdlZTdjYjIiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IDAgKi9cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zICYmIChvcHRpb25zLnBsYWluT2JqZWN0cyB8fCBvcHRpb25zLmFsbG93UHJvdG90eXBlcykpIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiAhaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJdGVtID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBtZXJnZSh0YXJnZXRJdGVtLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyLCBkZWNvZGVyLCBjaGFyc2V0KSB7XG4gICAgdmFyIHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgICB9XG4gICAgLy8gdXRmLThcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0ciwgZGVmYXVsdEVuY29kZXIsIGNoYXJzZXQpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHN0cjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgc3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGUoc3RyaW5nKS5yZXBsYWNlKC8ldVswLTlhLWZdezR9L2dpLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJTI2JTIzJyArIHBhcnNlSW50KCQwLnNsaWNlKDIpLCAxNikgKyAnJTNCJztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgYyA9PT0gMHgyRCAvLyAtXG4gICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cbiAgICAgICAgICAgIHx8IGMgPT09IDB4NUYgLy8gX1xuICAgICAgICAgICAgfHwgYyA9PT0gMHg3RSAvLyB+XG4gICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XG4gICAgICAgICAgICB8fCAoYyA+PSAweDQxICYmIGMgPD0gMHg1QSkgLy8gYS16XG4gICAgICAgICAgICB8fCAoYyA+PSAweDYxICYmIGMgPD0gMHg3QSkgLy8gQS1aXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgaGV4VGFibGVbY107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEMwIHwgKGMgPj4gNildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+PSAweEUwMDApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKCgoYyAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgJiAweDNGRikpO1xuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiAxMikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhLCBiKTtcbn07XG5cbnZhciBtYXliZU1hcCA9IGZ1bmN0aW9uIG1heWJlTWFwKHZhbCwgZm4pIHtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZuKHZhbFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIHJldHVybiBmbih2YWwpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXJyYXlUb09iamVjdDogYXJyYXlUb09iamVjdCxcbiAgICBhc3NpZ246IGFzc2lnbixcbiAgICBjb21iaW5lOiBjb21iaW5lLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXG4gICAgbWVyZ2U6IG1lcmdlXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdXBlcmFnZW50L34vcXMvbGliL3V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc2NoZWR1bGVyL2luZGV4LmpzIiwiLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9pcy1vYmplY3QuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBGb3JtYXQgPSB7XG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsLmFzc2lnbihcbiAgICB7XG4gICAgICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG4gICAgICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgRm9ybWF0XG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdXBlcmFnZW50L34vcXMvbGliL2Zvcm1hdHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxubGV0IHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXG4gICAgJ1VzaW5nIGJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQnXG4gICk7XG4gIHJvb3QgPSB0aGlzO1xufSBlbHNlIHtcbiAgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn1cblxuY29uc3QgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5jb25zdCBzYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1zYWZlLXN0cmluZ2lmeScpO1xuY29uc3QgcXMgPSByZXF1aXJlKCdxcycpO1xuY29uc3QgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuY29uc3QgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdChtZXRob2QsIHVybCk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmNvbnN0IHJlcXVlc3QgPSBleHBvcnRzO1xuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSAoKSA9PiB7XG4gIGlmIChcbiAgICByb290LlhNTEh0dHBSZXF1ZXN0ICYmXG4gICAgKCFyb290LmxvY2F0aW9uIHx8XG4gICAgICByb290LmxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonIHx8XG4gICAgICAhcm9vdC5BY3RpdmVYT2JqZWN0KVxuICApIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTtcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTtcbiAgfSBjYXRjaCB7fVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpO1xuICB9IGNhdGNoIHt9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUicpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltID8gKHMpID0+IHMudHJpbSgpIDogKHMpID0+IHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgY29uc3QgcGFpcnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpXG4gICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cblxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJKGtleSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4ge1xuICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGZvciAoY29uc3Qgc3Via2V5IGluIHZhbCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIHN1YmtleSkpXG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBgJHtrZXl9WyR7c3Via2V5fV1gLCB2YWxbc3Via2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJKGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGNvbnN0IHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIGxldCBwYWlyO1xuICBsZXQgcG9zO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgcGFpci5zbGljZShwb3MgKyAxKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgZm9ybTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcXMuc3RyaW5naWZ5LFxuICAnYXBwbGljYXRpb24vanNvbic6IHNhZmVTdHJpbmdpZnlcbn07XG5cbi8qKlxuICogRGVmYXVsdCBwYXJzZXJzLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2Vcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgY29uc3QgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgY29uc3QgZmllbGRzID0ge307XG4gIGxldCBpbmRleDtcbiAgbGV0IGxpbmU7XG4gIGxldCBmaWVsZDtcbiAgbGV0IHZhbDtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG1pbWVgIGlzIGpzb24gb3IgaGFzICtqc29uIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzSlNPTihtaW1lKSB7XG4gIC8vIHNob3VsZCBtYXRjaCAvanNvbiBvciAranNvblxuICAvLyBidXQgbm90IC9qc29uLXNlcVxuICByZXR1cm4gL1svK11qc29uKCR8W14tXFx3XSkvaS50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9XG4gICAgKHRoaXMucmVxLm1ldGhvZCAhPT0gJ0hFQUQnICYmXG4gICAgICAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8XG4gICAgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICBsZXQgeyBzdGF0dXMgfSA9IHRoaXMueGhyO1xuICAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICBzdGF0dXMgPSAyMDQ7XG4gIH1cblxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnM7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAodGhpcy50ZXh0ID09PSBudWxsICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID1cbiAgICAgIHRoaXMucmVxLm1ldGhvZCA9PT0gJ0hFQUQnXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGxldCBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcbiAgaWYgKHRoaXMucmVxLl9wYXJzZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXEuX3BhcnNlcih0aGlzLCBzdHIpO1xuICB9XG5cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCA+IDAgfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHsgcmVxIH0gPSB0aGlzO1xuICBjb25zdCB7IG1ldGhvZCB9ID0gcmVxO1xuICBjb25zdCB7IHVybCB9ID0gcmVxO1xuXG4gIGNvbnN0IG1zZyA9IGBjYW5ub3QgJHttZXRob2R9ICR7dXJsfSAoJHt0aGlzLnN0YXR1c30pYDtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7XG4gICAgfSBjYXRjaCAoZXJyXykge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGVycl87XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPVxuICAgICAgICAgIHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgOiBzZWxmLnhoci5yZXNwb25zZTtcbiAgICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICBsZXQgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgIHJlcy5zdGF0dXNUZXh0IHx8IHJlcy50ZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJfKSB7XG4gICAgICBuZXdfZXJyID0gZXJyXzsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9XG5cbiAgICAvLyAjMTAwMCBkb24ndCBjYXRjaCBlcnJvcnMgZnJvbSB0aGUgY2FsbGJhY2sgdG8gYXZvaWQgZG91YmxlIGNhbGxpbmcgaXRcbiAgICBpZiAobmV3X2Vycikge1xuICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkge1xuICAgIC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicgPyAnYmFzaWMnIDogJ2F1dG8nXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBiYXNpYyBhdXRoLCBidG9hIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXMuX2F1dGgodXNlciwgcGFzcywgb3B0aW9ucywgZW5jb2Rlcik7XG59O1xuXG4vKipcbiAqIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiAqICAgICAucXVlcnkoJ3NpemU9MTAnKVxuICogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xuICBpZiAodmFsKSB0aGlzLl9xdWVyeS5wdXNoKHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgb3B0aW9uc2AgKG9yIGZpbGVuYW1lKS5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZmllbGQsIGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKGZpZWxkLCBmaWxlLCBvcHRpb25zIHx8IGZpbGUubmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAnUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLidcbiAgKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnNvbGUud2FybignVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudDtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhO1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQnXG4gICk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGU7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBob3N0IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXMgYSBob3N0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gKFxuICAgIG9iaiAmJlxuICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgIUFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJ1xuICApO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50J1xuICAgICk7XG4gIH1cblxuICB0aGlzLl9lbmRDYWxsZWQgPSB0cnVlO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBxdWVyeXN0cmluZ1xuICB0aGlzLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nKCk7XG5cbiAgdGhpcy5fZW5kKCk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fc2V0VXBsb2FkVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgLy8gdXBsb2FkIHRpbWVvdXQgaXQncyB3b2tycyBvbmx5IGlmIGRlYWRsaW5lIHRpbWVvdXQgaXMgb2ZmXG4gIGlmICh0aGlzLl91cGxvYWRUaW1lb3V0ICYmICF0aGlzLl91cGxvYWRUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl91cGxvYWRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcihcbiAgICAgICAgJ1VwbG9hZCB0aW1lb3V0IG9mICcsXG4gICAgICAgIHNlbGYuX3VwbG9hZFRpbWVvdXQsXG4gICAgICAgICdFVElNRURPVVQnXG4gICAgICApO1xuICAgIH0sIHRoaXMuX3VwbG9hZFRpbWVvdXQpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpXG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soXG4gICAgICBuZXcgRXJyb3IoJ1RoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgZXZlbiBiZWZvcmUgLmVuZCgpIHdhcyBjYWxsZWQnKVxuICAgICk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKTtcbiAgY29uc3QgeyB4aHIgfSA9IHRoaXM7XG4gIGxldCBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVhZHlTdGF0ZSB9ID0geGhyO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuXG4gICAgaWYgKHJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgbGV0IHN0YXR1cztcbiAgICB0cnkge1xuICAgICAgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHN0YXR1cyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIGNvbnN0IGhhbmRsZVByb2dyZXNzID0gKGRpcmVjdGlvbiwgZSkgPT4ge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gKGUubG9hZGVkIC8gZS50b3RhbCkgKiAxMDA7XG5cbiAgICAgIGlmIChlLnBlcmNlbnQgPT09IDEwMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdXBsb2FkVGltZW91dFRpbWVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG5cbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJykpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdwcm9ncmVzcycsXG4gICAgICAgICAgaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgaWYgKHhoci51cGxvYWQpIHtcbiAgICB0aGlzLl9zZXRVcGxvYWRUaW1lb3V0KCk7XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKFxuICAgICF0aGlzLl9mb3JtRGF0YSAmJlxuICAgIHRoaXMubWV0aG9kICE9PSAnR0VUJyAmJlxuICAgIHRoaXMubWV0aG9kICE9PSAnSEVBRCcgJiZcbiAgICB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiZcbiAgICAhdGhpcy5faXNIb3N0KGRhdGEpXG4gICkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBsZXQgc2VyaWFsaXplID1cbiAgICAgIHRoaXMuX3NlcmlhbGl6ZXIgfHxcbiAgICAgIHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cblxuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gIH1cblxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xuICBmb3IgKGNvbnN0IGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKHRoaXMuaGVhZGVyW2ZpZWxkXSA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaGVhZGVyLCBmaWVsZCkpXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZGF0YSk7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gKCkgPT4gbmV3IEFnZW50KCk7XG5cblsnR0VUJywgJ1BPU1QnLCAnT1BUSU9OUycsICdQQVRDSCcsICdQVVQnLCAnREVMRVRFJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAodXJsLCBmbikge1xuICAgIGNvbnN0IHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKHJlcSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGUuZGVsZXRlO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3QuZGVsID0gZGVsO1xucmVxdWVzdC5kZWxldGUgPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vc3JjL2NsaWVudC5qcyIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcbnN0cmluZ2lmeS5zdGFibGVTdHJpbmdpZnkgPSBkZXRlcm1pbmlzdGljU3RyaW5naWZ5XG5cbnZhciBhcnIgPSBbXVxudmFyIHJlcGxhY2VyU3RhY2sgPSBbXVxuXG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIpIHtcbiAgZGVjaXJjKG9iaiwgJycsIFtdLCB1bmRlZmluZWQpXG4gIHZhciByZXNcbiAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKVxuICB9IGVsc2Uge1xuICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgfVxuICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gZGVjaXJjICh2YWwsIGssIHN0YWNrLCBwYXJlbnQpIHtcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKVxuICAgICAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6ICdbQ2lyY3VsYXJdJyB9KVxuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwga10pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFtrXSA9ICdbQ2lyY3VsYXJdJ1xuICAgICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgc3RhY2ssIHZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgc3RhY2ssIHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIpIHtcbiAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCAnJywgW10sIHVuZGVmaW5lZCkgfHwgb2JqXG4gIHZhciByZXNcbiAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICB9IGVsc2Uge1xuICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgfVxuICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIHN0YWNrLCBwYXJlbnQpIHtcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKVxuICAgICAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6ICdbQ2lyY3VsYXJdJyB9KVxuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwga10pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudFtrXSA9ICdbQ2lyY3VsYXJdJ1xuICAgICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIHN0YWNrLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgdmFyIHRtcCA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXVxuICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIHN0YWNrLCB2YWwpXG4gICAgICAgIHRtcFtrZXldID0gdmFsW2tleV1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICAgICAgICBwYXJlbnRba10gPSB0bXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXBcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyB3cmFwcyByZXBsYWNlciBmdW5jdGlvbiB0byBoYW5kbGUgdmFsdWVzIHdlIGNvdWxkbid0IHJlcGxhY2Vcbi8vIGFuZCBtYXJrIHRoZW0gYXMgW0NpcmN1bGFyXVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPSByZXBsYWNlciAhPT0gdW5kZWZpbmVkID8gcmVwbGFjZXIgOiBmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gdiB9XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2VyU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldXG4gICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgdmFsID0gJ1tDaXJjdWxhcl0nXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHRyYWNpbmcgPSByZXF1aXJlKCdzY2hlZHVsZXIvdHJhY2luZycpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbmlmICghUmVhY3QpIHtcbiAge1xuICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uXCIgKTtcbiAgfVxufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMjsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbiBvciBjbGFzc1xuXG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG52YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gMTk7XG52YXIgRnVuZGFtZW50YWxDb21wb25lbnQgPSAyMDtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIEJsb2NrID0gMjI7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjM7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjQ7XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7IC8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cblxudmFyIGVuYWJsZUZ1bmRhbWVudGFsQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biB3aGlsZSB1bm1vdW50aW5nIChvciBhZnRlciBpbiB0aGUgY2FzZSBvZiBwYXNzaXZlIGVmZmVjdHMpXG52YXIgd2FybkFib3V0U3RyaW5nUmVmcyA9IGZhbHNlO1xuXG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5cblxudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gIHt9IDsgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSArICdDYXB0dXJlJywgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSkge1xuICAgICAgZXJyb3IoJ0V2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IGRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxOYXRpdmVFdmVudHMuYWRkKGRlcGVuZGVuY2llc1tpXSk7XG4gIH1cbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggcHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZnVsbHkgZGlzYWJsZWQgamF2YXNjcmlwdDogVVJMcywgYW5kIGlmXG4gICAgICAgIC8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4gICAgICAgIHNhbml0aXplVVJMKCcnICsgZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuXG5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBvcGFxdWUgcmVmZXJlbmNlIElELCBpdCdzIGV4cGVjdGVkIHRoYXRcbiAgICAvLyB0aGUgbmV4dCBwcm9wIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzZXJ2ZXIgdmFsdWUsIHNvIGp1c3QgcmV0dXJuXG4gICAgLy8gZXhwZWN0ZWRcblxuXG4gICAgaWYgKGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9IC8vIElmIHRoZSBwcm9wIGlzbid0IGluIHRoZSBzcGVjaWFsIGxpc3QsIHRyZWF0IGl0IGFzIGEgc2ltcGxlIGF0dHJpYnV0ZS5cblxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cblxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiBhdHRyaWJ1dGUgdHlwZSBpcyBib29sZWFuLCB3ZSBrbm93IGZvciBzdXJlIGl0IHdvbid0IGJlIGFuIGV4ZWN1dGlvbiBzaW5rXG4gICAgICAvLyBhbmQgd2Ugd29uJ3QgcmVxdWlyZSBUcnVzdGVkIFR5cGUgaGVyZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHNhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgdmFyIG93bmVyID0gIGZpYmVyLl9kZWJ1Z093bmVyID8gZmliZXIuX2RlYnVnT3duZXIudHlwZSA6IG51bGwgO1xuICB2YXIgc291cmNlID0gIGZpYmVyLl9kZWJ1Z1NvdXJjZSA7XG5cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLl9yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5cblxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElzUmVuZGVyaW5nKCkge1xuICB7XG4gICAgcmV0dXJuIGlzUmVuZGVyaW5nO1xuICB9XG59XG5cbi8vIEZsb3cgZG9lcyBub3QgYWxsb3cgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgbW9zdCBub24tc3RyaW5nIHR5cGVzLiBUbyB3b3JrXG4vLyBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB3ZSB1c2UgYW4gb3BhcXVlIHR5cGUgdGhhdCBjYW4gb25seSBiZSBvYnRhaW5lZCBieVxuLy8gcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCBnZXRUb1N0cmluZ1ZhbHVlIGZpcnN0LlxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07IC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcblxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7IC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byAnICsgJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvICcgKyAndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8IC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgIC8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuICAgIC8vIGJsYW5rLXRleHQgYnV0dG9ucy5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuICAgIC8vIHByb3BlcnRpZXM6XG4gICAgLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDMuIE90aGVyd2lzZSB0aGVyZSBzaG91bGQgYmUgbm8gY2hhbmdlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgaXQgb25seSBjaGFuZ2VzIHdoZW4gaXQgbmVlZHNcbiAgICAvLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMsIGlzSHlkcmF0aW5nKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgdmFyIGlzQnV0dG9uID0gdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0JzsgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcblxuICAgIGlmIChpc0J1dHRvbiAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAge1xuICAgICAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2VcbiAgICAgICAgLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMy4gQW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHN5bmNocm9uaXplZCB0byB0aGUgcHJvcGVydHksXG4gICAgICAvLyBzbyB3ZSBhc3NpZ24gZGVmYXVsdFZhbHVlIHRvIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgLy8gYXNzaWdubWVudCBzdGVwIGFib3ZlLlxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9IC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cblxuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGJvdGggdGhlIGNoZWNrZWQgcHJvcGVydHkgYW5kXG4gICAgLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBjaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XG4gIH1cblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuXG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfSAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuXG5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuXG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG5cblxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG90aGVyTm9kZSk7XG5cbiAgICAgIGlmICghb3RoZXJQcm9wcykge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG5cblxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTsgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn0gLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKCAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDsgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZSBwYXRoIHRvby5cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgY29kZSBwYXRoIGFib3ZlLCBidXQgcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgICAvLyBXYXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZSBzbyB0aGF0IGNsaWVudCBhbmQgaHlkcmF0aW9uIGFyZSBjb25zaXN0ZW50LlxuICAgIC8vIFRPRE86IHRoaXMgc2VlbXMgbGlrZSBpdCBjb3VsZCBjYXVzZSBhIERFVi1vbmx5IHRocm93IGZvciBoeWRyYXRpb25cbiAgICAvLyBpZiBjaGlsZHJlbiBjb250YWlucyBhIG5vbi1lbGVtZW50IG9iamVjdC4gV2Ugc2hvdWxkIHRyeSB0byBhdm9pZCB0aGF0LlxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnICYmIHByb3BzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuXG5cbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcblxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0sIHByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgaWYgKCEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIiApO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cblxuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgIGlmICghKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gdG9TdHJpbmcodmFsdWUpOyAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsICYmIG5vZGUuZGVmYXVsdFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDsgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG5cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSAnJyAmJiB0ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcpIHtcblxuICAgIGlmICghKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgICAgIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgICAgIC8vIHRoZSB0YXJnZXQgbm9kZVxuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sLnZhbHVlT2YoKS50b1N0cmluZygpICsgJzwvc3ZnPic7XG4gICAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn0pO1xuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbJ2FuaW1hdGlvbkRlbGF5JywgJ2FuaW1hdGlvbkRpcmVjdGlvbicsICdhbmltYXRpb25EdXJhdGlvbicsICdhbmltYXRpb25GaWxsTW9kZScsICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhbmltYXRpb25OYW1lJywgJ2FuaW1hdGlvblBsYXlTdGF0ZScsICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICBiYWNrZ3JvdW5kOiBbJ2JhY2tncm91bmRBdHRhY2htZW50JywgJ2JhY2tncm91bmRDbGlwJywgJ2JhY2tncm91bmRDb2xvcicsICdiYWNrZ3JvdW5kSW1hZ2UnLCAnYmFja2dyb3VuZE9yaWdpbicsICdiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknLCAnYmFja2dyb3VuZFJlcGVhdCcsICdiYWNrZ3JvdW5kU2l6ZSddLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFsnYmFja2dyb3VuZFBvc2l0aW9uWCcsICdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sXG4gIGJvcmRlcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCcsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tFbmQ6IFsnYm9yZGVyQmxvY2tFbmRDb2xvcicsICdib3JkZXJCbG9ja0VuZFN0eWxlJywgJ2JvcmRlckJsb2NrRW5kV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tTdGFydDogWydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCAnYm9yZGVyQmxvY2tTdGFydFN0eWxlJywgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCddLFxuICBib3JkZXJCb3R0b206IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyQm90dG9tV2lkdGgnXSxcbiAgYm9yZGVyQ29sb3I6IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyVG9wQ29sb3InXSxcbiAgYm9yZGVySW1hZ2U6IFsnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VSZXBlYXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVNvdXJjZScsICdib3JkZXJJbWFnZVdpZHRoJ10sXG4gIGJvcmRlcklubGluZUVuZDogWydib3JkZXJJbmxpbmVFbmRDb2xvcicsICdib3JkZXJJbmxpbmVFbmRTdHlsZScsICdib3JkZXJJbmxpbmVFbmRXaWR0aCddLFxuICBib3JkZXJJbmxpbmVTdGFydDogWydib3JkZXJJbmxpbmVTdGFydENvbG9yJywgJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCddLFxuICBib3JkZXJMZWZ0OiBbJ2JvcmRlckxlZnRDb2xvcicsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyTGVmdFdpZHRoJ10sXG4gIGJvcmRlclJhZGl1czogWydib3JkZXJCb3R0b21MZWZ0UmFkaXVzJywgJ2JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzJywgJ2JvcmRlclRvcExlZnRSYWRpdXMnLCAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnXSxcbiAgYm9yZGVyUmlnaHQ6IFsnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSxcbiAgYm9yZGVyU3R5bGU6IFsnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyVG9wU3R5bGUnXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGNvbHVtblJ1bGU6IFsnY29sdW1uUnVsZUNvbG9yJywgJ2NvbHVtblJ1bGVTdHlsZScsICdjb2x1bW5SdWxlV2lkdGgnXSxcbiAgY29sdW1uczogWydjb2x1bW5Db3VudCcsICdjb2x1bW5XaWR0aCddLFxuICBmbGV4OiBbJ2ZsZXhCYXNpcycsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJ10sXG4gIGZsZXhGbG93OiBbJ2ZsZXhEaXJlY3Rpb24nLCAnZmxleFdyYXAnXSxcbiAgZm9udDogWydmb250RmFtaWx5JywgJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCAnZm9udEtlcm5pbmcnLCAnZm9udExhbmd1YWdlT3ZlcnJpZGUnLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLCAnZm9udFdlaWdodCcsICdsaW5lSGVpZ2h0J10sXG4gIGZvbnRWYXJpYW50OiBbJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogWydncmlkQXV0b0NvbHVtbnMnLCAnZ3JpZEF1dG9GbG93JywgJ2dyaWRBdXRvUm93cycsICdncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFsnZ3JpZFRlbXBsYXRlQXJlYXMnLCAnZ3JpZFRlbXBsYXRlQ29sdW1ucycsICdncmlkVGVtcGxhdGVSb3dzJ10sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogWydtYXNrQ2xpcCcsICdtYXNrQ29tcG9zaXRlJywgJ21hc2tJbWFnZScsICdtYXNrTW9kZScsICdtYXNrT3JpZ2luJywgJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWScsICdtYXNrUmVwZWF0JywgJ21hc2tTaXplJ10sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogWyd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbJ3RyYW5zaXRpb25EZWxheScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndHJhbnNpdGlvblByb3BlcnR5JywgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICB3b3JkV3JhcDogWydvdmVyZmxvd1dyYXAnXVxufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cblxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWx1ZUVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbn1cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cblxuXG5mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKSB7XG4gIHZhciBleHBhbmRlZCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25naGFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cGFuZGVkW2xvbmdoYW5kc1tpXV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkO1xufVxuLyoqXG4gKiBXaGVuIG1peGluZyBzaG9ydGhhbmQgYW5kIGxvbmdoYW5kIHByb3BlcnR5IG5hbWVzLCB3ZSB3YXJuIGR1cmluZyB1cGRhdGVzIGlmXG4gKiB3ZSBleHBlY3QgYW4gaW5jb3JyZWN0IHJlc3VsdCB0byBvY2N1ci4gSW4gcGFydGljdWxhciwgd2Ugd2FybiBmb3I6XG4gKlxuICogVXBkYXRpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgb3ZlcndyaXR0ZW4pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdiYXonLCBmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnYmF6J1xuICogUmVtb3ZpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgbG9zdCB0b28pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICcnXG4gKiBSZW1vdmluZyBhIGxvbmdoYW5kIHByb3BlcnR5IChzaG91bGQgcmV2ZXJ0IHRvIHNob3J0aGFuZDsgZG9lc24ndCk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2Zvbyd9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnRWYXJpYW50ID0gJydcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRTdHlsZXMpIHtcbiAge1xuICAgIGlmICghbmV4dFN0eWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHBhbmRlZFVwZGF0ZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVVcGRhdGVzKTtcbiAgICB2YXIgZXhwYW5kZWRTdHlsZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7XG4gICAgdmFyIHdhcm5lZEFib3V0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXhwYW5kZWRVcGRhdGVzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxLZXkgPSBleHBhbmRlZFVwZGF0ZXNba2V5XTtcbiAgICAgIHZhciBjb3JyZWN0T3JpZ2luYWxLZXkgPSBleHBhbmRlZFN0eWxlc1trZXldO1xuXG4gICAgICBpZiAoY29ycmVjdE9yaWdpbmFsS2V5ICYmIG9yaWdpbmFsS2V5ICE9PSBjb3JyZWN0T3JpZ2luYWxLZXkpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvcmlnaW5hbEtleSArICcsJyArIGNvcnJlY3RPcmlnaW5hbEtleTtcblxuICAgICAgICBpZiAod2FybmVkQWJvdXRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5lZEFib3V0W3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJyArICdjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcgKyBcImF2b2lkIHRoaXMsIGRvbid0IG1peCBzaG9ydGhhbmQgYW5kIG5vbi1zaG9ydGhhbmQgcHJvcGVydGllcyBcIiArICdmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcgKyAnc2VwYXJhdGUgdmFsdWVzLicsIGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKSA/ICdSZW1vdmluZycgOiAnVXBkYXRpbmcnLCBvcmlnaW5hbEtleSwgY29ycmVjdE9yaWdpbmFsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbnZhciBJU19SRVBMQVlFRCA9IDEgPDwgNDtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRmFsbGJhY2sgdG8gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCBmb3IgSUU5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdzsgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH0gLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcblxuXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgcmVzdG9yZUltcGwgPSBudWxsO1xudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHJlc3RvcmVJbXBsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbigpIG5lZWRzIHRvIGJlIGNhbGxlZCB0byBoYW5kbGUgYSB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGRpc2NyZXRlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xufTtcblxudmFyIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwgPSBiYXRjaGVkVXBkYXRlc0ltcGw7XG52YXIgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuXG4gIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkRXZlbnRVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIGlmIChpc0JhdGNoaW5nRXZlbnRVcGRhdGVzKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGEsIGIpO1xuICB9XG5cbiAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXIgPSBpc0luc2lkZUV2ZW50SGFuZGxlcjtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGRpc2NyZXRlVXBkYXRlc0ltcGwoZm4sIGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gcHJldklzSW5zaWRlRXZlbnRIYW5kbGVyO1xuXG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlc0lmTmVlZGVkKHRpbWVTdGFtcCkge1xuICB7XG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsIF9kaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwpIHtcbiAgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRVcGRhdGVzSW1wbDtcbiAgZGlzY3JldGVVcGRhdGVzSW1wbCA9IF9kaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwgPSBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGBcIiArIHJlZ2lzdHJhdGlvbk5hbWUgKyBcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIgKyB0eXBlb2YgbGlzdGVuZXIgKyBcImAgdHlwZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAoISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Nyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcblxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cbiAgICAgIGlmICghZGlkQ2FsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCByZWFsbHkgd3JvbmcsIGFuZCBvdXIgZXZlbnQgd2FzIG5vdCBkaXNwYXRjaGVkLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NzM0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBwcm9kdWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICByZXR1cm4gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbnZhciBoYXNFcnJvciA9IGZhbHNlO1xudmFyIGNhdWdodEVycm9yID0gbnVsbDsgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cblxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG52YXIgcmVwb3J0ZXIgPSB7XG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBoYXNFcnJvciA9IGZhbHNlO1xuICBjYXVnaHRFcnJvciA9IG51bGw7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMS5hcHBseShyZXBvcnRlciwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9cblxuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5mdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuNjtcbnZhciBEZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG44O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyOyAvLyBUT0RPIChlZmZlY3RzKSBSZW1vdmUgdGhpcyBiaXQgb25jZSB0aGUgbmV3IHJlY29uY2lsZXIgaXMgc3luY2VkIHRvIHRoZSBvbGQuXG5cbnZhciBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXYgPVxuLyogICAgICovXG44MTkyO1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgSHlkcmF0aW5nQW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuMTAyODsgLy8gUGFzc2l2ZSAmIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcblxudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgKi9cbjkzMjsgLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMjA0NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xNjM4NDsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoIShnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoIShuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYS5hbHRlcm5hdGUgPT09IGIpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoIShhLnRhZyA9PT0gSG9zdFJvb3QpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH0gLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcblxuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRvZXNGaWJlckNvbnRhaW4ocGFyZW50RmliZXIsIGNoaWxkRmliZXIpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZEZpYmVyO1xuICB2YXIgcGFyZW50RmliZXJBbHRlcm5hdGUgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50RmliZXIgfHwgbm9kZSA9PT0gcGFyZW50RmliZXJBbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb247XG5mdW5jdGlvbiBzZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGZuO1xufVxudmFyIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkgPSBmbjtcbn0gLy8gVE9ETzogVXBncmFkZSB0aGlzIGRlZmluaXRpb24gb25jZSB3ZSdyZSBvbiBhIG5ld2VyIHZlcnNpb24gb2YgRmxvdyB0aGF0XG52YXIgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlOyAvLyBUaGUgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzIHRvIGJlIHJlcGxheWVkLlxuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHMgPSBbXTsgLy8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxuXG52YXIgcXVldWVkRm9jdXMgPSBudWxsO1xudmFyIHF1ZXVlZERyYWcgPSBudWxsO1xudmFyIHF1ZXVlZE1vdXNlID0gbnVsbDsgLy8gRm9yIHBvaW50ZXIgZXZlbnRzIHRoZXJlIGNhbiBiZSBvbmUgbGF0ZXN0IGV2ZW50IHBlciBwb2ludGVySWQuXG5cbnZhciBxdWV1ZWRQb2ludGVycyA9IG5ldyBNYXAoKTtcbnZhciBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCk7IC8vIFdlIGNvdWxkIGNvbnNpZGVyIHJlcGxheWluZyBzZWxlY3Rpb25jaGFuZ2UgYW5kIHRvdWNobW92ZXMgdG9vLlxuXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW107XG5mdW5jdGlvbiBoYXNRdWV1ZWREaXNjcmV0ZUV2ZW50cygpIHtcbiAgcmV0dXJuIHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDA7XG59XG52YXIgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2V1cCcsICd0b3VjaGNhbmNlbCcsICd0b3VjaGVuZCcsICd0b3VjaHN0YXJ0JywgJ2F1eGNsaWNrJywgJ2RibGNsaWNrJywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcnVwJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnY29tcG9zaXRpb25lbmQnLCAnY29tcG9zaXRpb25zdGFydCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ2lucHV0JywgJ3RleHRJbnB1dCcsIC8vIEludGVudGlvbmFsbHkgY2FtZWxDYXNlXG4nY29weScsICdjdXQnLCAncGFzdGUnLCAnY2xpY2snLCAnY2hhbmdlJywgJ2NvbnRleHRtZW51JywgJ3Jlc2V0JywgJ3N1Ym1pdCddO1xuZnVuY3Rpb24gaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyB8IElTX1JFUExBWUVELFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRDb250YWluZXJzOiBbdGFyZ2V0Q29udGFpbmVyXVxuICB9O1xufVxuXG5mdW5jdGlvbiBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgcXVldWVkRGlzY3JldGVFdmVudHMucHVzaChxdWV1ZWRFdmVudCk7XG59IC8vIFJlc2V0cyB0aGUgcmVwbGF5aW5nIGZvciB0aGlzIHR5cGUgb2YgY29udGludW91cyBldmVudCB0byBubyBldmVudC5cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5sYW5lUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7IC8vIFdlIGRvbid0IGN1cnJlbnRseSBoYXZlIGEgd2F5IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZlxuICAgICAgICAgIC8vIGEgcm9vdCBvdGhlciB0aGFuIHN5bmMuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBxdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuXG4gIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQocXVldWVkRXZlbnQuZG9tRXZlbnROYW1lLCBxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICB2YXIgX2ZpYmVyMyA9IGdldEluc3RhbmNlRnJvbU5vZGUobmV4dEJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIzICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjMpO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxuXG5cbiAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LCBrZXksIG1hcCkge1xuICBpZiAoYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkpIHtcbiAgICBtYXAuZGVsZXRlKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIEZpcnN0IHJlcGxheSBkaXNjcmV0ZSBldmVudHMuXG5cbiAgd2hpbGUgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dERpc2NyZXRlRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXTtcblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICAvLyBJbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2YgdGhpcyBib3VuZGFyeSB0byB1bmJsb2NrXG4gICAgICAvLyB0aGUgbmV4dCBkaXNjcmV0ZSBldmVudC5cbiAgICAgIHZhciBfZmliZXI0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKF9maWJlcjQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IG5leHREaXNjcmV0ZUV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChuZXh0RGlzY3JldGVFdmVudC5kb21FdmVudE5hbWUsIG5leHREaXNjcmV0ZUV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmV4dERpc2NyZXRlRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICAgIG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3ZlIHN1Y2Nlc3NmdWxseSByZXBsYXllZCB0aGUgZmlyc3QgZXZlbnQuIExldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgfSAvLyBOZXh0IHJlcGxheSBhbnkgY29udGludW91cyBldmVudHMuXG5cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpIHtcbiAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKSB7XG4gICAgcXVldWVkRHJhZyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpIHtcbiAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gIH1cblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG5cbiAgICBpZiAoIWhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSB0cnVlOyAvLyBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGF0dGVtcHQgcmVwbGF5aW5nIGFzIG1hbnkgZXZlbnRzIGFzIGFyZVxuICAgICAgLy8gbm93IHVuYmxvY2tlZC4gVGhpcyBmaXJzdCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdW5ibG9ja2VkIHlldC5cbiAgICAgIC8vIFdlIGNvdWxkIGNoZWNrIGl0IGVhcmx5IHRvIGF2b2lkIHNjaGVkdWxpbmcgYW4gdW5uZWNlc3NhcnkgY2FsbGJhY2suXG5cbiAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSwgcmVwbGF5VW5ibG9ja2VkRXZlbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgLy8gTWFyayBhbnl0aGluZyB0aGF0IHdhcyBibG9ja2VkIG9uIHRoaXMgYXMgbm8gbG9uZ2VyIGJsb2NrZWRcbiAgLy8gYW5kIGVsaWdpYmxlIGZvciBhIHJlcGxheS5cbiAgaWYgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRGlzY3JldGVFdmVudHNbMF0sIHVuYmxvY2tlZCk7IC8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3NcbiAgICAvLyB3b3J0aCBpdCBiZWNhdXNlIHdlIGV4cGVjdCB2ZXJ5IGZldyBkaXNjcmV0ZSBldmVudHMgdG8gcXVldWUgdXAgYW5kIG9uY2VcbiAgICAvLyB3ZSBhcmUgYWN0dWFsbHkgZnVsbHkgdW5ibG9ja2VkIGl0IHdpbGwgYmUgZmFzdCB0byByZXBsYXkgdGhlbS5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZWRFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzW2ldO1xuXG4gICAgICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZE1vdXNlLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgdmFyIHVuYmxvY2sgPSBmdW5jdGlvbiAocXVldWVkRXZlbnQpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpO1xuICB9O1xuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2godW5ibG9jayk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07XG5cbiAgICBpZiAocXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdO1xuXG4gICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KG5leHRFeHBsaWNpdFRhcmdldCk7XG5cbiAgICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHVuYmxvY2tlZC5cbiAgICAgICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50ID0gMDtcbnZhciBVc2VyQmxvY2tpbmdFdmVudCA9IDE7XG52YXIgQ29udGludW91c0V2ZW50ID0gMjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7XG52YXIgZXZlbnRQcmlvcml0aWVzID0gbmV3IE1hcCgpOyAvLyBXZSBzdG9yZSBtb3N0IG9mIHRoZSBldmVudHMgaW4gdGhpcyBtb2R1bGUgaW4gcGFpcnMgb2YgdHdvIHN0cmluZ3Mgc28gd2UgY2FuIHJlLXVzZVxuLy8gdGhlIGNvZGUgcmVxdWlyZWQgdG8gYXBwbHkgdGhlIHNhbWUgbG9naWMgZm9yIGV2ZW50IHByaW9yaXRpemF0aW9uIGFuZCB0aGF0IG9mIHRoZVxuLy8gU2ltcGxlRXZlbnRQbHVnaW4uIFRoaXMgY29tcGxpY2F0ZXMgdGhpbmdzIHNsaWdodGx5LCBidXQgdGhlIGFpbSBpcyB0byByZWR1Y2UgY29kZVxuLy8gZHVwbGljYXRpb24gKGZvciB3aGljaCB0aGVyZSB3b3VsZCBiZSBxdWl0ZSBhIGJpdCkuIEZvciB0aGUgZXZlbnRzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbi8vIGZvciB0aGUgU2ltcGxlRXZlbnRQbHVnaW4gKG90aGVyRGlzY3JldGVFdmVudHMpIHdlIHByb2Nlc3MgdGhlbSBzZXBhcmF0ZWx5IGFzIGFuXG4vLyBhcnJheSBvZiB0b3AgbGV2ZWwgZXZlbnRzLlxuLy8gTGFzdGx5LCB3ZSBpZ25vcmUgcHJldHRpZXIgc28gd2UgY2FuIGtlZXAgdGhlIGZvcm1hdHRpbmcgc2FuZS5cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgZGlzY3JldGVFdmVudFBhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2NhbmNlbCcsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xpY2snLCAnY2xvc2UnLCAnY2xvc2UnLCAnY29udGV4dG1lbnUnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjb3B5JywgJ2N1dCcsICdjdXQnLCAnYXV4Y2xpY2snLCAnYXV4Q2xpY2snLCAnZGJsY2xpY2snLCAnZG91YmxlQ2xpY2snLCAvLyBDYXJlZnVsIVxuJ2RyYWdlbmQnLCAnZHJhZ0VuZCcsICdkcmFnc3RhcnQnLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHJvcCcsICdmb2N1c2luJywgJ2ZvY3VzJywgLy8gQ2FyZWZ1bCFcbidmb2N1c291dCcsICdibHVyJywgLy8gQ2FyZWZ1bCFcbidpbnB1dCcsICdpbnB1dCcsICdpbnZhbGlkJywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlEb3duJywgJ2tleXByZXNzJywgJ2tleVByZXNzJywgJ2tleXVwJywgJ2tleVVwJywgJ21vdXNlZG93bicsICdtb3VzZURvd24nLCAnbW91c2V1cCcsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheScsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlckRvd24nLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJVcCcsICdyYXRlY2hhbmdlJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzZXQnLCAnc2Vla2VkJywgJ3NlZWtlZCcsICdzdWJtaXQnLCAnc3VibWl0JywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoRW5kJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVjaGFuZ2UnLCAndm9sdW1lQ2hhbmdlJ107XG52YXIgb3RoZXJEaXNjcmV0ZUV2ZW50cyA9IFsnY2hhbmdlJywgJ3NlbGVjdGlvbmNoYW5nZScsICd0ZXh0SW5wdXQnLCAnY29tcG9zaXRpb25zdGFydCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnVwZGF0ZSddO1xuXG5cbnZhciB1c2VyQmxvY2tpbmdQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydkcmFnJywgJ2RyYWcnLCAnZHJhZ2VudGVyJywgJ2RyYWdFbnRlcicsICdkcmFnZXhpdCcsICdkcmFnRXhpdCcsICdkcmFnbGVhdmUnLCAnZHJhZ0xlYXZlJywgJ2RyYWdvdmVyJywgJ2RyYWdPdmVyJywgJ21vdXNlbW92ZScsICdtb3VzZU1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VPdXQnLCAnbW91c2VvdmVyJywgJ21vdXNlT3ZlcicsICdwb2ludGVybW92ZScsICdwb2ludGVyTW92ZScsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlcm92ZXInLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3Njcm9sbCcsICd0b2dnbGUnLCAndG9nZ2xlJywgJ3RvdWNobW92ZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnd2hlZWwnXTsgLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnYWJvcnQnLCAnYWJvcnQnLCBBTklNQVRJT05fRU5ELCAnYW5pbWF0aW9uRW5kJywgQU5JTUFUSU9OX0lURVJBVElPTiwgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsIEFOSU1BVElPTl9TVEFSVCwgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhbnBsYXknLCAnY2FuUGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdjYW5QbGF5VGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlbmRlZCcsICdlcnJvcicsICdlcnJvcicsICdnb3Rwb2ludGVyY2FwdHVyZScsICdnb3RQb2ludGVyQ2FwdHVyZScsICdsb2FkJywgJ2xvYWQnLCAnbG9hZGVkZGF0YScsICdsb2FkZWREYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdsb2FkU3RhcnQnLCAnbG9zdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdwbGF5aW5nJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd0aW1lVXBkYXRlJywgVFJBTlNJVElPTl9FTkQsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnd2FpdGluZyddO1xuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqXG4gKiBpbnRvXG4gKlxuICogdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKFtcbiAqICAgWydhYm9ydCcsICdvbkFib3J0J10sXG4gKiBdKTtcbiAqXG4gKiBhbmQgcmVnaXN0ZXJzIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoZXZlbnRUeXBlcywgcHJpb3JpdHkpIHtcbiAgLy8gQXMgdGhlIGV2ZW50IHR5cGVzIGFyZSBpbiBwYWlycyBvZiB0d28sIHdlIG5lZWQgdG8gaXRlcmF0ZVxuICAvLyB0aHJvdWdoIGluIHR3b3MuIFRoZSBldmVudHMgYXJlIGluIHBhaXJzIG9mIHR3byB0byBzYXZlIGNvZGVcbiAgLy8gYW5kIGltcHJvdmUgaW5pdCBwZXJmIG9mIHByb2Nlc3NpbmcgdGhpcyBhcnJheSwgYXMgaXQgd2lsbFxuICAvLyByZXN1bHQgaW4gZmFyIGZld2VyIG9iamVjdCBhbGxvY2F0aW9ucyBhbmQgcHJvcGVydHkgYWNjZXNzZXNcbiAgLy8gaWYgd2Ugb25seSB1c2UgdGhyZWUgYXJyYXlzIHRvIHByb2Nlc3MgYWxsIHRoZSBjYXRlZ29yaWVzIG9mXG4gIC8vIGluc3RlYWQgb2YgdHVwbGVzLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdG9wRXZlbnQgPSBldmVudFR5cGVzW2ldO1xuICAgIHZhciBldmVudCA9IGV2ZW50VHlwZXNbaSArIDFdO1xuICAgIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KHRvcEV2ZW50LCBwcmlvcml0eSk7XG4gICAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KHRvcEV2ZW50LCByZWFjdE5hbWUpO1xuICAgIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFt0b3BFdmVudF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEV2ZW50UHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KGV2ZW50VHlwZXNbaV0sIHByaW9yaXR5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5Rm9yUGx1Z2luU3lzdGVtKGRvbUV2ZW50TmFtZSkge1xuICB2YXIgcHJpb3JpdHkgPSBldmVudFByaW9yaXRpZXMuZ2V0KGRvbUV2ZW50TmFtZSk7IC8vIERlZmF1bHQgdG8gYSBDb250aW51b3VzRXZlbnQuIE5vdGU6IHdlIG1pZ2h0XG4gIC8vIHdhbnQgdG8gd2FybiBpZiB3ZSBjYW4ndCBkZXRlY3QgdGhlIHByaW9yaXR5XG4gIC8vIGZvciB0aGUgZXZlbnQuXG5cbiAgcmV0dXJuIHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyBDb250aW51b3VzRXZlbnQgOiBwcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnRzKCkge1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgRGlzY3JldGVFdmVudCk7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIFVzZXJCbG9ja2luZ0V2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoY29udGludW91c1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIENvbnRpbnVvdXNFdmVudCk7XG4gIHNldEV2ZW50UHJpb3JpdGllcyhvdGhlckRpc2NyZXRlRXZlbnRzLCBEaXNjcmV0ZUV2ZW50KTtcbn1cblxudmFyIFNjaGVkdWxlcl9ub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDk4O1xudmFyIE5vcm1hbFByaW9yaXR5ID0gOTc7XG52YXIgTG93UHJpb3JpdHkgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkgPSA5NTsgLy8gTm9Qcmlvcml0eSBpcyB0aGUgYWJzZW5jZSBvZiBwcmlvcml0eS4gQWxzbyBSZWFjdC1vbmx5LlxuXG52YXIgTm9Qcmlvcml0eSA9IDkwO1xudmFyIGluaXRpYWxUaW1lTXMgPSBTY2hlZHVsZXJfbm93KCk7IC8vIElmIHRoZSBpbml0aWFsIHRpbWVzdGFtcCBpcyByZWFzb25hYmx5IHNtYWxsLCB1c2UgU2NoZWR1bGVyJ3MgYG5vd2AgZGlyZWN0bHkuXG5cbnZhciBTeW5jTGFuZVByaW9yaXR5ID0gMTU7XG52YXIgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkgPSAxNDtcbnZhciBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTM7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eSA9IDEyO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDExO1xudmFyIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSA9IDEwO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA5O1xudmFyIERlZmF1bHRMYW5lUHJpb3JpdHkgPSA4O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eSA9IDc7XG52YXIgVHJhbnNpdGlvblByaW9yaXR5ID0gNjtcbnZhciBSZXRyeUxhbmVQcmlvcml0eSA9IDU7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gNDtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMztcbnZhciBJZGxlTGFuZVByaW9yaXR5ID0gMjtcbnZhciBPZmZzY3JlZW5MYW5lUHJpb3JpdHkgPSAxO1xudmFyIE5vTGFuZVByaW9yaXR5ID0gMDtcbnZhciBUb3RhbExhbmVzID0gMzE7XG52YXIgTm9MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBTeW5jQmF0Y2hlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICovXG4yO1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgKi9cbjQ7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjQ7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgKi9cbjMyO1xudmFyIElucHV0Q29udGludW91c0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjE5MjtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgRGVmYXVsdExhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zNTg0O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIFRyYW5zaXRpb25MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxODYxMTI7XG52YXIgUmV0cnlMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjI5MTQ1NjA7XG52YXIgU29tZVJldHJ5TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBOb25JZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI3O1xudmFyIElkbGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODtcbnZhciBJZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG44MDUzMDYzNjg7XG52YXIgT2Zmc2NyZWVuTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTA3Mzc0MTgyNDtcbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xuZnVuY3Rpb24gc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShuZXdMYW5lUHJpb3JpdHkpIHtcbn0gLy8gXCJSZWdpc3RlcnNcIiB1c2VkIHRvIFwicmV0dXJuXCIgbXVsdGlwbGUgdmFsdWVzXG4vLyBVc2VkIGJ5IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIGFuZCBnZXROZXh0TGFuZXM6XG5cbnZhciByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIGlmICgoU3luY0xhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNMYW5lO1xuICB9XG5cbiAgaWYgKChTeW5jQmF0Y2hlZExhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTeW5jQmF0Y2hlZExhbmU7XG4gIH1cblxuICBpZiAoKElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dERpc2NyZXRlTGFuZXMgPSBJbnB1dERpc2NyZXRlTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXREaXNjcmV0ZUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBpbnB1dERpc2NyZXRlTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dENvbnRpbnVvdXNMYW5lcyA9IElucHV0Q29udGludW91c0xhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlucHV0Q29udGludW91c0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0Q29udGludW91c0xhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIERlZmF1bHRIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgZGVmYXVsdExhbmVzID0gRGVmYXVsdExhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGRlZmF1bHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gZGVmYXVsdExhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTGFuZXMgPSBUcmFuc2l0aW9uTGFuZXMgJiBsYW5lcztcblxuICBpZiAodHJhbnNpdGlvbkxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MYW5lcztcbiAgfVxuXG4gIHZhciByZXRyeUxhbmVzID0gUmV0cnlMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChyZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBSZXRyeUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gcmV0cnlMYW5lcztcbiAgfVxuXG4gIGlmIChsYW5lcyAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJZGxlSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlkbGVMYW5lcyA9IElkbGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpZGxlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlkbGVMYW5lcztcbiAgfVxuXG4gIGlmICgoT2Zmc2NyZWVuTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gT2Zmc2NyZWVuTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAge1xuICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICByZXR1cm4gbGFuZXM7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNMYW5lUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBMb3dTY2hlZHVsZXJQcmlvcml0eSwgc29tZWhvdy4gTWF5YmUgdGhlIHNhbWUgbGFuZSBhcyBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVMYW5lUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5vTGFuZVByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBsYW5lUHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KGxhbmVQcmlvcml0eSkge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIEltbWVkaWF0ZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBVc2VyQmxvY2tpbmdQcmlvcml0eTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIERlZmF1bHRMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBSZXRyeUxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElkbGVMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb1ByaW9yaXR5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdXBkYXRlIHByaW9yaXR5OiBcIiArIGxhbmVQcmlvcml0eSArIFwiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIG5leHRMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdmFyIGV4cGlyZWRMYW5lcyA9IHJvb3QuZXhwaXJlZExhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBDaGVjayBpZiBhbnkgd29yayBoYXMgZXhwaXJlZC5cblxuICBpZiAoZXhwaXJlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgbmV4dExhbmVzID0gZXhwaXJlZExhbmVzO1xuICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAgIC8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxuICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgTm9uSWRsZUxhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICBpZiAobm9uSWRsZVVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7XG4gICAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvbmx5IHJlbWFpbmluZyB3b3JrIGlzIElkbGUuXG4gICAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh1bmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBoaWdoZXIgcHJpb3JpdHkgbGFuZXMsIHdlJ2xsIGluY2x1ZGUgdGhlbSBldmVuIGlmIHRoZXlcbiAgLy8gYXJlIHN1c3BlbmRlZC5cblxuXG4gIG5leHRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKG5leHRMYW5lcyk7IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgaWYgKHdpcExhbmVzICE9PSBOb0xhbmVzICYmIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiYgLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuICAvLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbiAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2lwTGFuZXMpO1xuICAgIHZhciB3aXBMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICAgIGlmIChuZXh0TGFuZVByaW9yaXR5IDw9IHdpcExhbmVQcmlvcml0eSkge1xuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IG5leHRMYW5lUHJpb3JpdHk7XG4gICAgfVxuICB9IC8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbiAgLy9cbiAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG4gIC8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4gIC8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4gIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuICAvLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4gIC8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbiAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG4gIC8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuICAvL1xuICAvLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCwgbGlrZVxuICAvLyB1c2VNdXRhYmxlU291cmNlLCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChlbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IG5leHRMYW5lcyAmIGVudGFuZ2xlZExhbmVzO1xuXG4gICAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICBuZXh0TGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG4gICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dExhbmVzO1xufVxuZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcykge1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBldmVudFRpbWUgPSBldmVudFRpbWVzW2luZGV4XTtcblxuICAgIGlmIChldmVudFRpbWUgPiBtb3N0UmVjZW50RXZlbnRUaW1lKSB7XG4gICAgICBtb3N0UmVjZW50RXZlbnRUaW1lID0gZXZlbnRUaW1lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgcmV0dXJuIG1vc3RSZWNlbnRFdmVudFRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBFeHBpcmF0aW9uIGhldXJpc3RpYyBpcyBjb25zdGFudCBwZXIgbGFuZSwgc28gY291bGQgdXNlIGEgbWFwLlxuICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lKTtcbiAgdmFyIHByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG5cbiAgaWYgKHByaW9yaXR5ID49IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLiBXaGVuXG4gICAgLy8gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZyB0aGVyZSdzXG4gICAgLy8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mIHN5bmNocm9ub3VzXG4gICAgLy8gdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlXG4gICAgLy8gc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0IGV4cGlyYXRpb25cbiAgICAvLyB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb24gZG9lcyBoYXBwZW4uXG4gICAgLy9cbiAgICAvLyBBbHNvIG5vdGUgdGhhdCwgaW4gdGhlIGNhc2Ugb2YgdXNlciBpbnB1dCBzcGVjaWZpY2FsbHksIHRoaXMgd2lsbCBzb29uIG5vXG4gICAgLy8gbG9uZ2VyIGJlIGFuIGlzc3VlIGJlY2F1c2Ugd2UgcGxhbiB0byBtYWtlIHVzZXIgaW5wdXQgc3luY2hyb25vdXMgYnlcbiAgICAvLyBkZWZhdWx0ICh1bnRpbCB5b3UgZW50ZXIgYHN0YXJ0VHJhbnNpdGlvbmAsIG9mIGNvdXJzZS4pXG4gICAgLy9cbiAgICAvLyBJZiB3ZXJlbid0IHBsYW5uaW5nIHRvIG1ha2UgdGhlc2UgdXBkYXRlcyBzeW5jaHJvbm91cyBzb29uIGFueXdheSwgSVxuICAgIC8vIHdvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBudW1iZXIgYSBjb25maWd1cmFibGUgcGFyYW1ldGVyLlxuICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgfSBlbHNlIGlmIChwcmlvcml0eSA+PSBUcmFuc2l0aW9uUHJpb3JpdHkpIHtcbiAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4gIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuICAvLyBvZiB0aGlzIGZ1bmN0aW9uLlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4gIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbiAgLy8gaXQgYXMgZXhwaXJlZCB0byBmb3JjZSBpdCB0byBmaW5pc2guXG5cbiAgdmFyIGxhbmVzID0gcGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gTm9UaW1lc3RhbXApIHtcbiAgICAgIC8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4gICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgIGlmICgobGFuZSAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcyB8fCAobGFuZSAmIHBpbmdlZExhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhpcyBsYW5lIGV4cGlyZWRcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gcmV0dXJuTmV4dExhbmVzUHJpb3JpdHkoKSB7XG4gIHJldHVybiByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIE5vbklkbGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBSZXRyeUxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIGEgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRVcGRhdGVMYW5lKGxhbmVQcmlvcml0eSwgd2lwTGFuZXMpIHtcbiAgc3dpdGNoIChsYW5lUHJpb3JpdHkpIHtcbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN5bmNMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmU7XG5cbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcblxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSW5wdXREaXNjcmV0ZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHRvIHRoZSBuZXh0IHByaW9yaXR5IGxldmVsXG4gICAgICAgICAgcmV0dXJuIGZpbmRVcGRhdGVMYW5lKElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk6XG4gICAgICB7XG4gICAgICAgIHZhciBfbGFuZTIgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dENvbnRpbnVvdXNMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMiA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoRGVmYXVsdExhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lMjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMyA9IHBpY2tBcmJpdHJhcnlMYW5lKERlZmF1bHRMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gSWYgYWxsIHRoZSBkZWZhdWx0IGxhbmVzIGFyZSBhbHJlYWR5IGJlaW5nIHdvcmtlZCBvbiwgbG9vayBmb3IgYVxuICAgICAgICAgIC8vIGxhbmUgaW4gdGhlIHRyYW5zaXRpb24gcmFuZ2UuXG4gICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICAgIGlmIChfbGFuZTMgPT09IE5vTGFuZSkge1xuICAgICAgICAgICAgLy8gQWxsIHRoZSB0cmFuc2l0aW9uIGxhbmVzIGFyZSB0YWtlbiwgdG9vLiBUaGlzIHNob3VsZCBiZSB2ZXJ5XG4gICAgICAgICAgICAvLyByYXJlLCBidXQgYXMgYSBsYXN0IHJlc29ydCwgcGljayBhIGRlZmF1bHQgbGFuZS4gVGhpcyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUzO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6IC8vIFNob3VsZCBiZSBoYW5kbGVkIGJ5IGZpbmRUcmFuc2l0aW9uTGFuZSBpbnN0ZWFkXG5cbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFJldHJ5TGFuZSBpbnN0ZWFkXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICB9XG4gIH1cbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRUcmFuc2l0aW9uTGFuZSh3aXBMYW5lcywgcGVuZGluZ0xhbmVzKSB7XG4gIC8vIEZpcnN0IGxvb2sgZm9yIGxhbmVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdW5jbGFpbWVkLCBpLmUuIGhhdmUgbm9cbiAgLy8gcGVuZGluZyB3b3JrLlxuICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyAmIH5wZW5kaW5nTGFuZXMpO1xuXG4gIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBJZiBhbGwgbGFuZXMgaGF2ZSBwZW5kaW5nIHdvcmssIGxvb2sgZm9yIGEgbGFuZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHdvcmtlZCBvbi5cbiAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIElmIGV2ZXJ5dGhpbmcgaXMgYmVpbmcgd29ya2VkIG9uLCBwaWNrIGFueSBsYW5lLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFJldHJ5TGFuZSh3aXBMYW5lcykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgZmluZFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoUmV0cnlMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgZmluZHMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgbm9uLXplcm8gYml0LlxuICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IE5vTGFuZXMgOiAxIDw8IGluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRFcXVhbE9ySGlnaGVyUHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICByZXR1cm4gKGdldExvd2VzdFByaW9yaXR5TGFuZShsYW5lcykgPDwgMSkgLSAxO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG4vLyB1cGRhdGVzKSB0byBhIGdyb3VwIG9mIGxhbmVzICh1c2VkIGZvciBmbHVzaGluZyB3b3JrKS5cblxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSkge1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLCBiKSB7XG4gIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgcmV0dXJuIGEgIT09IE5vTGFuZSAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIC8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuICAvLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG4gIHZhciBsYW5lTWFwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBUb3RhbExhbmVzOyBpKyspIHtcbiAgICBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIH1cblxuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVMYW5lLCBldmVudFRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTsgLy8gVE9ETzogVGhlb3JldGljYWxseSwgYW55IHVwZGF0ZSB0byBhbnkgbGFuZSBjYW4gdW5ibG9jayBhbnkgb3RoZXIgbGFuZS4gQnV0XG4gIC8vIGl0J3Mgbm90IHByYWN0aWNhbCB0byB0cnkgZXZlcnkgc2luZ2xlIHBvc3NpYmxlIGNvbWJpbmF0aW9uLiBXZSBuZWVkIGFcbiAgLy8gaGV1cmlzdGljIHRvIGRlY2lkZSB3aGljaCBsYW5lcyB0byBhdHRlbXB0IHRvIHJlbmRlciwgYW5kIGluIHdoaWNoIGJhdGNoZXMuXG4gIC8vIEZvciBub3csIHdlIHVzZSB0aGUgc2FtZSBoZXVyaXN0aWMgYXMgaW4gdGhlIG9sZCBFeHBpcmF0aW9uVGltZXMgbW9kZWw6XG4gIC8vIHJldHJ5IGFueSBsYW5lIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LCBidXQgZG9uJ3QgdHJ5IHVwZGF0ZXMgYXQgaGlnaGVyXG4gIC8vIHByaW9yaXR5IHdpdGhvdXQgYWxzbyBpbmNsdWRpbmcgdGhlIGxvd2VyIHByaW9yaXR5IHVwZGF0ZXMuIFRoaXMgd29ya3Mgd2VsbFxuICAvLyB3aGVuIGNvbnNpZGVyaW5nIHVwZGF0ZXMgYWNyb3NzIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMsIGJ1dCBpc24ndFxuICAvLyBzdWZmaWNpZW50IGZvciB1cGRhdGVzIHdpdGhpbiB0aGUgc2FtZSBwcmlvcml0eSwgc2luY2Ugd2Ugd2FudCB0byB0cmVhdFxuICAvLyB0aG9zZSB1cGRhdGVzIGFzIHBhcmFsbGVsLlxuICAvLyBVbnN1c3BlbmQgYW55IHVwZGF0ZSBhdCBlcXVhbCBvciBsb3dlciBwcmlvcml0eS5cblxuICB2YXIgaGlnaGVyUHJpb3JpdHlMYW5lcyA9IHVwZGF0ZUxhbmUgLSAxOyAvLyBUdXJucyAwYjEwMDAgaW50byAwYjAxMTFcblxuICByb290LnN1c3BlbmRlZExhbmVzICY9IGhpZ2hlclByaW9yaXR5TGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpIHtcbiAgcm9vdC5leHBpcmVkTGFuZXMgfD0gSW5wdXREaXNjcmV0ZUxhbmVzICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBJbnB1dERpc2NyZXRlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCB1cGRhdGVMYW5lKSB7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyB8PSB1cGRhdGVMYW5lICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gIHZhciBub0xvbmdlclBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV2ZW50VGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gZW50YW5nbGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcztcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLiBPbmx5IHVzZWQgb24gbGFuZXMsIHNvIGFzc3VtZSBpbnB1dCBpcyBhbiBpbnRlZ2VyLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayhsYW5lcykge1xuICBpZiAobGFuZXMgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGxhbmVzKSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSW50ZW50aW9uYWxseSBub3QgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB3b3VsZCB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3JcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgIHJ1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7IC8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cblxudmFyIF9lbmFibGVkID0gdHJ1ZTsgLy8gVGhpcyBpcyBleHBvcnRlZCBpbiBGQiBidWlsZHMgZm9yIHVzZSBieSBsZWdhY3kgRkIgbGF5ZXIgaW5mcmEuXG4vLyBXZSdkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgYnV0IGl0J3Mgbm90IGNsZWFyIGlmIHRoaXMgaXMgc2FmZS5cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgZXZlbnRQcmlvcml0eSA9IGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKTtcbiAgdmFyIGxpc3RlbmVyV3JhcHBlcjtcblxuICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICBjYXNlIERpc2NyZXRlRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaERpc2NyZXRlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250aW51b3VzRXZlbnQ6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQobmF0aXZlRXZlbnQudGltZVN0YW1wKTtcbiAgfVxuXG4gIGRpc2NyZXRlVXBkYXRlcyhkaXNwYXRjaEV2ZW50LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIHJ1bldpdGhQcmlvcml0eShVc2VyQmxvY2tpbmdQcmlvcml0eSQxLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhbGxvd1JlcGxheSA9IHRydWU7XG5cbiAge1xuICAgIC8vIFRPRE86IHJlcGxheWluZyBjYXB0dXJlIHBoYXNlIGV2ZW50cyBpcyBjdXJyZW50bHkgYnJva2VuXG4gICAgLy8gYmVjYXVzZSB3ZSB1c2VkIHRvIGRvIGl0IGR1cmluZyB0b3AtbGV2ZWwgbmF0aXZlIGJ1YmJsZSBoYW5kbGVyc1xuICAgIC8vIGJ1dCBub3cgd2UgdXNlIGRpZmZlcmVudCBidWJibGUgYW5kIGNhcHR1cmUgaGFuZGxlcnMuXG4gICAgLy8gSW4gZWFnZXIgbW9kZSwgd2UgYXR0YWNoIGNhcHR1cmUgbGlzdGVuZXJzIGVhcmx5LCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZmlsdGVyIHRoZW0gb3V0IHVudGlsIHdlIGZpeCB0aGUgbG9naWMgdG8gaGFuZGxlIHRoZW0gY29ycmVjdGx5LlxuICAgIC8vIFRoaXMgY291bGQndmUgYmVlbiBvdXRzaWRlIHRoZSBmbGFnIGJ1dCBJIHB1dCBpdCBpbnNpZGUgdG8gcmVkdWNlIHJpc2suXG4gICAgYWxsb3dSZXBsYXkgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpID09PSAwO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5ICYmIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkgJiYgaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUpKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzLCBhbmQgdGhpcyBpcyBhbm90aGVyIGRpc2NyZXRlXG4gICAgLy8gZXZlbnQsIHRoZW4gd2UgY2FuJ3QgZGlzcGF0Y2ggaXQgcmVnYXJkbGVzcyBvZiBpdHMgdGFyZ2V0LCBzaW5jZSB0aGV5XG4gICAgLy8gbmVlZCB0byBkaXNwYXRjaCBpbiBvcmRlci5cbiAgICBxdWV1ZURpc2NyZXRlRXZlbnQobnVsbCwgLy8gRmxhZ3MgdGhhdCB3ZSdyZSBub3QgYWN0dWFsbHkgYmxvY2tlZCBvbiBhbnl0aGluZyBhcyBmYXIgYXMgd2Uga25vdy5cbiAgICBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkIHRoaXMgZXZlbnQuXG4gICAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhbGxvd1JlcGxheSkge1xuICAgIGlmIChpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgIC8vIFRoaXMgdGhpcyB0byBiZSByZXBsYXllZCBsYXRlciBvbmNlIHRoZSB0YXJnZXQgaXMgYXZhaWxhYmxlLlxuICAgICAgcXVldWVEaXNjcmV0ZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG5lZWQgdG8gY2xlYXIgb25seSBpZiB3ZSBkaWRuJ3QgcXVldWUgYmVjYXVzZVxuICAgIC8vIHF1ZXVlaW5nIGlzIGFjY3VtbXVsYXRpdmUuXG5cblxuICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gVGhpcyBpcyBub3QgcmVwbGF5YWJsZSBzbyB3ZSdsbCBpbnZva2UgaXQgYnV0IHdpdGhvdXQgYSB0YXJnZXQsXG4gIC8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cblxuXG4gIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBudWxsLCB0YXJnZXRDb250YWluZXIpO1xufSAvLyBBdHRlbXB0IGRpc3BhdGNoaW5nIGFuIGV2ZW50LiBSZXR1cm5zIGEgU3VzcGVuc2VJbnN0YW5jZSBvciBDb250YWluZXIgaWYgaXQncyBibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICAvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyBhIHJlcGxheSBzb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgaXQgbWlnaHQgYmxvY2tcbiAgICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLlxuICAgICAgICAgIHJldHVybiBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAgICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAgICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgICAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcik7IC8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH0pO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIHJvb3QgPSBudWxsO1xudmFyIHN0YXJ0VGV4dCA9IG51bGw7XG52YXIgZmFsbGJhY2tUZXh0ID0gbnVsbDtcbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuXG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiByb290KSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWU7XG4gIH1cblxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2Fzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqL1xuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHsvLyBNb2Rlcm4gZXZlbnQgc3lzdGVtIGRvZXNuJ3QgdXNlIHBvb2xpbmcuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgfSk7XG5cbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgdmlldzogMCxcbiAgZGV0YWlsOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKTtcbnZhciBsYXN0TW92ZW1lbnRYO1xudmFyIGxhc3RNb3ZlbWVudFk7XG52YXIgbGFzdE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KSB7XG4gIGlmIChldmVudCAhPT0gbGFzdE1vdXNlRXZlbnQpIHtcbiAgICBpZiAobGFzdE1vdXNlRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IDA7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gMDtcbiAgICB9XG5cbiAgICBsYXN0TW91c2VFdmVudCA9IGV2ZW50O1xuICB9XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICByZWxhdGVkVGFyZ2V0OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChGb2N1c0V2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBkYXRhOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG4vLyBIYXBwZW5zIHRvIHNoYXJlIHRoZSBzYW1lIGxpc3QgZm9yIG5vdy5cblxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgcG9pbnRlcklkOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogMCxcbiAgaXNQcmltYXJ5OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cblxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IDAsXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcblxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5cbmlmIChjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufSAvLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxuXG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IGNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTsgLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cblxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25CZWZvcmVJbnB1dCcsIFsnY29tcG9zaXRpb25lbmQnLCAna2V5cHJlc3MnLCAndGV4dElucHV0JywgJ3Bhc3RlJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25FbmQnLCBbJ2NvbXBvc2l0aW9uZW5kJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25TdGFydCcsIFsnY29tcG9zaXRpb25zdGFydCcsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJywgWydjb21wb3NpdGlvbnVwZGF0ZScsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbn0gLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxuXG5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiYgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2NvbXBvc2l0aW9uc3RhcnQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uRW5kJztcblxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzpcbiAgICAgIHJldHVybiAnb25Db21wb3NpdGlvblVwZGF0ZSc7XG4gIH1cbn1cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICovXG5cblxuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG5cbiAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuXG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbmF0aXZlRXZlbnQubG9jYWxlID09PSAna28nO1xufSAvLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG5cblxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSAnb25Db21wb3NpdGlvbkVuZCc7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25TdGFydCcpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdvbkNvbXBvc2l0aW9uRW5kJykge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIGV2ZW50VHlwZSk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZXZlbnRUeXBlLCBkb21FdmVudE5hbWUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG5cbiAgICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG5cbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7IC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gaWdub3JlIGl0LlxuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAnY29tcG9zaXRpb25lbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG5cblxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsICdvbkJlZm9yZUlucHV0Jyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0lucHV0RXZlbnQoJ29uQmVmb3JlSW5wdXQnLCAnYmVmb3JlaW5wdXQnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICAgIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICBpZiAoIWNhblVzZURPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ2hhbmdlJywgWydjaGFuZ2UnLCAnY2xpY2snLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdpbnB1dCcsICdrZXlkb3duJywgJ2tleXVwJywgJ3NlbGVjdGlvbmNoYW5nZSddKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoaW5zdCwgJ29uQ2hhbmdlJyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsICdjaGFuZ2UnLCBudWxsLCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xuXG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTsgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTtcblxuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xuXG5cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcblxuaWYgKGNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c2luJykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59IC8vIEZvciBJRTggYW5kIElFOS5cblxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcgfHwgZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnY2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnaW5wdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG5cbiAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICB9XG5cbiAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpO1xuXG4gICAgaWYgKGluc3QpIHtcbiAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICBoYW5kbGVFdmVudEZ1bmMoZG9tRXZlbnROYW1lLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgfSAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMigpIHtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsIFsnbW91c2VvdXQnLCAnbW91c2VvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLCBbJ3BvaW50ZXJvdXQnLCAncG9pbnRlcm92ZXInXSk7XG59XG4vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgaXNPdmVyRXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW92ZXInIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJztcbiAgdmFyIGlzT3V0RXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW91dCcgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm91dCc7XG5cbiAgaWYgKGlzT3ZlckV2ZW50ICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfUkVQTEFZRUQpID09PSAwKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIW9iamVjdElzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuICB2YXIgd2luID0gb3duZXJEb2N1bWVudCAmJiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24gJiYgd2luLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDsgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuXG5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuXG5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IC8vIEVkZ2UgZmFpbHMgd2l0aCBcIk9iamVjdCBleHBlY3RlZFwiIGluIHNvbWUgc2NlbmFyaW9zLlxuICAvLyAoRm9yIGluc3RhbmNlOiBUaW55TUNFIGVkaXRvciB1c2VkIGluIGEgbGlzdCBjb21wb25lbnQgdGhhdCBzdXBwb3J0cyBwYXN0aW5nIHRvIGFkZCBtb3JlLFxuICAvLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcblxuICBpZiAoIXdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTsgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cblxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbkZyYW1lKGlmcmFtZSkge1xuICB0cnkge1xuICAgIC8vIEFjY2Vzc2luZyB0aGUgY29udGVudERvY3VtZW50IG9mIGEgSFRNTElmcmFtZUVsZW1lbnQgY2FuIGNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4gICAgLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4gICAgLy8gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAvLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuICAgIC8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2ludGVncmF0aW9uLXdpdGgtaWRsXG4gICAgcmV0dXJuIHR5cGVvZiBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSAnc3RyaW5nJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCkge1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcblxuICB3aGlsZSAoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgIGlmIChpc1NhbWVPcmlnaW5GcmFtZShlbGVtZW50KSkge1xuICAgICAgd2luID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG4vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuXG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAocHJpb3JTZWxlY3Rpb25SYW5nZSAhPT0gbnVsbCAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9IC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG5cblxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb247XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsIFsnZm9jdXNvdXQnLCAnY29udGV4dG1lbnUnLCAnZHJhZ2VuZCcsICdmb2N1c2luJywgJ2tleWRvd24nLCAna2V5dXAnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5cblxuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cblxuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uJDEoYWN0aXZlRWxlbWVudCQxKTtcblxuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QkMSwgJ29uU2VsZWN0Jyk7XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCAnc2VsZWN0JywgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgICAgZXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcblxuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcnNlZSByaWdodCBub3cuXG5cbiAgaWYgKHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMpIHtcbiAgICBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICAgIGV4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufSAvLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxuXG5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnbG9hZGVkZGF0YScsICdsb2FkZWRtZXRhZGF0YScsICdsb2Fkc3RhcnQnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXTsgLy8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxuXG52YXIgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChbJ2NhbmNlbCcsICdjbG9zZScsICdpbnZhbGlkJywgJ2xvYWQnLCAnc2Nyb2xsJywgJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtcblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgaW5DYXB0dXJlUGhhc2UpIHtcbiAgdmFyIHByZXZpb3VzSW5zdGFuY2U7XG5cbiAgaWYgKGluQ2FwdHVyZVBoYXNlKSB7XG4gICAgZm9yICh2YXIgaSA9IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBkaXNwYXRjaExpc3RlbmVyc1tpXSxcbiAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGxpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG5cbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kgPSBkaXNwYXRjaExpc3RlbmVyc1tfaV0sXG4gICAgICAgICAgX2luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmluc3RhbmNlLFxuICAgICAgICAgIF9jdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgX2xpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmxpc3RlbmVyO1xuXG4gICAgICBpZiAoX2luc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9saXN0ZW5lciwgX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9pbnN0YW5jZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZGlzcGF0Y2hRdWV1ZSRpID0gZGlzcGF0Y2hRdWV1ZVtpXSxcbiAgICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnMgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCwgbGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSk7IC8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgfSAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cblxuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzKTtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyID0gZmFsc2U7XG4gIHZhciBsaXN0ZW5lclNldCA9IGdldEV2ZW50TGlzdGVuZXJTZXQodGFyZ2V0RWxlbWVudCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7XG5cbiAgaWYgKCFsaXN0ZW5lclNldC5oYXMobGlzdGVuZXJTZXRLZXkpKSB7XG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCBJU19OT05fREVMRUdBVEVELCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG52YXIgbGlzdGVuaW5nTWFya2VyID0gJ19yZWFjdExpc3RlbmluZycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBkb24ndCBpdGVyYXRlIHRocm91Z2ggZXZlbnRzXG4gICAgICAvLyBmb3IgdGhlIHNhbWUgcG9ydGFsIGNvbnRhaW5lciBvciByb290IG5vZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAvLyBUT0RPOiBvbmNlIHdlIHJlbW92ZSB0aGUgZmxhZywgd2UgbWF5IGJlIGFibGUgdG8gYWxzb1xuICAgICAgLy8gcmVtb3ZlIHNvbWUgb2YgdGhlIGJvb2trZWVwaW5nIG1hcHMgdXNlZCBmb3IgbGF6aW5lc3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgaWYgKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGZhbHNlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCB0cnVlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCByb290Q29udGFpbmVyRWxlbWVudCwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgdmFyIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50OyAvLyBzZWxlY3Rpb25jaGFuZ2UgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50XG4gIC8vIG90aGVyd2lzZSBpdCB3b24ndCBjYXB0dXJlIGluY29taW5nIGV2ZW50cyB0aGF0IGFyZSBvbmx5XG4gIC8vIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZScgJiYgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB0YXJnZXQgPSByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICB9IC8vIElmIHRoZSBldmVudCBjYW4gYmUgZGVsZWdhdGVkIChvciBpcyBjYXB0dXJlIHBoYXNlKSwgd2UgY2FuXG4gIC8vIHJlZ2lzdGVyIGl0IHRvIHRoZSByb290IGNvbnRhaW5lci4gT3RoZXJ3aXNlLCB3ZSBzaG91bGRcbiAgLy8gcmVnaXN0ZXIgdGhlIGV2ZW50IHRvIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgbWFyayBpdCBhc1xuICAvLyBhIG5vbi1kZWxlZ2F0ZWQgZXZlbnQuXG5cblxuICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gbnVsbCAmJiAhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciAmJiBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBGb3IgYWxsIG5vbi1kZWxlZ2F0ZWQgZXZlbnRzLCBhcGFydCBmcm9tIHNjcm9sbCwgd2UgYXR0YWNoXG4gICAgLy8gdGhlaXIgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSByZXNwZWN0aXZlIGVsZW1lbnRzIHRoYXQgdGhlaXJcbiAgICAvLyBldmVudHMgZmlyZSBvbi4gVGhhdCBtZWFucyB3ZSBjYW4gc2tpcCB0aGlzIHN0ZXAsIGFzIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCBwcmV2aW91c2x5LiBIb3dldmVyLCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSB0aGUgc2Nyb2xsIGV2ZW50IGJlY2F1c2UgdGhlIHJlYWxpdHkgaXMgdGhhdCBhbnlcbiAgICAvLyBlbGVtZW50IGNhbiBzY3JvbGwuXG4gICAgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFwcGx5IHRoZSBzYW1lIGxvZ2ljIHRvIGFsbFxuICAgIC8vIGV2ZW50cyBmcm9tIHRoZSBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdC4gVGhlbiB3ZSBjYW4gcmVtb3ZlXG4gICAgLy8gdGhpcyBzcGVjaWFsIGNhc2UgYW5kIHVzZSB0aGUgc2FtZSBsb2dpYyBmb3IgYWxsIGV2ZW50cy5cbiAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2Nyb2xsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfTk9OX0RFTEVHQVRFRDtcbiAgICB0YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXQpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZW50cnkgaXMgZW1wdHkgb3Igd2Ugc2hvdWxkIHVwZ3JhZGUsIHRoZW5cbiAgLy8gd2UgbmVlZCB0byB0cmFwIGFuIGV2ZW50IGxpc3RlbmVyIG9udG8gdGhlIHRhcmdldC5cblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19DQVBUVVJFX1BIQVNFO1xuICAgIH1cblxuICAgIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCBpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpIHtcbiAgdmFyIGxpc3RlbmVyID0gY3JlYXRlRXZlbnRMaXN0ZW5lcldyYXBwZXJXaXRoUHJpb3JpdHkodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MpOyAvLyBJZiBwYXNzaXZlIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB0aGVuIHRoZSBldmVudCB3aWxsIGJlXG4gIC8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG5cbiAgdmFyIGlzUGFzc2l2ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGlmIChwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIEJyb3dzZXJzIGludHJvZHVjZWQgYW4gaW50ZXJ2ZW50aW9uLCBtYWtpbmcgdGhlc2UgZXZlbnRzXG4gICAgLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuICAgIC8vIHRvIGRvY3VtZW50IGFueW1vcmUsIGJ1dCBjaGFuZ2luZyB0aGlzIG5vdyB3b3VsZCB1bmRvXG4gICAgLy8gdGhlIHBlcmZvcm1hbmNlIHdpbnMgZnJvbSB0aGUgY2hhbmdlLiBTbyB3ZSBlbXVsYXRlXG4gICAgLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTY1MVxuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBkb21FdmVudE5hbWUgPT09ICd0b3VjaG1vdmUnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3doZWVsJykge1xuICAgICAgaXNQYXNzaXZlTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldENvbnRhaW5lciA9ICB0YXJnZXRDb250YWluZXI7XG4gIHZhciB1bnN1YnNjcmliZUxpc3RlbmVyOyAvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5cblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXIpIHtcbiAgcmV0dXJuIGdyYW5kQ29udGFpbmVyID09PSB0YXJnZXRDb250YWluZXIgfHwgZ3JhbmRDb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBncmFuZENvbnRhaW5lci5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3Q7XG5cbiAgaWYgKChldmVudFN5c3RlbUZsYWdzICYgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUpID09PSAwICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfTk9OX0RFTEVHQVRFRCkgPT09IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyTm9kZSA9IHRhcmdldENvbnRhaW5lcjsgLy8gSWYgd2UgYXJlIHVzaW5nIHRoZSBsZWdhY3kgRkIgc3VwcG9ydCBmbGFnLCB3ZVxuXG4gICAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBiZWxvdyBsb2dpYyBhdHRlbXB0cyB0byB3b3JrIG91dCBpZiB3ZSBuZWVkIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIHRhcmdldCBmaWJlciB0byBhIGRpZmZlcmVudCBhbmNlc3Rvci4gV2UgaGFkIHNpbWlsYXIgbG9naWNcbiAgICAgIC8vIGluIHRoZSBsZWdhY3kgZXZlbnQgc3lzdGVtLCBleGNlcHQgdGhlIGJpZyBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgIC8vIHN5c3RlbXMgaXMgdGhhdCB0aGUgbW9kZXJuIGV2ZW50IHN5c3RlbSBub3cgaGFzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAvLyBhdHRhY2hlZCB0byBlYWNoIFJlYWN0IFJvb3QgYW5kIFJlYWN0IFBvcnRhbCBSb290LiBUb2dldGhlcixcbiAgICAgIC8vIHRoZSBET00gbm9kZXMgcmVwcmVzZW50aW5nIHRoZXNlIHJvb3RzIGFyZSB0aGUgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBUbyBmaWd1cmUgb3V0IHdoaWNoIGFuY2VzdG9yIGluc3RhbmNlIHdlIHNob3VsZCB1c2UsIHdlIHRyYXZlcnNlXG4gICAgICAvLyB1cCB0aGUgZmliZXIgdHJlZSBmcm9tIHRoZSB0YXJnZXQgaW5zdGFuY2UgYW5kIGF0dGVtcHQgdG8gZmluZFxuICAgICAgLy8gcm9vdCBib3VuZGFyaWVzIHRoYXQgbWF0Y2ggdGhhdCBvZiBvdXIgY3VycmVudCBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIElmIHdlIGZpbmQgdGhhdCBcInJvb3RDb250YWluZXJcIiwgd2UgZmluZCB0aGUgcGFyZW50IGZpYmVyXG4gICAgICAvLyBzdWItdHJlZSBmb3IgdGhhdCByb290IGFuZCBtYWtlIHRoYXQgb3VyIGFuY2VzdG9yIGluc3RhbmNlLlxuICAgICAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0O1xuXG4gICAgICBtYWluTG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZVRhZyA9IG5vZGUudGFnO1xuXG4gICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0Um9vdCB8fCBub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoY29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgaXMgYSBwb3J0YWwsIGJ1dCBpdCdzIG5vdCB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvci5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHBvcnRhbHMgaGFuZGxlIHRoZWlyIG93biBldmVudHMgYWxsIHRoZSB3YXkgZG93biB0byB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIFNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIHN0b3Agbm93LiBIb3dldmVyLCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgcG9ydGFsXG4gICAgICAgICAgICAvLyB3YXMgcGFydCBvZiAqb3VyKiByb290LlxuICAgICAgICAgICAgdmFyIGdyYW5kTm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICAgICAgICB3aGlsZSAoZ3JhbmROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IGdyYW5kTm9kZS50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGdyYW5kVGFnID09PSBIb3N0Um9vdCB8fCBncmFuZFRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFuZENvbnRhaW5lciA9IGdyYW5kTm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IgYW5kIHdlIGZvdW5kIGl0IGFzXG4gICAgICAgICAgICAgICAgICAvLyBhIHBhcmVudCBvZiB0aGUgUG9ydGFsLiBUaGF0IG1lYW5zIHdlIGNhbiBpZ25vcmUgaXQgYmVjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFBvcnRhbCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRvIHVzLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyYW5kTm9kZSA9IGdyYW5kTm9kZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBOb3cgd2UgbmVlZCB0byBmaW5kIGl0J3MgY29ycmVzcG9uZGluZyBob3N0IGZpYmVyIGluIHRoZSBvdGhlclxuICAgICAgICAgIC8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4gICAgICAgICAgLy8gbmVlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZSBmaWJlciBpcyBhIGhvc3QgaW5zdGFuY2UsIG90aGVyd2lzZVxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdHJhdmVyc2UgdXAgdGhyb3VnaCB0aGUgRE9NIHRpbGwgd2UgZmluZCB0aGUgY29ycmVjdFxuICAgICAgICAgIC8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxuXG5cbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudE5vZGUudGFnO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHBhcmVudFRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGFuY2VzdG9ySW5zdCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmF0Y2hlZEV2ZW50VXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBhbmNlc3Rvckluc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50VHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciBIVE1MX05BTUVTUEFDRSQxID0gTmFtZXNwYWNlcy5odG1sO1xudmFyIHdhcm5lZFVua25vd25UYWdzO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2U7XG52YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcztcbnZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7XG52YXIgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZztcbnZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGU7XG52YXIgbm9ybWFsaXplSFRNTDtcblxue1xuICB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWUsXG4gICAgLy8gRWxlY3Ryb24gc2hpcHMgYSBjdXN0b20gPHdlYnZpZXc+IHRhZyB0byBkaXNwbGF5IGV4dGVybmFsIHdlYiBjb250ZW50IGluXG4gICAgLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4gICAgLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4gICAgLy8gaXMgb2Z0ZW4gdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbiAgICB3ZWJ2aWV3OiB0cnVlXG4gIH07XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCB7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1xuICAgIH0pO1xuICB9OyAvLyBJRSAxMSBwYXJzZXMgJiBub3JtYWxpemVzIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgb3Bwb3NlZCB0byBvdGhlclxuICAvLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbiAgLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4gIC8vIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudCAmIHNlcnZlciB2ZXJzaW9ucyBvciBhcHBseWluZ1xuICAvLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbiAgLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuICAvLyBpbiB0aGF0IGJyb3dzZXIgY29tcGxldGVseSBpbiBmYXZvciBvZiBkb2luZyBhbGwgdGhhdCB3b3JrLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuXG5cbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBlcnJvcignRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07IC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuXG5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTsgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuXG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIHR5cGUgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cblxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwge1xuICAgICAgICBpczogcHJvcHMuaXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWAgYW5kIGBzaXplYFxuICAgICAgLy8gYXR0cmlidXRlcyBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzOlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgZG9lcyBub3Qgc2Nyb2xsIHRvIHRoZSBjb3JyZWN0IG9wdGlvbiBiZWNhdXNlIHNpbmd1bGFyXG4gICAgICAvLyAgYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtICMxMzIyMlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgc2V0IHRoZSBmaXJzdCBpdGVtIGFzIHNlbGVjdGVkIGRlc3BpdGUgdGhlIGBzaXplYCBhdHRyaWJ1dGUgIzE0MjM5XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzIyMlxuICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyMzlcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9tRWxlbWVudDtcblxuICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zaXplKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxuICAgICAgICAgIG5vZGUuc2l6ZSA9IHByb3BzLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICB2YXIgcHJvcHM7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcblxuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcyk7XG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcblxuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG5cblxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnb2JqZWN0JyAmJiBuZXh0UHJvcCAhPT0gbnVsbCAmJiBuZXh0UHJvcC4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEUpIHtcbiAgICAgIC8vIElmIHdlIGVuY291bnRlciB1c2VPcGFxdWVSZWZlcmVuY2UncyBvcGFxdWUgb2JqZWN0LCB0aGlzIG1lYW5zIHdlIGFyZSBoeWRyYXRpbmcuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGNhbGwgdGhlIG9wYXF1ZSBvYmplY3QncyB0b1N0cmluZyBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgYSBuZXcgY2xpZW50XG4gICAgICAvLyBJRCBzbyBjbGllbnQgYW5kIHNlcnZlciBJRHMgbWF0Y2ggYW5kIHRocm93cyB0byByZXJlbmRlci5cbiAgICAgIG5leHRQcm9wLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRQcm9wc1tTVFlMRV0pO1xuICAgIH1cblxuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufSAvLyBBcHBseSB0aGUgZGlmZi5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7IC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZztcbiAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7XG5cbiAge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIGFsbG93ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIC8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG4gICAgdHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWUgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcblxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlOyAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUoc3RhbmRhcmROYW1lKTtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcblxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG5cbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuXG4gICAgdmFyIGluZm8gPSB7XG4gICAgICB0YWc6IHRhZ1xuICAgIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH0gLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG5cbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG5cbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5cbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcblxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JyB8fCB0YWcgPT09ICdmcmFtZXNldCc7XG5cbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2ZyYW1lJztcblxuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH0gLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4kMSA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkVGFnICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZztcblxuICAgIGlmIChkaWRXYXJuJDFbd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuJDFbd2FybktleV0gPSB0cnVlO1xuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuXG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZyk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG59XG5cbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZSA9PT0gJ29wdGlvbicgfHwgdHlwZSA9PT0gJ25vc2NyaXB0JyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuLy8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cblxudmFyIHNjaGVkdWxlVGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBub1RpbWVvdXQgPSAtMTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cblxuICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9IC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4gIC8vIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcblxuXG4gIHZhciByZWFjdFJvb3RDb250YWluZXIgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICBpZiAoKHJlYWN0Um9vdENvbnRhaW5lciA9PT0gbnVsbCB8fCByZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZCkgJiYgcGFyZW50Tm9kZS5vbmNsaWNrID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnROb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgdmFyIGJvZHkgPSBjb250YWluZXIuYm9keTtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIGZvciAoOyBub2RlICE9IG51bGw7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpOyAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgLy8gZ2V0IGF0dGFjaGVkLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH0gLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuXG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmICggcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkgO1xufVxudmFyIGNsaWVudElkID0gMDtcbmZ1bmN0aW9uIG1ha2VDbGllbnRJZEluREVWKHdhcm5PbkFjY2Vzc0luREVWKSB7XG4gIHZhciBpZCA9ICdyOicgKyAoY2xpZW50SWQrKykudG9TdHJpbmcoMzYpO1xuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgd2Fybk9uQWNjZXNzSW5ERVYoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc09wYXF1ZUh5ZHJhdGluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEU7XG59XG5mdW5jdGlvbiBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGF0dGVtcHRUb1JlYWRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9PUEFRVUVfSURfVFlQRSxcbiAgICB0b1N0cmluZzogYXR0ZW1wdFRvUmVhZFZhbHVlLFxuICAgIHZhbHVlT2Y6IGF0dGVtcHRUb1JlYWRWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKSB7XG4gIHtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhwb3J0YWxJbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEZpYmVyJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxQcm9wc0tleSA9ICdfX3JlYWN0UHJvcHMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5ID0gJ19fcmVhY3RDb250YWluZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50cyQnICsgcmFuZG9tS2V5O1xuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuZnVuY3Rpb24gbWFya0NvbnRhaW5lckFzUm9vdChob3N0Um9vdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gaG9zdFJvb3Q7XG59XG5mdW5jdGlvbiB1bm1hcmtDb250YWluZXJBc1Jvb3Qobm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtcbn0gLy8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gSG9zdFJvb3Qgb3IgU3VzcGVuc2VDb21wb25lbnQgaGVyZS5cbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfSAvLyBJZiB0aGUgZGlyZWN0IGV2ZW50IHRhcmdldCBpc24ndCBhIFJlYWN0IG93bmVkIERPTSBub2RlLCB3ZSBuZWVkIHRvIGxvb2tcbiAgLy8gdG8gc2VlIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBhIFJlYWN0IG93bmVkIERPTSBub2RlLlxuXG5cbiAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAvLyBXZSdsbCBjaGVjayBpZiB0aGlzIGlzIGEgY29udGFpbmVyIHJvb3QgdGhhdCBjb3VsZCBpbmNsdWRlXG4gICAgLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2VcbiAgICAvLyBpZiB3ZSdyZSBhIGNoaWxkIG9mIGEgZGVoeWRyYXRlZCBjb250YWluZXIsIHdlIG5lZWQgdG8gZmlyc3RcbiAgICAvLyBmaW5kIHRoYXQgaW5uZXIgY29udGFpbmVyIGJlZm9yZSBtb3Zpbmcgb24gdG8gZmluZGluZyB0aGUgcGFyZW50XG4gICAgLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuICAgIC8vIGl0c2VsZiBiZWNhdXNlIHRoZSBmaWJlcnMgYXJlIGNvbmNlcHR1YWxseSBiZXR3ZWVuIHRoZSBjb250YWluZXJcbiAgICAvLyBub2RlIGFuZCB0aGUgZmlyc3QgY2hpbGQuIEl0IGlzbid0IHN1cnJvdW5kaW5nIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICAvLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbiAgICB0YXJnZXRJbnN0ID0gcGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSB8fCBwYXJlbnROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAgIC8vIFNpbmNlIHRoaXMgd2Fzbid0IHRoZSBkaXJlY3QgdGFyZ2V0IG9mIHRoZSBldmVudCwgd2UgbWlnaHQgaGF2ZVxuICAgICAgLy8gc3RlcHBlZCBwYXN0IGRlaHlkcmF0ZWQgRE9NIG5vZGVzIHRvIGdldCBoZXJlLiBIb3dldmVyIHRoZXkgY291bGRcbiAgICAgIC8vIGFsc28gaGF2ZSBiZWVuIG5vbi1SZWFjdCBub2Rlcy4gV2UgbmVlZCB0byBhbnN3ZXIgd2hpY2ggb25lLlxuICAgICAgLy8gSWYgd2UgdGhlIGluc3RhbmNlIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gdGhlcmUgY2FuJ3QgYmVcbiAgICAgIC8vIGEgbmVzdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdpdGhpbiBpdC4gU28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgZmFzdFxuICAgICAgLy8gYmFpbG91dC4gTW9zdCBvZiB0aGUgdGltZSwgd2hlbiBwZW9wbGUgYWRkIG5vbi1SZWFjdCBjaGlsZHJlbiB0b1xuICAgICAgLy8gdGhlIHRyZWUsIGl0IGlzIHVzaW5nIGEgcmVmIHRvIGEgY2hpbGQtbGVzcyBET00gbm9kZS5cbiAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgb25seSBuZWVkIHRvIGNoZWNrIG9uZSBvZiB0aGUgZmliZXJzIGJlY2F1c2UgaWYgaXRcbiAgICAgIC8vIGhhcyBldmVyIGdvbmUgZnJvbSBoYXZpbmcgY2hpbGRyZW4gdG8gZGVsZXRpbmcgdGhlbSBvciB2aWNlIHZlcnNhXG4gICAgICAvLyBpdCB3b3VsZCBoYXZlIGRlbGV0ZWQgdGhlIGRlaHlkcmF0ZWQgYm91bmRhcnkgbmVzdGVkIGluc2lkZSBhbHJlYWR5LlxuICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhlIEhvc3RSb290IHN0YXJ0cyBvdXQgd2l0aCBhbiBhbHRlcm5hdGUgaXQgbWlnaHRcbiAgICAgIC8vIGhhdmUgb25lIG9uIHRoZSBhbHRlcm5hdGUgc28gd2UgbmVlZCB0byBjaGVjayBpbiBjYXNlIHRoaXMgd2FzIGFcbiAgICAgIC8vIHJvb3QuXG4gICAgICB2YXIgYWx0ZXJuYXRlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG5cbiAgICAgIGlmICh0YXJnZXRJbnN0LmNoaWxkICE9PSBudWxsIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbiAgICAgICAgLy8gbmVzdGVkIHdpdGhpbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgYW5kIGlmIHNvLCB3aGljaCBvbmUuXG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcblxuICAgICAgICB3aGlsZSAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc3VzcGVuc2UgaW5zdGFuY2UuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgICAgLy8gaHlkcmF0ZWQgaXQgeWV0LiBFdmVuIHRob3VnaCB3ZSBsZWF2ZSB0aGUgY29tbWVudHMgaW4gdGhlXG4gICAgICAgICAgLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbiAgICAgICAgICAvLyB0aGF0IGNvdWxkIGFscmVhZHkgYmUgaHlkcmF0ZWQsIHdlIHdvdWxkbid0IGhhdmUgZm91bmQgdGhlbVxuICAgICAgICAgIC8vIHRocm91Z2ggdGhpcyBwYXNzIHNpbmNlIGlmIHRoZSB0YXJnZXQgaXMgaHlkcmF0ZWQgaXQgd291bGRcbiAgICAgICAgICAvLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuICAgICAgICAgIC8vIExldCdzIGdldCB0aGUgZmliZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgICAgIC8vIGFzIHRoZSBkZWVwZXN0IGluc3RhbmNlLlxuICAgICAgICAgIHZhciB0YXJnZXRTdXNwZW5zZUluc3QgPSBzdXNwZW5zZUluc3RhbmNlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgICAgICAgaWYgKHRhcmdldFN1c3BlbnNlSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN1c3BlbnNlSW5zdDtcbiAgICAgICAgICB9IC8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgZ290dGVuIHRvIGh5ZHJhdGUgaXQgeWV0LiBUaGVyZSBtaWdodCBzdGlsbCBiZSBhXG4gICAgICAgICAgLy8gcGFyZW50IGJvdW5kYXJ5IHRoYXQgaGFzbid0IGFib3ZlIHRoaXMgb25lIHNvIHdlIG5lZWQgdG8gZmluZFxuICAgICAgICAgIC8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5cblxuICAgICAgICAgIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpOyAvLyBJZiB3ZSBkb24ndCBmaW5kIG9uZSwgdGhlbiB0aGF0IHNob3VsZCBtZWFuIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAgIC8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuICAgICAgICAgIC8vIGJlbG93IHNpbmNlIGl0IHdpbGwgYmFpbCBvdXQgb24gdGhlIGlzTW91bnRlZCBjaGVjayBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICB0YXJnZXROb2RlID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSB8fCBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCB8fCBpbnN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9IC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cblxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclNldChub2RlKSB7XG4gIHZhciBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG5cbiAgaWYgKGVsZW1lbnRMaXN0ZW5lclNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIHtcbiAgICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKCEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG5cbiAgICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7IC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDsgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cblxuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTsgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgIGlmICghKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIEJsb2NraW5nUm9vdCA9IDE7XG52YXIgQ29uY3VycmVudFJvb3QgPSAyO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfSAvLyBEZXZUb29scyBleGlzdHNcblxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LCBwcmlvcml0eUxldmVsKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBwcmlvcml0eUxldmVsLCBkaWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgdW5kZWZpbmVkLCBkaWRFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgU2NoZWR1bGVyX3Nob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgIFNjaGVkdWxlcl9yZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgIFNjaGVkdWxlcl9ub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gU2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICAgIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Mb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTtcblxue1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLlxuICAvLyByZWFjdC1kb20gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZlxuICAvLyBzY2hlZHVsZXIvdHJhY2luZ1xuICBpZiAoISh0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmICE9IG51bGwgJiYgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ICE9IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSXQgaXMgbm90IHN1cHBvcnRlZCB0byBydW4gdGhlIHByb2ZpbGluZyB2ZXJzaW9uIG9mIGEgcmVuZGVyZXIgKGZvciBleGFtcGxlLCBgcmVhY3QtZG9tL3Byb2ZpbGluZ2ApIHdpdGhvdXQgYWxzbyByZXBsYWNpbmcgdGhlIGBzY2hlZHVsZXIvdHJhY2luZ2AgbW9kdWxlIHdpdGggYHNjaGVkdWxlci90cmFjaW5nLXByb2ZpbGluZ2AuIFlvdXIgYnVuZGxlciBtaWdodCBoYXZlIGEgc2V0dGluZyBmb3IgYWxpYXNpbmcgYm90aCBtb2R1bGVzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9wcm9maWxpbmdcIiApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUNhbGxiYWNrTm9kZSA9IHt9OyAvLyBFeGNlcHQgZm9yIE5vUHJpb3JpdHksIHRoZXNlIGNvcnJlc3BvbmQgdG8gU2NoZWR1bGVyIHByaW9yaXRpZXMuIFdlIHVzZVxuLy8gYXNjZW5kaW5nIG51bWJlcnMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSBsaWtlIG51bWJlcnMuIFRoZXkgc3RhcnQgYXQgOTAgdG9cbi8vIGF2b2lkIGNsYXNoaW5nIHdpdGggU2NoZWR1bGVyJ3MgcHJpb3JpdGllcy5cblxudmFyIEltbWVkaWF0ZVByaW9yaXR5JDEgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQyID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkkMSA9IDk3O1xudmFyIExvd1ByaW9yaXR5JDEgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkkMSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5JDEgPSA5MDtcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlcl9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSAvLyBGYWxsIGJhY2sgZ3JhY2VmdWxseSBpZiB3ZSdyZSBydW5uaW5nIGFuIG9sZGVyIHZlcnNpb24gb2YgU2NoZWR1bGVyLlxuU2NoZWR1bGVyX3JlcXVlc3RQYWludCAhPT0gdW5kZWZpbmVkID8gU2NoZWR1bGVyX3JlcXVlc3RQYWludCA6IGZ1bmN0aW9uICgpIHt9O1xudmFyIHN5bmNRdWV1ZSA9IG51bGw7XG52YXIgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBudWxsO1xudmFyIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbnZhciBpbml0aWFsVGltZU1zJDEgPSBTY2hlZHVsZXJfbm93JDEoKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cbi8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgbW9kZXJuIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgcGVyZm9ybWFuY2Uubm93YC4gSW5cbi8vIG9sZGVyIGJyb3dzZXJzLCBTY2hlZHVsZXIgZmFsbHMgYmFjayB0byBgRGF0ZS5ub3dgLCB3aGljaCByZXR1cm5zIGEgVW5peFxuLy8gdGltZXN0YW1wLiBJbiB0aGF0IGNhc2UsIHN1YnRyYWN0IHRoZSBtb2R1bGUgaW5pdGlhbGl6YXRpb24gdGltZSB0byBzaW11bGF0ZVxuLy8gdGhlIGJlaGF2aW9yIG9mIHBlcmZvcm1hbmNlLm5vdyBhbmQga2VlcCBvdXIgdGltZXMgc21hbGwgZW5vdWdoIHRvIGZpdFxuLy8gd2l0aGluIDMyIGJpdHMuXG4vLyBUT0RPOiBDb25zaWRlciBsaWZ0aW5nIHRoaXMgaW50byBTY2hlZHVsZXIuXG5cbnZhciBub3cgPSBpbml0aWFsVGltZU1zJDEgPCAxMDAwMCA/IFNjaGVkdWxlcl9ub3ckMSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ub3ckMSgpIC0gaW5pdGlhbFRpbWVNcyQxO1xufTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICBzd2l0Y2ggKFNjaGVkdWxlcl9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgY2FzZSBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfTG93UHJpb3JpdHk6XG4gICAgICByZXR1cm4gTG93UHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX0lkbGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHkkMTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0UHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgTG93UHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfTG93UHJpb3JpdHk7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBwcmlvcml0eSBsZXZlbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMShyZWFjdFByaW9yaXR5TGV2ZWwsIGZuKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZm4pO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhyZWFjdFByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIC8vIFB1c2ggdGhpcyBjYWxsYmFjayBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiBXZSdsbCBmbHVzaCB0aGVzZSBlaXRoZXIgaW5cbiAgLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG4gICAgc3luY1F1ZXVlID0gW2NhbGxiYWNrXTsgLy8gRmx1c2ggdGhlIHF1ZXVlIGluIHRoZSBuZXh0IHRpY2ssIGF0IHRoZSBlYXJsaWVzdC5cblxuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBmYWtlQ2FsbGJhY2tOb2RlO1xufVxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gIGlmIChjYWxsYmFja05vZGUgIT09IGZha2VDYWxsYmFja05vZGUpIHtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgdmFyIG5vZGUgPSBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZTtcbiAgICBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgU2NoZWR1bGVyX2NhbmNlbENhbGxiYWNrKG5vZGUpO1xuICB9XG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmN5LlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcblxuICAgIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfaXNTeW5jMiA9IHRydWU7XG4gICAgICAgIHZhciBfcXVldWUgPSBzeW5jUXVldWU7XG4gICAgICAgIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IF9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3F1ZXVlW2ldO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soX2lzU3luYzIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBzeW5jUXVldWUgPSBzeW5jUXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB9IC8vIFJlc3VtZSBmbHVzaGluZyBpbiB0aGUgbmV4dCB0aWNrXG5cblxuICAgICAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWUpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMSc7XG5cbnZhciBOb01vZGUgPSAwO1xudmFyIFN0cmljdE1vZGUgPSAxOyAvLyBUT0RPOiBSZW1vdmUgQmxvY2tpbmdNb2RlIGFuZCBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3Rcbi8vIHRhZyBpbnN0ZWFkXG5cbnZhciBCbG9ja2luZ01vZGUgPSAyO1xudmFyIENvbmN1cnJlbnRNb2RlID0gNDtcbnZhciBQcm9maWxlTW9kZSA9IDg7XG52YXIgRGVidWdUcmFjaW5nTW9kZSA9IDE2O1xuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBOb1RyYW5zaXRpb24gPSAwO1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIHNvcnRlZE5hbWVzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgbmV4dFZhbHVlKSB7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuXG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgLy8gTm8gY2hhbmdlXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgIHtcbiAgICAgIGlmICgoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpICE9PSBjaGFuZ2VkQml0cykge1xuICAgICAgICBlcnJvcignY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEJpdHMgfCAwO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIG5vZGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgIWlzU3Vic2V0T2ZMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3RDb250ZXh0O1xuXG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcykpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlOyAvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4gICAgICAgICAgICAvLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4gICAgICAgICAgICAvLyB3b3J0aCBmaXhpbmcuXG5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cblxuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9PT0gY29udGV4dCkgOyBlbHNlIGlmIChvYnNlcnZlZEJpdHMgPT09IGZhbHNlIHx8IG9ic2VydmVkQml0cyA9PT0gMCkgOyBlbHNlIHtcbiAgICB2YXIgcmVzb2x2ZWRPYnNlcnZlZEJpdHM7IC8vIEF2b2lkIGRlb3B0aW5nIG9uIG9ic2VydmFibGUgYXJndW1lbnRzIG9yIGhldGVyb2dlbmVvdXMgdHlwZXMuXG5cbiAgICBpZiAodHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHwgb2JzZXJ2ZWRCaXRzID09PSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpIHtcbiAgICAgIC8vIE9ic2VydmUgYWxsIHVwZGF0ZXMuXG4gICAgICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBjb250ZXh0O1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbSxcbiAgICAgICAgcmVzcG9uZGVyczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGxcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4gIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG4gIC8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuXG4gICAgICAvLyB3ZSBiYWlsIG91dCBvbiBhIHBhcmVudCBmaWJlciB0aGF0IHRoZW4gY2FwdHVyZXMgYW4gZXJyb3IgdGhyb3duIGJ5XG4gICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cbiAgICAgIC8vIC1wcm9ncmVzcyBxdWV1ZSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlcy4gV2UgdXN1YWxseSBjbG9uZSBkdXJpbmdcbiAgICAgIC8vIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IHRoYXQgZGlkbid0IGhhcHBlbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbDtcbiAgICAgIHZhciBuZXdMYXN0ID0gbnVsbDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZS5ldmVudFRpbWUsXG4gICAgICAgICAgICBsYW5lOiB1cGRhdGUubGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgICAgIG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTsgLy8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5cblxuICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICAgIG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbiAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblxuXG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuICAgICAgdmFyIHVwZGF0ZUV2ZW50VGltZSA9IHVwZGF0ZS5ldmVudFRpbWU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cblxuXG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG4gICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVmZmVjdHMgPSBbdXBkYXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2sgKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB7XG4gIHJldHVybiBoYXNGb3JjZVVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UpIHtcbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIHZhciBlZmZlY3RzID0gZmluaXNoZWRRdWV1ZS5lZmZlY3RzO1xuICBmaW5pc2hlZFF1ZXVlLmVmZmVjdHMgPSBudWxsO1xuXG4gIGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWZmZWN0ID0gZWZmZWN0c1tpXTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGVmZmVjdC5jYWxsYmFjaztcblxuICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsgLy8gUmVhY3QuQ29tcG9uZW50IHVzZXMgYSBzaGFyZWQgZnJvemVuIG9iamVjdCBieSBkZWZhdWx0LlxuLy8gV2UnbGwgdXNlIGl0IHRvIGRldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBsZWdhY3kgcmVmcy5cblxudmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS5yZWZzO1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPSBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gICAgY29udGV4dCA9IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfSAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4gICAgICAvLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICAgICAgaWYgKChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSB8fCB3YXJuQWJvdXRTdHJpbmdSZWZzKSAmJiAvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fc2VsZiAmJiBlbGVtZW50Ll9vd25lci5zdGF0ZU5vZGUgIT09IGVsZW1lbnQuX3NlbGYpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignQSBzdHJpbmcgcmVmLCBcIiVzXCIsIGhhcyBiZWVuIGZvdW5kIHdpdGhpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBtaXhlZFJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3Q7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG4gICAgICAgIGlmICghKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiBXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluc3QpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcblxuICAgICAgICBpZiAocmVmcyA9PT0gZW1wdHlSZWZzT2JqZWN0KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgICAgICByZWZzID0gaW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufSAvLyBXZSBhdm9pZCBpbmxpbmluZyB0aGlzIHRvIGF2b2lkIHBvdGVudGlhbCBkZW9wdHMgZnJvbSB1c2luZyB0cnkvY2F0Y2guXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cblxuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG5cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZmxhZ3MgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcikge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbiAgICAgIG5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfSAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cblxuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICghKG5ld0NoaWxkcmVuICE9IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuXG5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLnRhZykge1xuICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgQmxvY2s6XG5cbiAgICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIGhlcmUgaWYgZW5hYmxlQmxvY2tzQVBJIGlzIG5vdCBvbi5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9leGlzdGluZzMgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBfZXhpc3RpbmczLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZXhpc3RpbmczLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nMztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICBfY3JlYXRlZDQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIHZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbDtcblxuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG5cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgQmxvY2s6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufSAvLyBSZXNldCBhIHdvcmtJblByb2dyZXNzIGNoaWxkIHNldCB0byBwcmVwYXJlIGl0IGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIGlmICghKGMgIT09IE5PX0NPTlRFWFQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gcm9vdEluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpOyAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpOyAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4gIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4gIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dCA9IDA7IC8vIFRoZSBTdXNwZW5zZSBDb250ZXh0IGlzIHNwbGl0IGludG8gdHdvIHBhcnRzLiBUaGUgbG93ZXIgYml0cyBpc1xuLy8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuLy8gdGhpcyBpbW1lZGlhdGUgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGdldHMgcmVzZXQgZWFjaCBuZXdcbi8vIGJvdW5kYXJ5IG9yIHN1c3BlbnNlIGxpc3QuXG5cbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIFN1YnRyZWUgRmxhZ3M6XG4vLyBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgaW5kaWNhdGVzIHRoYXQgb25lIG9mIG91ciBwYXJlbnQgU3VzcGVuc2Vcbi8vIGJvdW5kYXJpZXMgaXMgbm90IGN1cnJlbnRseSBzaG93aW5nIHZpc2libGUgbWFpbiBjb250ZW50LlxuLy8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiBpdCBpcyBkZXNpcmFibGUgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGF0XG4vLyB0aGUgcGFyZW50LiBJZiBub3QsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIHVuZGVzaXJhYmxlIGJvdW5kYXJpZXNcbi8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cblxudmFyIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCA9IDE7IC8vIFNoYWxsb3cgRmxhZ3M6XG4vLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyO1xudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7XG5mdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbn1cbmZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayB8IHNoYWxsb3dDb250ZXh0O1xufVxuZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzdWJ0cmVlQ29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCB8IHN1YnRyZWVDb250ZXh0O1xufVxuZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzOyAvLyBJbiBvcmRlciB0byBjYXB0dXJlLCB0aGUgU3VzcGVuc2UgY29tcG9uZW50IG11c3QgaGF2ZSBhIGZhbGxiYWNrIHByb3AuXG5cbiAgaWYgKHByb3BzLmZhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG5cbiAgaWYgKHByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxuICAvLyBwYXJlbnQgYm91bmRhcnkgaWYgaXQgaXMgY3VycmVudGx5IGludmlzaWJsZS5cblxuXG4gIGlmIChoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgdGhlIHBhcmVudCBpcyBub3QgYWJsZSB0byBoYW5kbGUgaXQsIHdlIG11c3QgaGFuZGxlIGl0LlxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgKi9cbjA7IC8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG5cbnZhciBIYXNFZmZlY3QgPVxuLyogKi9cbjE7IC8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxuXG52YXIgTGF5b3V0ID1cbi8qICAgICovXG4yO1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG40O1xuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uOyAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG5cbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcblxuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcblxuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcblxuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuXG4gIHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7IC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuLy8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcbnZhciByZW5kZXJlclNpZ2lsJDE7XG5cbntcbiAgLy8gVXNlZCB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIG11dGFibGUgc291cmNlLlxuICByZW5kZXJlclNpZ2lsJDEgPSB7fTtcbn1cblxuZnVuY3Rpb24gbWFya1NvdXJjZUFzRGlydHkobXV0YWJsZVNvdXJjZSkge1xuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuICAgIHtcbiAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHJldHVybiBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5O1xuICB9XG59XG5mdW5jdGlvbiBzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSwgdmVyc2lvbikge1xuICB7XG4gICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IHZlcnNpb247XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgbXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWwkMTtcbiAgICAgIH0gZWxzZSBpZiAobXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCQxKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIG11dGFibGUgc291cmNlLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gRWFnZXIgcmVhZHMgdGhlIHZlcnNpb24gb2YgYSBtdXRhYmxlIHNvdXJjZSBhbmQgc3RvcmVzIGl0IG9uIHRoZSByb290LlxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVzZU9wYXF1ZUlkZW50aWZpZXI7XG5cbntcbiAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllciA9IHt9O1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS50eXBlKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY3kuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAoISFkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAoIShuZXh0Q3VycmVudEhvb2sgIT09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgIGVhZ2VyUmVkdWNlcjogdXBkYXRlLmVhZ2VyUmVkdWNlcixcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgaWYgKHVwZGF0ZS5lYWdlclJlZHVjZXIgPT09IHJlZHVjZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksIGFuZCBpdHMgcmVkdWNlciBtYXRjaGVzIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVkdWNlciwgd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZS5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KSB7XG4gIHtcbiAgICB3YXJuQWJvdXRNdWx0aXBsZVJlbmRlcmVyc0RFVihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGdldFZlcnNpb24gPSBzb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihzb3VyY2UuX3NvdXJjZSk7IC8vIElzIGl0IHNhZmUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyP1xuXG4gIHZhciBpc1NhZmVUb1JlYWRGcm9tU291cmNlID0gZmFsc2U7IC8vIENoZWNrIHRoZSB2ZXJzaW9uIGZpcnN0LlxuICAvLyBJZiB0aGlzIHJlbmRlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgd2l0aCBhIHNwZWNpZmljIHZlcnNpb24sXG4gIC8vIHdlIGNhbiB1c2UgaXQgYWxvbmUgdG8gZGV0ZXJtaW5lIGlmIHdlIGNhbiBzYWZlbHkgcmVhZCBmcm9tIHRoZSBzb3VyY2UuXG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJWZXJzaW9uID0gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSk7XG5cbiAgaWYgKGN1cnJlbnRSZW5kZXJWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgLy8gSXQncyBzYWZlIHRvIHJlYWQgaWYgdGhlIHN0b3JlIGhhc24ndCBiZWVuIG11dGF0ZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgIC8vIHdlIHJlYWQgc29tZXRoaW5nLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBjdXJyZW50UmVuZGVyVmVyc2lvbiA9PT0gdmVyc2lvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHZlcnNpb24sIHRoZW4gdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSByZWFkIGZyb20gdGhlXG4gICAgLy8gc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcywgc28gd2UgbmVlZCB0byBkbyBhIGJpdCBtb3JlIHdvcmsuXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRldGVybWluZSBpcyBpZiB0aGVyZSBhcmUgYW55IGhvb2tzIHRoYXQgYWxyZWFkeVxuICAgIC8vIHN1YnNjcmliZWQgdG8gdGhlIHNvdXJjZSwgYW5kIGlmIHNvLCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcGVuZGluZ1xuICAgIC8vIG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgeWV0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbXV0YXRpb25zLCB0aGVuIGByb290Lm11dGFibGVSZWFkTGFuZXNgIHdpbGwgYmVcbiAgICAvLyBlbXB0eSwgYW5kIHdlIGtub3cgd2UgY2FuIHNhZmVseSByZWFkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgKmFyZSogcGVuZGluZyBtdXRhdGlvbnMsIHdlIG1heSBzdGlsbCBiZSBhYmxlIHRvIHNhZmVseSByZWFkXG4gICAgLy8gaWYgdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgbGFuZXMgYXJlIGluY2x1c2l2ZSBvZiB0aGUgcGVuZGluZyBtdXRhdGlvblxuICAgIC8vIGxhbmVzLCBzaW5jZSB0aGF0IGd1YXJhbnRlZXMgdGhhdCB0aGUgdmFsdWUgd2UncmUgYWJvdXQgdG8gcmVhZCBmcm9tXG4gICAgLy8gdGhlIHNvdXJjZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlIHJlYWQgZHVyaW5nIHRoZSBtb3N0XG4gICAgLy8gcmVjZW50IG11dGF0aW9uLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHJvb3QubXV0YWJsZVJlYWRMYW5lcyk7XG5cbiAgICBpZiAoaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSkge1xuICAgICAgLy8gSWYgaXQncyBzYWZlIHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgLy8gc3RvcmUgdGhlIHZlcnNpb24gaW4gY2FzZSBvdGhlciBjb21wb25lbnRzIHJlYWQgZnJvbSBpdC5cbiAgICAgIC8vIEEgY2hhbmdlZCB2ZXJzaW9uIG51bWJlciB3aWxsIGxldCB0aG9zZSBjb21wb25lbnRzIGtub3cgdG8gdGhyb3cgYW5kIHJlc3RhcnQgdGhlIHJlbmRlci5cbiAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihzb3VyY2UsIHZlcnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgdmFyIHNuYXBzaG90ID0gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBzbmFwc2hvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2FzZSBvZiBhIG11dGFibGUgc291cmNlIGJlaW5nIHNoYXJlZCBiZXR3ZWVuIHJlbmRlcmVycy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIGlmIHRoZSBzb3VyY2UgaXMgbXV0YXRlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHJlbmRlcmVyLFxuICAgIC8vIFRoZSBzZWNvbmQgcmVuZGVyZXIgZG9uJ3Qga25vdyB0aGF0IGl0IG5lZWRzIHRvIHJlc2V0IHRoZSBXSVAgdmVyc2lvbiBkdXJpbmcgdW53aW5kLFxuICAgIC8vIChiZWNhdXNlIHRoZSBob29rIG9ubHkgbWFya3Mgc291cmNlcyBhcyBkaXJ0eSBpZiBpdCdzIHdyaXR0ZW4gdG8gdGhlaXIgV0lQIHZlcnNpb24pLlxuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhpcyB0ZWFyIGNoZWNrIHRvIHRocm93IGFnYWluIGFuZCBldmVudHVhbGx5IGJlIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgLy8gV2UgY2FuIGF2b2lkIHRoaXMgaW5maW5pdGUgbG9vcCBieSBleHBsaWNpdGx5IG1hcmtpbmcgdGhlIHNvdXJjZSBhcyBkaXJ0eS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gdGVhcmluZyBpbiB0aGUgZmlyc3QgcmVuZGVyZXIgd2hlbiBpdCByZXN1bWVzLFxuICAgIC8vIGJ1dCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvIGFib3V0IHRoYXQgKHNob3J0IG9mIHRocm93aW5nIGhlcmUgYW5kIHJlZnVzaW5nIHRvIGNvbnRpbnVlIHRoZSByZW5kZXIpLlxuICAgIG1hcmtTb3VyY2VBc0RpcnR5KHNvdXJjZSk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCByZWFkIGZyb20gbXV0YWJsZSBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHRlYXJpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgaWYgKCEocm9vdCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgfSksXG4gICAgICBjdXJyZW50U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFNuYXBzaG90ID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90OyAvLyBHcmFiIGEgaGFuZGxlIHRvIHRoZSBzdGF0ZSBob29rIGFzIHdlbGwuXG4gIC8vIFdlIHVzZSBpdCB0byBjbGVhciB0aGUgcGVuZGluZyB1cGRhdGUgcXVldWUgaWYgd2UgaGF2ZSBhIG5ldyBzb3VyY2UuXG5cbiAgdmFyIHN0YXRlSG9vayA9IHdvcmtJblByb2dyZXNzSG9vaztcbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZWZzID0gbWVtb2l6ZWRTdGF0ZS5yZWZzO1xuICB2YXIgcHJldkdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZTb3VyY2UgPSBtZW1vaXplZFN0YXRlLnNvdXJjZTtcbiAgdmFyIHByZXZTdWJzY3JpYmUgPSBtZW1vaXplZFN0YXRlLnN1YnNjcmliZTtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0ge1xuICAgIHJlZnM6IHJlZnMsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTsgLy8gU3luYyB0aGUgdmFsdWVzIG5lZWRlZCBieSBvdXIgc3Vic2NyaXB0aW9uIGhhbmRsZXIgYWZ0ZXIgZWFjaCBjb21taXQuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZnMuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gTm9ybWFsbHkgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIGZvciBhIHN0YXRlIGhvb2sgbmV2ZXIgY2hhbmdlcyxcbiAgICAvLyBidXQgdGhpcyBob29rIHJlY3JlYXRlcyB0aGUgcXVldWUgaW4gY2VydGFpbiBjYXNlcyAgdG8gYXZvaWQgdXBkYXRlcyBmcm9tIHN0YWxlIHNvdXJjZXMuXG4gICAgLy8gaGFuZGxlQ2hhbmdlKCkgYmVsb3cgbmVlZHMgdG8gcmVmZXJlbmNlIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB3aXRob3V0IHJlLXN1YnNjcmliaW5nLFxuICAgIC8vIHNvIHdlIHVzZSBhIHJlZiB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgaGFzIHRoZSBsYXRlc3QgdmVyc2lvbi5cblxuICAgIHJlZnMuc2V0U25hcHNob3QgPSBzZXRTbmFwc2hvdDsgLy8gQ2hlY2sgZm9yIGEgcG9zc2libGUgY2hhbmdlIGJldHdlZW4gd2hlbiB3ZSBsYXN0IHJlbmRlcmVkIG5vdy5cblxuICAgIHZhciBtYXliZU5ld1ZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcblxuICAgIGlmICghb2JqZWN0SXModmVyc2lvbiwgbWF5YmVOZXdWZXJzaW9uKSkge1xuICAgICAgdmFyIG1heWJlTmV3U25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXliZU5ld1NuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24gYXMgdGhlIHNuYXBzaG90IHZhbHVlLiAnICsgJ0Z1bmN0aW9ucyBtYXkgY2xvc2Ugb3ZlciBtdXRhYmxlIHZhbHVlcyBhbmQgY2F1c2UgdGVhcmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdElzKHNuYXBzaG90LCBtYXliZU5ld1NuYXBzaG90KSkge1xuICAgICAgICBzZXRTbmFwc2hvdChtYXliZU5ld1NuYXBzaG90KTtcbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IC8vIElmIHRoZSBzb3VyY2UgbXV0YXRlZCBiZXR3ZWVuIHJlbmRlciBhbmQgbm93LFxuICAgICAgLy8gdGhlcmUgbWF5IGJlIHN0YXRlIHVwZGF0ZXMgYWxyZWFkeSBzY2hlZHVsZWQgZnJvbSB0aGUgb2xkIHNvdXJjZS5cbiAgICAgIC8vIEVudGFuZ2xlIHRoZSB1cGRhdGVzIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guXG5cblxuICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcbiAgICB9XG4gIH0sIFtnZXRTbmFwc2hvdCwgc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgd2UgZ290IGEgbmV3IHNvdXJjZSBvciBzdWJzY3JpYmUgZnVuY3Rpb24sIHJlLXN1YnNjcmliZSBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG4gIGRpc3BhdGNoZXIudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgICAgIHZhciBsYXRlc3RTZXRTbmFwc2hvdCA9IHJlZnMuc2V0U25hcHNob3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGxhdGVzdEdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKSk7IC8vIFJlY29yZCBhIHBlbmRpbmcgbXV0YWJsZSBzb3VyY2UgdXBkYXRlIHdpdGggdGhlIHNhbWUgZXhwaXJhdGlvbiB0aW1lLlxuXG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgICBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIGxhbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQSBzZWxlY3RvciBtaWdodCB0aHJvdyBhZnRlciBhIHNvdXJjZSBtdXRhdGlvbi5cbiAgICAgICAgLy8gZS5nLiBpdCBtaWdodCB0cnkgdG8gcmVhZCBmcm9tIGEgcGFydCBvZiB0aGUgc3RvcmUgdGhhdCBubyBsb25nZXIgZXhpc3RzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHN0aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB3aXRoIFJlYWN0LlxuICAgICAgICAvLyBXb3JzdCBjYXNlIHRoZSBzZWxlY3RvciB3aWxsIHRocm93IGFnYWluIGFuZCB0aGVuIGFuIGVycm9yIGJvdW5kYXJ5IHdpbGwgaGFuZGxlIGl0LlxuICAgICAgICBsYXRlc3RTZXRTbmFwc2hvdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoc291cmNlLl9zb3VyY2UsIGhhbmRsZUNoYW5nZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzdWJzY3JpYmUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgYW55IG9mIHRoZSBpbnB1dHMgdG8gdXNlTXV0YWJsZVNvdXJjZSBjaGFuZ2UsIHJlYWRpbmcgaXMgcG90ZW50aWFsbHkgdW5zYWZlLlxuICAvL1xuICAvLyBJZiBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgc3Vic2NyaXB0aW9uIGhhdmUgY2hhbmdlZCB3ZSBjYW4ndCBjYW4ndCB0cnVzdCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBNYXliZSB0aGUgc291cmNlIGNoYW5nZWQgaW4gYSB3YXkgdGhhdCB0aGUgb2xkIHN1YnNjcmlwdGlvbiBpZ25vcmVkIGJ1dCB0aGUgbmV3IG9uZSBkZXBlbmRzIG9uLlxuICAvL1xuICAvLyBJZiB0aGUgZ2V0U25hcHNob3QgZnVuY3Rpb24gY2hhbmdlZCwgd2UgYWxzbyBzaG91bGRuJ3QgcmVseSBvbiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHVuZGVybHlpbmcgc291cmNlIHdhcyBtdXRhdGVkIGJldHdlZW4gdGhlIHdoZW4gdGhlIGxhc3QgXCJjaGFuZ2VcIiBldmVudCBmaXJlZCxcbiAgLy8gYW5kIHdoZW4gdGhlIGN1cnJlbnQgcmVuZGVyICh3aXRoIHRoZSBuZXcgZ2V0U25hcHNob3QgZnVuY3Rpb24pIGlzIHByb2Nlc3NlZC5cbiAgLy9cbiAgLy8gSW4gYm90aCBjYXNlcywgd2UgbmVlZCB0byB0aHJvdyBhd2F5IHBlbmRpbmcgdXBkYXRlcyAoc2luY2UgdGhleSBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50KVxuICAvLyBhbmQgdHJlYXQgcmVhZGluZyBmcm9tIHRoZSBzb3VyY2UgYXMgd2UgZG8gaW4gdGhlIG1vdW50IGNhc2UuXG5cbiAgaWYgKCFvYmplY3RJcyhwcmV2R2V0U25hcHNob3QsIGdldFNuYXBzaG90KSB8fCAhb2JqZWN0SXMocHJldlNvdXJjZSwgc291cmNlKSB8fCAhb2JqZWN0SXMocHJldlN1YnNjcmliZSwgc3Vic2NyaWJlKSkge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBxdWV1ZSBhbmQgc2V0U3RhdGUgbWV0aG9kLFxuICAgIC8vIFNvIGlmIHRoZXJlIGFyZSBpbnRlcmxlYXZlZCB1cGRhdGVzLCB0aGV5IGdldCBwdXNoZWQgdG8gdGhlIG9sZGVyIHF1ZXVlLlxuICAgIC8vIFdoZW4gdGhpcyBiZWNvbWVzIGN1cnJlbnQsIHRoZSBwcmV2aW91cyBxdWV1ZSBhbmQgZGlzcGF0Y2ggbWV0aG9kIHdpbGwgYmUgZGlzY2FyZGVkLFxuICAgIC8vIGluY2x1ZGluZyBhbnkgaW50ZXJsZWF2aW5nIHVwZGF0ZXMgdGhhdCBvY2N1ci5cbiAgICB2YXIgbmV3UXVldWUgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBzbmFwc2hvdFxuICAgIH07XG4gICAgbmV3UXVldWUuZGlzcGF0Y2ggPSBzZXRTbmFwc2hvdCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgbmV3UXVldWUpO1xuICAgIHN0YXRlSG9vay5xdWV1ZSA9IG5ld1F1ZXVlO1xuICAgIHN0YXRlSG9vay5iYXNlUXVldWUgPSBudWxsO1xuICAgIHNuYXBzaG90ID0gcmVhZEZyb21VbnN1YmNyaWJlZE11dGFibGVTb3VyY2Uocm9vdCwgc291cmNlLCBnZXRTbmFwc2hvdCk7XG4gICAgc3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2suYmFzZVN0YXRlID0gc25hcHNob3Q7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczoge1xuICAgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgICAgc2V0U25hcHNob3Q6IG51bGxcbiAgICB9LFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gIH07XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcblxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUgfCBQYXNzaXZlLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUodmFsdWUpLFxuICAgICAgcHJldlZhbHVlID0gX21vdW50U3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9tb3VudFN0YXRlWzFdO1xuXG4gIG1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gMTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBwcmV2VmFsdWUgPSBfdXBkYXRlU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF91cGRhdGVTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCA8IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPyBVc2VyQmxvY2tpbmdQcmlvcml0eSQyIDogcHJpb3JpdHlMZXZlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICB9KTtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIF9tb3VudFN0YXRlMiA9IG1vdW50U3RhdGUoZmFsc2UpLFxuICAgICAgaXNQZW5kaW5nID0gX21vdW50U3RhdGUyWzBdLFxuICAgICAgc2V0UGVuZGluZyA9IF9tb3VudFN0YXRlMlsxXTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIGNhbiBiZSBzdG9yZWQgb24gYSByZWYsIHNpbmNlIGBzZXRQZW5kaW5nYFxuICAvLyBuZXZlciBjaGFuZ2VzLlxuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG4gIG1vdW50UmVmKHN0YXJ0KTtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZTIgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgc3RhcnRSZWYgPSB1cGRhdGVSZWYoKTtcbiAgdmFyIHN0YXJ0ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG52YXIgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkge1xuICB7XG4gICAgcmV0dXJuIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2FybiBpbiBlZmZlY3RzIGFuZCBjYWxsYmFja3MsIHRvb1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoZ2V0SXNSZW5kZXJpbmcoKSAmJiAhZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSkge1xuICAgICAgZXJyb3IoJ1RoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlICcgKyAncGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgJyArICd2YWx1ZSBkaXJlY3RseS4nKTtcblxuICAgICAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50T3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIG1ha2VJZCA9ICBtYWtlQ2xpZW50SWRJbkRFVi5iaW5kKG51bGwsIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpKSA7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgZGlkVXBncmFkZSA9IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cbiAgICB2YXIgcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkaWRVcGdyYWRlKSB7XG4gICAgICAgIC8vIE9ubHkgdXBncmFkZSBvbmNlLiBUaGlzIHdvcmtzIGV2ZW4gaW5zaWRlIHRoZSByZW5kZXIgcGhhc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgdXBkYXRlIGlzIGFkZGVkIHRvIGEgc2hhcmVkIHF1ZXVlLCB3aGljaCBvdXRsYXN0cyB0aGVcbiAgICAgICAgLy8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICBkaWRVcGdyYWRlID0gdHJ1ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IHRydWU7XG4gICAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGF0dHJpYnV0ZXMgb25seS4gRG8gbm90IHJlYWQgdGhlIHZhbHVlIGRpcmVjdGx5LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlkID0gbWFrZU9wYXF1ZUh5ZHJhdGluZ09iamVjdChyZWFkVmFsdWUpO1xuICAgIHZhciBzZXRJZCA9IG1vdW50U3RhdGUoaWQpWzFdO1xuXG4gICAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gVXBkYXRlIHwgUGFzc2l2ZTtcbiAgICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldElkKG1ha2VJZCgpKTtcbiAgICAgIH0sIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9IGVsc2Uge1xuICAgIHZhciBfaWQgPSBtYWtlSWQoKTtcblxuICAgIG1vdW50U3RhdGUoX2lkKTtcbiAgICByZXR1cm4gX2lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHVwZGF0ZVN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgaWQgPSByZXJlbmRlclN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgZWFnZXJSZWR1Y2VyOiBudWxsLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9OyAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuZWFnZXJSZWR1Y2VyID0gbGFzdFJlbmRlcmVkUmVkdWNlcjtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIGplc3QgaXNuJ3QgYSBnbG9iYWwsIGFuZCBpc24ndCByZWNvZ25pemVkIG91dHNpZGUgb2YgdGVzdHNcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgICAgd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKTtcbiAgICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2KGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU11dGFibGVTb3VyY2U6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblxue1xuICB2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93JDEoKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdyQxKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4gIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuICAvLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxuICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmOyAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAge1xuICAgIHZhciBfdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIHZhciBfaW5uZXJQcm9wVHlwZXMgPSBfdHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAoX2lubmVyUHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgIGNoZWNrUHJvcFR5cGVzKF9pbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuICAgIC8vIHVubGlrZSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgd2hpY2ggd2lsbCBiZSB0aGUgdW5yZXNvbHZlZCBvbmVzLlxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuXG4gICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgbmV4dFByb3BzKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIG91dGVyTWVtb1R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gb3V0ZXJNZW1vVHlwZTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBudWxsO1xuICAgICAgICB9IC8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG5cblxuICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuXG4gICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIChTaW1wbGVNZW1vQ29tcG9uZW50IGhhcyBubyBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtbGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IG5leHRQcm9wcy5tb2RlID09PSAndW5zdGFibGUtZGVmZXItd2l0aG91dC1oaWRpbmcnKSB7XG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IHdlIHNob3VsZCBkbyBpbiBCbG9ja2luZyBtb2RlLlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIF9uZXh0U3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lc1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlOyAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbiAgICAgIHZhciBfbmV4dFN0YXRlMiA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGUyOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cbiAgICAgIHZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBfc3VidHJlZVJlbmRlckxhbmVzO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSdyZSBub3QgaGlkZGVuIGFueW1vcmUsIHJlc2V0IHRoZSBzdGF0ZVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4gICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbiAgICAgIC8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIH1cblxuICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgX3N1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcbi8vIG91cnNlbHZlcyB0byB0aGlzIGNvbnN0cmFpbnQsIHRob3VnaC4gSWYgdGhlIGJlaGF2aW9yIGRpdmVyZ2VzLCB3ZSBzaG91bGRcbi8vIGZvcmsgdGhlIGZ1bmN0aW9uLlxuXG5cbnZhciB1cGRhdGVMZWdhY3lIaWRkZW5Db21wb25lbnQgPSB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlOyAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcblxuICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5lbGVtZW50IDogbnVsbDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAocm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAvLyBub3QgaHlkcmF0aW5nLlxuICAgIHtcbiAgICAgIHZhciBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhO1xuXG4gICAgICBpZiAobXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBtdXRhYmxlU291cmNlID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGFbaSArIDFdO1xuICAgICAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSwgcmVzb2x2ZWRQcm9wcyksIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgICB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50ICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluY29tcGxldGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfSAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbiAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciB2YWx1ZTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICAgIHZhciBoYXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAge1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG4gICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgcmV0cnlMYW5lOiBOb0xhbmVcbn07XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKVxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4gIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4gIC8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEJvdW5kYXJpZXMgd2l0aG91dCBmYWxsYmFja3Mgb3Igc2hvdWxkIGJlIGF2b2lkZWQgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlXG4gICAgICAvLyB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbiAgICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBuZXh0UHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxhdGlvbiBsb2dpYy4gVHdvXG4gIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuICAvL1xuICAvLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbiAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbiAgLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuICAvLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4gIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuICAvLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4gIC8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbiAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuICAvL1xuICAvLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4gIC8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbiAgLy9cbiAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4gIC8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuICAvLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuICAvLyBhIHN0YWNrLlxuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgLy8gQnV0IG9ubHkgaWYgdGhpcyBoYXMgYSBmYWxsYmFjay5cbiAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG4gICAgfVxuXG4gICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgdmFyIGZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wcy51bnN0YWJsZV9leHBlY3RlZExvYWRUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGhpcyBpcyBhIENQVS1ib3VuZCB0cmVlLiBTa2lwIHRoaXMgdHJlZSBhbmQgc2hvdyBhIHBsYWNlaG9sZGVyIHRvXG4gICAgICAvLyB1bmJsb2NrIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LiBUaGVuIGltbWVkaWF0ZWx5IHJldHJ5IGFmdGVyIHRoZVxuICAgICAgLy8gaW5pdGlhbCBjb21taXQuXG4gICAgICB2YXIgX2ZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblxuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzIHRvXG4gICAgICAvLyBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXMgb2ZcbiAgICAgIC8vIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlciwgaXQnc1xuICAgICAgLy8gbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhcyBjb21taXR0ZWQuIElmXG4gICAgICAvLyBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmUgcGFpbnRlZC5cbiAgICAgIC8vIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy4gV2UgY2FuIHVzZSBhbnlcbiAgICAgIC8vIFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nIHNpbmNlIHdlJ3JlIGxlYXZpbmdcbiAgICAgIC8vIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSAmJiBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAgIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcyA9IHByaW1hcnlDaGlsZFByb3BzO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbiAgICAgIC8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2VcbiAgICAgIC8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9KTtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfSAvLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZWZmZWN0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB3ZSdyZSBnb2luZyB0byByZW1haW4gb24gdGhlIGZhbGxiYWNrLCB3ZSBubyBsb25nZXIgd2FudFxuICAgIC8vIHRvIGRlbGV0ZSBpdC4gU28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdC4gRGVsZXRpb25zIGFyZSBzdG9yZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBsaXN0IGFzIGVmZmVjdHMuIFdlIHdhbnQgdG8ga2VlcCB0aGUgZWZmZWN0cyBmcm9tIHRoZSBwcmltYXJ5XG4gICAgLy8gdHJlZS4gU28gd2UgY29weSB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCdzIGVmZmVjdCBsaXN0LCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGluY2x1ZGUgdGhlIGZhbGxiYWNrIGRlbGV0aW9uIGVmZmVjdC5cblxuXG4gICAgdmFyIHByb2dyZXNzZWRMYXN0RWZmZWN0ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFzdEVmZmVjdDtcblxuICAgIGlmIChwcm9ncmVzc2VkTGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5maXJzdEVmZmVjdDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBwcm9ncmVzc2VkTGFzdEVmZmVjdDtcbiAgICAgIHByb2dyZXNzZWRMYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBSZXNldCB0aGlzIHNvbWV3aGVyZSBlbHNlPyBMb2wgbGVnYWN5IG1vZGUgaXMgc28gd2VpcmQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzKSB7XG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGZpcnN0Q2hpbGQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4gIC8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbiAgLy8gdG8gdW5ibG9jay5cbiAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuICAgICAgLy8gbGlzdCBpdHNlbGYuXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbiAgICAgIHNjaGVkdWxlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZykge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGUsXG4gICAgICBsYXN0RWZmZWN0OiBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmc7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCBTdXNwZW5zZUxpc3QgZG9lc24ndCB3b3JrIHNvIHdlIGp1c3RcbiAgICAvLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG4gICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInKTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW47XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO1xuICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbiAgICAvLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuXG5cbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5pbmRleCA9IG9sZFdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBvbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZWYgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZztcblxuICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudDtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGN1cnJlbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciB1cGRhdGVMYW5lcyA9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG5cbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgfSAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG5cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgICAgIC8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgICAgICAvLyBidXQgSSB3b24ndCA6KVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQyID8gX3VucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsIF91bnJlc29sdmVkUHJvcHMzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIF9yZXNvbHZlZFByb3BzMywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MyA/IF91bnJlc29sdmVkUHJvcHM0IDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MywgX3VucmVzb2x2ZWRQcm9wczQpO1xuXG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbjtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTtcbnZhciB1cGRhdGVIb3N0VGV4dCQxO1xuXG57XG4gIC8vIE11dGF0aW9uIG1vZGVcbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4gICAgLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciB0YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBsYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChsYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29sbGFwc2VkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKF90YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfbGFzdFRhaWxOb2RlID0gX3RhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIGlmICghaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrICYmIHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIC8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghZmliZXJSb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0LlxuICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3IgdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHkgYmUgZW1wdHkpLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHByZXZEaWRUaW1lb3V0ID0gcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgc3VidHJlZWUgaXMgcnVubmluZyBpbiBibG9ja2luZyBtb2RlIHdlIGNhbiBzdXNwZW5kLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB3b24ndCBzdXNwZW5kLlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgd2lsbCBzdGlsbCBzdXNwZW5kIGEgc3luY2hyb25vdXMgdHJlZSBpZiBhbnl0aGluZ1xuICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBidWcuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCB8fCBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4gICAgICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG4gICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgIC8vIHN1c3BlbmQgZm9yIGxvbmdlciBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmx5IHNjaGVkdWxlIHVwZGF0ZXMgaWYgdGhlc2UgdmFsdWVzIGFyZSBub24gZXF1YWwsIGkuZS4gaXQgY2hhbmdlZC5cbiAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgfHwgcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYVxuICAgICAgICAgICAgLy8gcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuIFRoaXMgZmxhZyBpcyBhbHNvIHVzZWQgdG8gaGlkZSB0aGVcbiAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4uIEluIG11dGF0aW9uIG1vZGUsIHdlIGFsc28gbmVlZCB0aGUgZmxhZyB0b1xuICAgICAgICAgICAgLy8gKnVuaGlkZSogY2hpbGRyZW4gdGhhdCB3ZXJlIHByZXZpb3VzbHkgaGlkZGVuLCBzbyBjaGVjayBpZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB0b28uXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgICAgLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbm5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5uYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbm5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBuZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3coKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfbmV3VGhlbm5hYmxlcyA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgaWYgKF9uZXdUaGVubmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbm5hYmxlcztcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlbGV0ZSB0aGUgcm93IHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHJlbmRlcmVkIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNoaWxkLiBUaGUgbmVzdGVkIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBhcHBlbmRlZCB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVtb3ZlIGFueSBlZmZlY3RzIHRoYXQgd2VyZSBhcHBlbmRlZCBhZnRlciB0aGlzIHBvaW50LlxuXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93KCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmIG5ld1Byb3BzLm1vZGUgIT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgdmFyIF9mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmICghKChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICB9O1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbyk7IC8vIEFsbG93IGluamVjdGVkIHNob3dFcnJvckRpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gICAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuXG4gICAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIGlmICh0cnVlKSB7XG4gICAgICB2YXIgc291cmNlID0gZXJyb3JJbmZvLnNvdXJjZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJzsgLy8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuICAgICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgaWYgKGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgICAvLyBJZ25vcmUgaXQgYW5kIGRvbid0IHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cblxuXG4gICAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeS50eXBlKTtcblxuICAgICAgaWYgKGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBcIlxcblwiICsgY29tcG9uZW50U3RhY2sgKyBcIlxcblxcblwiICsgKFwiXCIgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuXG4gICAgICBjb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4gICAgICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbiAgICAgIC8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBQb3NzaWJseVdlYWtNYXAkMSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbiAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRvIHByZXNlcnZlIHRoZSBwcmVleGlzdGluZyByZXRyeSBiZWhhdmlvciBvZiBlcnJvciBib3VuZGFyaWVzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgLy8gVE9ETzogV2FybiBpbiBzdHJpY3QgbW9kZSBpZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXNcbiAgICAgICAgLy8gbm90IGRlZmluZWQuXG4gICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7IC8vIE9ubHkgbG9nIGhlcmUgaWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWRcblxuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlIHRvIFwicGluZ1wiIHRoZSByb290IGFuZCByZXRyeS4gQnV0IG9ubHkgaWZcbiAgLy8gb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lcyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaFxuICAvLyBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlOyAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoKHNvdXJjZUZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBtZW1vaXplZFN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBhdHRlbXB0ZWRcbiAgICAgIC8vIHRvIHJlbmRlciBpdC5cbiAgICAgIHZhciBjdXJyZW50U291cmNlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICAgIHNvdXJjZUZpYmVyLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50U291cmNlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5ID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTsgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgU3VzcGVuc2UgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cblxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2UoX3dvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnRCb3VuZGFyeSkpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgICAgIC8vIFN0YXNoIHRoZSBwcm9taXNlIG9uIHRoZSBib3VuZGFyeSBmaWJlci4gSWYgdGhlIGJvdW5kYXJ5IHRpbWVzIG91dCwgd2UnbGxcbiAgICAgICAgLy8gYXR0YWNoIGFub3RoZXIgbGlzdGVuZXIgdG8gZmxpcCB0aGUgYm91bmRhcnkgYmFjayB0byBpdHMgbm9ybWFsIHN0YXRlLlxuICAgICAgICB2YXIgd2FrZWFibGVzID0gX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWtlYWJsZXMuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgfSAvLyBJZiB0aGUgYm91bmRhcnkgaXMgb3V0c2lkZSBvZiBibG9ja2luZyBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG4gICAgICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgU3VzcGVuc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgLy8gaW5zaWRlIGEgYmxvY2tpbmcgbW9kZSB0cmVlLiBJZiB0aGUgU3VzcGVuc2UgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgLy8gc2hvdWxkICpub3QqIHN1c3BlbmQgdGhlIGNvbW1pdC5cblxuXG4gICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlOyAvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4gICAgICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyAmPSB+KExpZmVjeWNsZUVmZmVjdE1hc2sgfCBJbmNvbXBsZXRlKTtcblxuICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG4gICAgICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuIE1hcmsgaXQgd2l0aCBTeW5jIHByaW9yaXR5IHRvXG4gICAgICAgICAgLy8gaW5kaWNhdGUgdGhhdCBpdCBzdGlsbCBoYXMgcGVuZGluZyB3b3JrLlxuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTsgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyByZW5kZXIgcGFzcyB3aWxsIHJ1biB0byBjb21wbGV0aW9uIG9yIHJlc3RhcnQgb3IgXCJzdXNwZW5kXCIgdGhlIGNvbW1pdC5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZmlyc3QgcHJpbmNpcGxlIGlzIHRoYXQgaWYgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3aGVuIHdlIGNvbXBsZXRlXG4gICAgICAgIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgeW91IHRoaW5rIHlvdSBtaWdodCB3YW50IHRvIHJlc3RhcnQgYmVmb3JlIGNvbW1pdHRpbmcuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc3RhcnRpbmcgdG9vIGFnZ3Jlc3NpdmVseSBpcyBhbHNvIG5vdCBnb29kIGJlY2F1c2UgaXQgc3RhcnZlcyBvdXQgYW55XG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbiAgICAgICAgLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4gICAgICAgIC8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAgICAgLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gc2hvdyB0aGUgaW5pdGlhbCBsb2FkaW5nIHN0YXRlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4gICAgICAgIC8vIGEgZmFsbGJhY2ssIHRoZW4gd2Ugc2hvdWxkIGFsd2F5cyBzdXNwZW5kL3Jlc3RhcnQuIFRyYW5zaXRpb25zIGFwcGx5XG4gICAgICAgIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBhbmQgaXQgZ2V0cyBcInJldHJpZWRcIiwgYWxsb3dpbmcgdXMgdG8gc2hvd1xuICAgICAgICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbiAgICAgICAgLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbiAgICAgICAgLy8gYW55d2hlcmUgaW4gdGhlIHRyZWUuIFRoaXMgZWZmZWN0aXZlbHkgdGhyb3R0bGVzIHByb2dyZXNzaXZlIGxvYWRpbmcgaW50byBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbiAgICAgICAgLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gYm91bmRhcnkuXG5cblxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpOyAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIEZhbGx0aHJvdWdoIHRvIGVycm9yIG1vZGUuXG4gICAgLy8gVE9ETzogVXNlIGludmFyaWFudCBzbyB0aGUgbWVzc2FnZSBpcyBzdHJpcHBlZCBpbiBwcm9kP1xuXG5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArICdcXG4nICsgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nKTtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cblxuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7XG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG5cbnZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcblxuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGUgPyBwcmV2UHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcblxuICAgICAgICAgICAgICAgIGVycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQodGFnLCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgdGFnKSA9PT0gdGFnKSB7XG4gICAgICAgIC8vIE1vdW50XG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSB1c2VFZmZlY3QoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyAndXNlRWZmZWN0KCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ0FuIGVmZmVjdCBmdW5jdGlvbiBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgX2VmZmVjdCA9IGVmZmVjdCxcbiAgICAgICAgICBuZXh0ID0gX2VmZmVjdC5uZXh0LFxuICAgICAgICAgIHRhZyA9IF9lZmZlY3QudGFnO1xuXG4gICAgICBpZiAoKHRhZyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSAmJiAodGFnICYgSGFzRWZmZWN0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gbmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG5cblxuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSwgZmluaXNoZWRSb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufSAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbi8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4vLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuXG5cbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcblxuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QyID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgZGVzdHJveSA9IF9lZmZlY3QyLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0Mi50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChjdXJyZW50LCBlZmZlY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgLy8gd2UgZG8gYW4gaW5uZXIgbG9vcCB3aGlsZSB3ZSdyZSBzdGlsbCBpbnNpZGUgdGhlIGhvc3Qgbm9kZS5cbiAgdmFyIG5vZGUgPSByb290O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKCAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvLyBOb3RlOiB3ZSBjYW5ub3QgbnVsbCBvdXQgc2libGluZyBoZXJlLCBvdGhlcndpc2UgaXQgY2FuIGNhdXNlIGlzc3Vlc1xuICAvLyB3aXRoIGZpbmRET01Ob2RlIGFuZCBob3cgaXQgcmVxdWlyZXMgdGhlIHNpYmxpbmcgZmllbGQgdG8gY2Fycnkgb3V0XG4gIC8vIHRyYXZlcnNhbCBpbiBhIGxhdGVyIGVmZmVjdC4gU2VlIFBSICMxNjgyMC4gV2Ugbm93IGNsZWFyIHRoZSBzaWJsaW5nXG4gIC8vIGZpZWxkIGFmdGVyIGVmZmVjdHMsIHNlZTogZGV0YWNoRmliZXJBZnRlckVmZmVjdHMuXG4gIC8vXG4gIC8vIERvbid0IGRpc2Nvbm5lY3Qgc3RhdGVOb2RlIG5vdzsgaXQgd2lsbCBiZSBkZXRhY2hlZCBpbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy8gSXQgbWF5IGJlIHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IGNvbXBvbmVudCBpcyBhbiBlcnJvciBib3VuZGFyeSxcbiAgLy8gYW5kIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgdGhyb3dzIHdoaWxlIHVubW91bnRpbmcgYSBwYXNzaXZlIGVmZmVjdC5cbiAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgZmliZXIuY2hpbGQgPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5maXJzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5cblxuICAgIGlmICghKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuXG5cbiAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBwYXJlbnQ7XG4gIHZhciBpc0NvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBpc0hvc3QgPyBub2RlLnN0YXRlTm9kZSA6IG5vZGUuc3RhdGVOb2RlLmluc3RhbmNlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gY3VycmVudDsgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cblxuICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBjdXJyZW50UGFyZW50SXNDb250YWluZXI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICghKHBhcmVudCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gIH1cblxuICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGRldGFjaEZpYmVyTXV0YXRpb24oY3VycmVudCk7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGRldGFjaEZpYmVyTXV0YXRpb24oYWx0ZXJuYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIGlmICghKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChfcm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IGh5ZHJhdGVkLiBObyBuZWVkIHRvIGh5ZHJhdGUgYWdhaW4uXG4gICAgICAgICAgICBfcm9vdC5oeWRyYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihfcm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG4gICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDb21wb25lbnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSAhPT0gbnVsbCkge1xuICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuXG4gICAge1xuICAgICAgLy8gSGlkZSB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIHRoZSBwcmltYXJ5IGNoaWxkcmVuLiBUT0RPOlxuICAgICAgLy8gSWRlYWxseSwgdGhpcyBlZmZlY3Qgd291bGQgaGF2ZSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgT2Zmc2NyZWVuIGZpYmVyXG4gICAgICAvLyBpdHNlbGYuIFRoYXQncyBob3cgdW5oaWRpbmcgd29ya3M6IHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHNjaGVkdWxlcyBhblxuICAgICAgLy8gZWZmZWN0IG9uIGl0c2VsZi4gSG93ZXZlciwgaW4gdGhpcyBjYXNlLCB0aGUgY29tcG9uZW50IGRpZG4ndCBjb21wbGV0ZSxcbiAgICAgIC8vIHNvIHRoZSBmaWJlciB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBub3JtYWwgcGF0aC4gV2VcbiAgICAgIC8vIGNvdWxkIGhhdmUgYXBwZW5kZWQgaXQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBTdXNwZW5zZSBjb21wb25lbnQnc1xuICAgICAgLy8gc2Vjb25kIHBhc3MsIGJ1dCBkb2luZyBpdCB0aGlzIHdheSBpcyBsZXNzIGNvbXBsaWNhdGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAvLyBzaW1wbGVyIGlmIHdlIGdvdCByaWQgb2YgdGhlIGVmZmVjdCBsaXN0IGFuZCB0cmF2ZXJzZWQgdGhlIHRyZWUsIGxpa2VcbiAgICAgIC8vIHdlJ3JlIHBsYW5uaW5nIHRvIGRvLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZFBhcmVudCA9IGZpbmlzaGVkV29yay5jaGlsZDtcbiAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKHByaW1hcnlDaGlsZFBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdha2VhYmxlLl9fcmVhY3REb05vdFRyYWNlSW50ZXJhY3Rpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXRyeSA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG4vLyBJdCByZXR1cm5zIGZhbHNlIGlmIHRoZSBib3VuZGFyeSBpcyBhbHJlYWR5IGhpZGRlbi5cbi8vIFRPRE86IFVzZSBhbiBlZmZlY3QgdGFnLlxuXG5cbmZ1bmN0aW9uIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZSAhPT0gbnVsbCAmJiBuZXdTdGF0ZS5kZWh5ZHJhdGVkID09PSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG5cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbnZhciBDT01QT05FTlRfVFlQRSA9IDA7XG52YXIgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMTtcbnZhciBST0xFX1RZUEUgPSAyO1xudmFyIFRFU1RfTkFNRV9UWVBFID0gMztcbnZhciBURVhUX1RZUEUgPSA0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IkMSA9IFN5bWJvbC5mb3I7XG4gIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuICBST0xFX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3Iucm9sZScpO1xuICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXh0Jyk7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixcbiAgICBJc1NvbWVSZW5kZXJlckFjdGluZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLklzU29tZVJlbmRlcmVyQWN0aW5nO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIEV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgRGlzY3JldGVFdmVudENvbnRleHQgPVxuLyogICAgICAgICAqL1xuNDtcbnZhciBMZWdhY3lVbmJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICovXG44O1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbW1pdENvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9XG4vKiAgICAgICAqL1xuNjQ7XG52YXIgUm9vdEluY29tcGxldGUgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbnZhciBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IG51bGw7IC8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGNvbW1pdHRlZCBhIGZhbGxiYWNrLiBUaGlzIGxldHMgdXMgZW5zdXJlIGEgdHJhaW5cbi8vIG1vZGVsIHdoZXJlIHdlIGRvbid0IGNvbW1pdCBuZXcgbG9hZGluZyBzdGF0ZXMgaW4gdG9vIHF1aWNrIHN1Y2Nlc3Npb24uXG5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcbnZhciBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDUwMDsgLy8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG5cbnZhciBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMDtcblxuZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdygpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIG5leHRFZmZlY3QgPSBudWxsO1xudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcbnZhciByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID0gbnVsbDsgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7IC8vIE1hcmtzIHRoZSBuZWVkIHRvIHJlc2NoZWR1bGUgcGVuZGluZyBpbnRlcmFjdGlvbnMgYXQgdGhlc2UgbGFuZXNcbi8vIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSB0cmFjZWQgYWNyb3NzIGNvbXBvbmVudHNcbi8vIHRoYXQgc3Bhd24gbmV3IHdvcmsgZHVyaW5nIHJlbmRlci4gRS5nLiBoaWRkZW4gYm91bmRhcmllcywgc3VzcGVuZGVkIFNTUlxuLy8gaHlkcmF0aW9uIG9yIFN1c3BlbnNlTGlzdC5cbi8vIFRPRE86IENhbiB1c2UgYSBiaXRtYXNrIGluc3RlYWQgb2YgYW4gYXJyYXlcblxudmFyIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG52YXIgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lczsgLy8gRGV2IG9ubHkgZmxhZyB0aGF0IHRyYWNrcyBpZiBwYXNzaXZlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBiZWluZyBmbHVzaGVkLlxuLy8gV2Ugd2FybiBhYm91dCBzdGF0ZSB1cGRhdGVzIGZvciB1bm1vdW50ZWQgY29tcG9uZW50cyBkaWZmZXJlbnRseSBpbiB0aGlzIGNhc2UuXG5cbnZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGUgaW5wdXRzXG4gIC8vIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGUsIHdlIHVzZSB0aGUgYHJlbmRlckxhbmVzYFxuICAvLyB0byBhdm9pZCBjaG9vc2luZyBhIGxhbmUgdGhhdCBpcyBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgXCJpbmNsdWRlZFwiIGxhbmVzIGNvdWxkIGJlIG11dGF0ZWQgaW4gYmV0d2VlbiB1cGRhdGVzIGluIHRoZVxuICAvLyBzYW1lIGV2ZW50LCBsaWtlIGlmIHlvdSBwZXJmb3JtIGFuIHVwZGF0ZSBpbnNpZGUgYGZsdXNoU3luY2AuIE9yIGFueSBvdGhlclxuICAvLyBjb2RlIHBhdGggdGhhdCBtaWdodCBjYWxsIGBwcmVwYXJlRnJlc2hTdGFja2AuXG4gIC8vXG4gIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpcyBvdmVyLlxuICAvLyBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG4gIC8vXG4gIC8vIFdlJ2xsIGRvIHRoZSBzYW1lIGZvciBgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzYCBiZWxvdy5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHZhciBpc1RyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSAhPT0gTm9UcmFuc2l0aW9uO1xuXG4gIGlmIChpc1RyYW5zaXRpb24pIHtcbiAgICBpZiAoY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCAhPT0gbnVsbCA/IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290LnBlbmRpbmdMYW5lcyA6IE5vTGFuZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRUcmFuc2l0aW9uTGFuZShjdXJyZW50RXZlbnRXaXBMYW5lcywgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzKTtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHRoZSBTY2hlZHVsZXIgcHJpb3JpdHkuXG4gIC8vIFRvIGRvIHRoYXQsIHdlJ3JlIHJlcGxhY2luZyBpdCB3aXRoIGFuIHVwZGF0ZSBsYW5lIHByaW9yaXR5LlxuXG5cbiAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTsgLy8gVGhlIG9sZCBiZWhhdmlvciB3YXMgdXNpbmcgdGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBTY2hlZHVsZXIuXG4gIC8vIFRoaXMgY291cGxlcyBSZWFjdCB0byB0aGUgU2NoZWR1bGVyIGludGVybmFscywgc28gd2UncmUgcmVwbGFjaW5nIGl0XG4gIC8vIHdpdGggdGhlIGN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkgYWJvdmUuIEFzIGFuIGV4YW1wbGUgb2YgaG93IHRoaXNcbiAgLy8gY291bGQgYmUgcHJvYmxlbWF0aWMsIGlmIHdlJ3JlIG5vdCBpbnNpZGUgYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLFxuICAvLyB0aGVuIHdlJ2xsIGdldCB0aGUgcHJpb3JpdHkgb2YgdGhlIGN1cnJlbnQgcnVubmluZyBTY2hlZHVsZXIgdGFzayxcbiAgLy8gd2hpY2ggaXMgcHJvYmFibHkgbm90IHdoYXQgd2Ugd2FudC5cblxuICB2YXIgbGFuZTtcblxuICBpZiAoIC8vIFRPRE86IFRlbXBvcmFyeS4gV2UncmUgcmVtb3ZpbmcgdGhlIGNvbmNlcHQgb2YgZGlzY3JldGUgdXBkYXRlcy5cbiAgKGV4ZWN1dGlvbkNvbnRleHQgJiBEaXNjcmV0ZUV2ZW50Q29udGV4dCkgIT09IE5vQ29udGV4dCAmJiBzY2hlZHVsZXJQcmlvcml0eSA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMikge1xuICAgIGxhbmUgPSBmaW5kVXBkYXRlTGFuZShJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlckxhbmVQcmlvcml0eSA9IHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHkpO1xuXG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKHNjaGVkdWxlckxhbmVQcmlvcml0eSwgY3VycmVudEV2ZW50V2lwTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gU2VlIGByZXF1ZXN0VXBkYXRlTGFuZWAgZm9yIGV4cGxhbmF0aW9uIG9mIGBjdXJyZW50RXZlbnRXaXBMYW5lc2BcblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmaW5kUmV0cnlMYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgIC8vIGBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2hgIGZsYWcgaXMgb2ZmIGFuZCB0aGlzIGlzIGEgcmVuZGVyXG4gICAgLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4gICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4gICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbiAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogcmVxdWVzdFVwZGF0ZUxhbmVQcmlvcml0eSBhbHNvIHJlYWRzIHRoZSBwcmlvcml0eS4gUGFzcyB0aGVcbiAgLy8gcHJpb3JpdHkgYXMgYW4gYXJndW1lbnQgdG8gdGhhdCBmdW5jdGlvbiBhbmQgdGhpcyBvbmUuXG5cblxuICB2YXIgcHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG5cbiAgaWYgKGxhbmUgPT09IFN5bmNMYW5lKSB7XG4gICAgaWYgKCAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlc1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAvLyBDaGVjayBpZiB3ZSdyZSBub3QgYWxyZWFkeSByZW5kZXJpbmdcbiAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFJlZ2lzdGVyIHBlbmRpbmcgaW50ZXJhY3Rpb25zIG9uIHRoZSByb290IHRvIGF2b2lkIGxvc2luZyB0cmFjZWQgaW50ZXJhY3Rpb24gZGF0YS5cbiAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKTsgLy8gVGhpcyBpcyBhIGxlZ2FjeSBlZGdlIGNhc2UuIFRoZSBpbml0aWFsIG1vdW50IG9mIGEgUmVhY3RET00ucmVuZGVyLWVkXG4gICAgICAvLyByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMsIGJ1dCBsYXlvdXQgdXBkYXRlc1xuICAgICAgLy8gc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuXG4gICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTY2hlZHVsZSBhIGRpc2NyZXRlIHVwZGF0ZSBidXQgb25seSBpZiBpdCdzIG5vdCBTeW5jLlxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmICggLy8gT25seSB1cGRhdGVzIGF0IHVzZXItYmxvY2tpbmcgcHJpb3JpdHkgb3IgZ3JlYXRlciBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGRpc2NyZXRlLCBldmVuIGluc2lkZSBhIGRpc2NyZXRlIGV2ZW50LlxuICAgIHByaW9yaXR5TGV2ZWwgPT09IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgfHwgcHJpb3JpdHlMZXZlbCA9PT0gSW1tZWRpYXRlUHJpb3JpdHkkMSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIGV2ZW50LiBUcmFjayB0aGUgbG93ZXN0IHByaW9yaXR5XG4gICAgICAvLyBkaXNjcmV0ZSB1cGRhdGUgcGVyIHJvb3Qgc28gd2UgY2FuIGZsdXNoIHRoZW0gZWFybHksIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmFkZChyb290KTtcbiAgICAgIH1cbiAgICB9IC8vIFNjaGVkdWxlIG90aGVyIHVwZGF0ZXMgYWZ0ZXIgaW4gY2FzZSB0aGUgY2FsbGJhY2sgaXMgc3luYy5cblxuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuICB9IC8vIFdlIHVzZSB0aGlzIHdoZW4gYXNzaWduaW5nIGEgbGFuZSBmb3IgYSB0cmFuc2l0aW9uIGluc2lkZVxuICAvLyBgcmVxdWVzdFVwZGF0ZUxhbmVgLiBXZSBhc3N1bWUgaXQncyB0aGUgc2FtZSBhcyB0aGUgcm9vdCBiZWluZyB1cGRhdGVkLFxuICAvLyBzaW5jZSBpbiB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzaW5nbGUgcm9vdCBhcHAgaXQgcHJvYmFibHkgaXMuIElmIGl0J3Mgbm90XG4gIC8vIHRoZSBzYW1lIHJvb3QsIHRoZW4gaXQncyBub3QgYSBodWdlIGRlYWwsIHdlIGp1c3QgbWlnaHQgYmF0Y2ggbW9yZSBzdHVmZlxuICAvLyB0b2dldGhlciBtb3JlIHRoYW4gbmVjZXNzYXJ5LlxuXG5cbiAgbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QgPSByb290O1xufSAvLyBUaGlzIGlzIHNwbGl0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB3ZSBjYW4gbWFyayBhIGZpYmVyIHdpdGggcGVuZGluZ1xuLy8gd29yayB3aXRob3V0IHRyZWF0aW5nIGl0IGFzIGEgdHlwaWNhbCB1cGRhdGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gYW4gZXZlbnQ7XG4vLyBlLmcuIHJldHJ5aW5nIGEgU3VzcGVuc2UgYm91bmRhcnkgaXNuJ3QgYW4gdXBkYXRlLCBidXQgaXQgZG9lcyBzY2hlZHVsZSB3b3JrXG4vLyBvbiBhIGZpYmVyLlxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cblxuXG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5cblxuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlOyAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuICAvLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxuXG4gIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpOyAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxuXG4gIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTsgLy8gVGhpcyByZXR1cm5zIHRoZSBwcmlvcml0eSBsZXZlbCBjb21wdXRlZCBkdXJpbmcgdGhlIGBnZXROZXh0TGFuZXNgIGNhbGwuXG5cbiAgdmFyIG5ld0NhbGxiYWNrUHJpb3JpdHkgPSByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdGFzay4gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgaXQuXG5cblxuICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9PT0gbmV3Q2FsbGJhY2tQcmlvcml0eSkge1xuICAgICAgLy8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXdcbiAgICAvLyBvbmUgYmVsb3cuXG5cblxuICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja05vZGU7XG5cbiAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IFN5bmNMYW5lUHJpb3JpdHkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFN5bmMgUmVhY3QgY2FsbGJhY2tzIGFyZSBzY2hlZHVsZWQgb24gYSBzcGVjaWFsXG4gICAgLy8gaW50ZXJuYWwgcXVldWVcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH0gZWxzZSBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkpIHtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobmV3Q2FsbGJhY2tQcmlvcml0eSk7XG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayhzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290KSB7XG4gIC8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4gIC8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cbiAgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuICBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBleHBpcmF0aW9uIHRpbWUgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAvLyBUaGUgcmVuZGVyIGluY2x1ZGVkIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgIC8vIGxhbmVzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIHdpdGguXG4gICAgLy9cbiAgICAvLyBTbyB3ZSdsbCB0aHJvdyBvdXQgdGhlIGN1cnJlbnQgd29yayBhbmQgcmVzdGFydC5cbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgfSBlbHNlIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5jb21wbGV0ZSkge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgICAgaWYgKHJvb3QuaHlkcmF0ZSkge1xuICAgICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgIH0gLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuXG5cbiAgICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpO1xuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJbmNvbXBsZXRlOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTsgLy8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiAgICAgICAgIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93KCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuICAgICAgICAgIC8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgYSBwbGFjZWhvbGRlciB0byBkaXNwbGF5IGFmdGVyIGEgc2hvcnQgZGVsYXksIHVzaW5nIHRoZSBKdXN0XG4gICAgICAgICAgLy8gTm90aWNlYWJsZSBEaWZmZXJlbmNlLlxuICAgICAgICAgIC8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG4gICAgICAgICAgLy8gdGhlIG9ubHkgcmVhc29uIHdlIHRyYWNrIHRoZSBldmVudCB0aW1lLCB0aGVuIHByb2JhYmx5IG5vdC5cbiAgICAgICAgICAvLyBDb25zaWRlciByZW1vdmluZy5cbiAgICAgICAgICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIHZhciBldmVudFRpbWVNcyA9IG1vc3RSZWNlbnRFdmVudFRpbWU7XG4gICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTXMgPSBub3coKSAtIGV2ZW50VGltZU1zO1xuXG4gICAgICAgICAgdmFyIF9tc1VudGlsVGltZW91dCA9IGpuZCh0aW1lRWxhcHNlZE1zKSAtIHRpbWVFbGFwc2VkTXM7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG5cbiAgICAgICAgICBpZiAoX21zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2sgaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgICAgLy8gdG8gYXJyaXZlLlxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgX21zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcyk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KSB7XG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzO1xuICB2YXIgZXhpdFN0YXR1cztcblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGluY2x1ZGVzU29tZUxhbmUocm9vdC5leHBpcmVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoZXJlJ3MgYSBwYXJ0aWFsIHRyZWUsIGFuZCBhdCBsZWFzdCBvbmUgb2YgaXRzIGxhbmVzIGhhcyBleHBpcmVkLiBGaW5pc2hcbiAgICAvLyByZW5kZXJpbmcgaXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzdCBvZiB0aGUgZXhwaXJlZCB3b3JrLlxuICAgIGxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB1bmhpZGluZyBhIGhpZGRlbiB0cmVlLCB3ZSBpbmNsdWRlIGFsbCB0aGUgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJlbmRlcmVkXG4gICAgICAvLyBjb25jdXJyZW50bHkuIElmIHRoZSB3aG9sZSB0cmVlIGlzIHJlbmRlcmVkIHN5bmNocm9ub3VzbHksIHRoZW4gdGhlcmVcbiAgICAgIC8vIGFyZSBubyBpbnRlcmxlYXZlZCBldmVudHMuXG4gICAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBsYW5lcyk7XG4gICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgLy8gZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG5cbiAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB0aHJvdyBmYXRhbEVycm9yO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290KTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmx1c2hEaXNjcmV0ZVVwZGF0ZXMoKSB7XG4gIC8vIFRPRE86IFNob3VsZCBiZSBhYmxlIHRvIGZsdXNoIGluc2lkZSBiYXRjaGVkVXBkYXRlcywgYnV0IG5vdCBpbnNpZGUgYGFjdGAuXG4gIC8vIEhvd2V2ZXIsIGBhY3RgIHVzZXMgYGJhdGNoZWRVcGRhdGVzYCwgc28gdGhlcmUncyBubyB3YXkgdG8gZGlzdGluZ3Vpc2hcbiAgLy8gdGhvc2UgdHdvIGNhc2VzLiBOZWVkIHRvIGZpeCB0aGlzIGJlZm9yZSBleHBvc2luZyBmbHVzaERpc2NyZXRlVXBkYXRlc1xuICAvLyBhcyBhIHB1YmxpYyBBUEkuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChCYXRjaGVkQ29udGV4dCB8IFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ3Vuc3RhYmxlX2ZsdXNoRGlzY3JldGVVcGRhdGVzOiBDYW5ub3QgZmx1c2ggdXBkYXRlcyB3aGVuIFJlYWN0IGlzICcgKyAnYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBhbHJlYWR5IHJlbmRlcmluZywgc28gd2UgY2FuJ3Qgc3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIHdvcmsuXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIG5lc3RlZCBldmVudCBkaXNwYXRjaCB0cmlnZ2VyZWQgYnkgYSBsaWZlY3ljbGUvZWZmZWN0LFxuICAgIC8vIGxpa2UgYGVsLmZvY3VzKClgLiBFeGl0LlxuXG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmbHVzaFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMoKTsgLy8gSWYgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgc2NoZWR1bGVkIHBhc3NpdmUgZWZmZWN0cywgZmx1c2ggdGhlbSBub3cgc28gdGhhdFxuICAvLyB0aGV5IGZpcmUgYmVmb3JlIHRoZSBuZXh0IHNlcmlhbCBldmVudC5cblxuICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpIHtcbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAvLyBGb3IgZWFjaCByb290IHdpdGggcGVuZGluZyBkaXNjcmV0ZSB1cGRhdGVzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvXG4gICAgLy8gaW1tZWRpYXRlbHkgZmx1c2ggdGhlbS5cbiAgICB2YXIgcm9vdHMgPSByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzO1xuICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsO1xuICAgIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB9KTtcbiAgfSAvLyBOb3cgZmx1c2ggdGhlIGltbWVkaWF0ZSBxdWV1ZS5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEV2ZW50Q29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMkMShmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IERpc2NyZXRlRXZlbnRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJ1bldpdGhQcmlvcml0eSQxKFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIsIGZuLmJpbmQobnVsbCwgYSwgYiwgYywgZCkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCAmPSB+QmF0Y2hlZENvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gTGVnYWN5VW5iYXRjaGVkQ29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblxuICBpZiAoKHByZXZFeGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnICsgJ2ZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gJyArICdhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGEpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcblxuICB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZm4uYmluZChudWxsLCBhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG4gIHB1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBzdWJ0cmVlUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IHN1YnRyZWVSZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJbmNvbXBsZXRlO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIHtcbiAgICBzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKSB7XG4gIGRvIHtcbiAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG4gICAgICAvLyBzZXBhcmF0ZSBpc3N1ZS4gV3JpdGUgYSByZWdyZXNzaW9uIHRlc3QgdXNpbmcgc3RyaW5nIHJlZnMuXG5cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCB8fCBlcnJvcmVkV29yay5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gYmUgd29ya2luZyBvbiBhIG5vbi1yb290IGZpYmVyLiBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSBpdDsgdGhlIHJvb3QgaXNcbiAgICAgICAgLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3JcbiAgICAgICAgLy8gYm91bmRhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gdGhyb3duVmFsdWU7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuICAgICAgICAvLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnRlcmFjdGlvbnMocm9vdCkge1xuICB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgICByZXR1cm4gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucykge1xuICB7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RDb21wbGV0ZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gQWxyZWFkeSB0aW1lZCBvdXQsIHNvIHBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICBzdGFydFdvcmtPblBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cbiAge1xuICAgIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKTtcbiAgfVxuXG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcblxuICAgIHJldHVybiBSb290SW5jb21wbGV0ZTtcbiAgfSBlbHNlIHtcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICggKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspO1xuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiYgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgKHJldHVybkZpYmVyLmZsYWdzICYgSW5jb21wbGV0ZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yay5sYXN0RWZmZWN0O1xuICAgICAgICB9IC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZiBuZWVkZWQsXG4gICAgICAgIC8vIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG5cblxuICAgICAgICB2YXIgZmxhZ3MgPSBjb21wbGV0ZWRXb3JrLmZsYWdzOyAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3QuIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZVxuICAgICAgICAvLyBjb21taXR0ZWQuXG5cbiAgICAgICAgaWYgKGZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgICAgIGlmIChfbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5mbGFncyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBfbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7IC8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG5cbiAgICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRMYW5lcyhjb21wbGV0ZWRXb3JrKSB7XG4gIGlmICggLy8gVE9ETzogTW92ZSB0aGlzIGNoZWNrIG91dCBvZiB0aGUgaG90IHBhdGggYnkgbW92aW5nIGByZXNldENoaWxkTGFuZXNgXG4gIC8vIHRvIHN3aXRjaCBzdGF0ZW1lbnQgaW4gYGNvbXBsZXRlV29ya2AuXG4gIChjb21wbGV0ZWRXb3JrLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50IHx8IGNvbXBsZXRlZFdvcmsudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiAhaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7IC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXG4gIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjsgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgIC8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbiAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgIC8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG5cbiAgICB2YXIgc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zID0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgfHwgY29tcGxldGVkV29yay5jaGlsZCAhPT0gY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQ7XG4gICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuXG4gICAgICBpZiAoc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zKSB7XG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IGNvbXBsZXRlZFdvcmsudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBjb21wbGV0ZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCkge1xuICB2YXIgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG4gIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGNvbW1pdFJvb3RJbXBsLmJpbmQobnVsbCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoZmluaXNoZWRXb3JrICE9PSByb290LmN1cnJlbnQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDsgLy8gVXBkYXRlIHRoZSBmaXJzdCBhbmQgbGFzdCBwZW5kaW5nIHRpbWVzIG9uIHRoaXMgcm9vdC4gVGhlIG5ldyBmaXJzdFxuICAvLyBwZW5kaW5nIHRpbWUgaXMgd2hhdGV2ZXIgaXMgbGVmdCBvbiB0aGUgcm9vdCBmaWJlci5cblxuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO1xuICBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTsgLy8gQ2xlYXIgYWxyZWFkeSBmaW5pc2hlZCBkaXNjcmV0ZSB1cGRhdGVzIGluIGNhc2UgdGhhdCBhIGxhdGVyIGNhbGwgb2ZcbiAgLy8gYGZsdXNoRGlzY3JldGVVcGRhdGVzYCBzdGFydHMgYSB1c2VsZXNzIHJlbmRlciBwYXNzIHdoaWNoIG1heSBjYW5jZWxzXG4gIC8vIGEgc2NoZWR1bGVkIHRpbWVvdXQuXG5cbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICBpZiAoIWhhc0Rpc2NyZXRlTGFuZXMocmVtYWluaW5nTGFuZXMpICYmIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuaGFzKHJvb3QpKSB7XG4gICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmRlbGV0ZShyb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgfSAvLyBHZXQgdGhlIGxpc3Qgb2YgZWZmZWN0cy5cblxuXG4gIHZhciBmaXJzdEVmZmVjdDtcblxuICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZiBpdFxuICAgIC8vIGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBpZiAoZmlyc3RFZmZlY3QgIT09IG51bGwpIHtcblxuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzLCBudWxsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBlcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TXV0YXRpb25FZmZlY3RzLCBudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG4gICAgLy8gdGhlIGhvc3QgdHJlZSBhZnRlciBpdCdzIGJlZW4gbXV0YXRlZC4gVGhlIGlkaW9tYXRpYyB1c2UgY2FzZSBmb3IgdGhpcyBpc1xuICAgIC8vIGxheW91dCwgYnV0IGNsYXNzIGNvbXBvbmVudCBsaWZlY3ljbGVzIGFsc28gZmlyZSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy5cblxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdExheW91dEVmZmVjdHMsIG51bGwsIHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFRlbGwgU2NoZWR1bGVyIHRvIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBzbyB0aGUgYnJvd3NlciBoYXMgYW5cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuXG4gICAge1xuICAgICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHlMZXZlbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZG9uZSB3aXRoIHRoZSBlZmZlY3QgY2hhaW4gYXQgdGhpcyBwb2ludCBzbyBsZXQncyBjbGVhciB0aGVcbiAgICAvLyBuZXh0RWZmZWN0IHBvaW50ZXJzIHRvIGFzc2lzdCB3aXRoIEdDLiBJZiB3ZSBoYXZlIHBhc3NpdmUgZWZmZWN0cywgd2UnbGxcbiAgICAvLyBjbGVhciB0aGlzIGluIGZsdXNoUGFzc2l2ZUVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXh0TmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICAgIGlmIChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZXhwaXJhdGlvblRpbWVzID0gc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXI7XG4gICAgICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGlyYXRpb25UaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGV4cGlyYXRpb25UaW1lc1tpXSwgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHRoZW4gd2UgY2FuIGNvbXBsZXRlIHRoZSBwZW5kaW5nIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgd2FpdCB1bnRpbCBhZnRlciB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSBmbHVzaGVkLlxuICAgICAgLy8gV2FpdCB0byBkbyB0aGlzIHVudGlsIGFmdGVyIHJlbWFpbmluZyB3b3JrIGhhcyBiZWVuIHNjaGVkdWxlZCxcbiAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgcHJlbWF0dXJlbHkgc2lnbmFsIGNvbXBsZXRlIGZvciBpbnRlcmFjdGlvbnMgd2hlbiB0aGVyZSdzIGUuZy4gaGlkZGVuIHdvcmsuXG4gICAgICBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nTGFuZXMgPT09IFN5bmNMYW5lKSB7XG4gICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgX2Vycm9yMztcbiAgfVxuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAvLyBhIFJlYWN0RE9NLnJlbmRlci1lZCByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcy4gVGhlIGNvbW1pdCBmaXJlZFxuICAgIC8vIHN5bmNocm9ub3VzbHksIGJ1dCBsYXlvdXQgdXBkYXRlcyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBiYXRjaC5cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgIGlmICghc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyICYmIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIGlmIChkb2VzRmliZXJDb250YWluKG5leHRFZmZlY3QsIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSkpIHtcbiAgICAgICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIHRoZSBob3QgcGF0aCB1c2luZyBhIGRlZGljYXRlZCBlZmZlY3QgdGFnLlxuICAgICAgICBpZiAobmV4dEVmZmVjdC50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIG5leHRFZmZlY3QpICYmIGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gZmx1c2ggYXRcbiAgICAgIC8vIHRoZSBlYXJsaWVzdCBvcHBvcnR1bml0eS5cbiAgICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IG1vdmUgdGhlIGJ1bGsgb2YgdGhpcyBmdW5jdGlvbiB0byBjb21taXRXb3JrLlxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5IHBvc3NpYmxlXG4gICAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gICAgLy8gc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG5cblxuICAgIHZhciBwcmltYXJ5RmxhZ3MgPSBmbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbiB8IEh5ZHJhdGluZyk7XG5cbiAgICBzd2l0Y2ggKHByaW1hcnlGbGFncykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuICAgICAgICAgIG5leHRFZmZlY3QuZmxhZ3MgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50OyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nQW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nOyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDMsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cblxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMocm9vdCwgY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgLy8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4gIGlmIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSAhPT0gTm9Qcmlvcml0eSQxKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA+IE5vcm1hbFByaW9yaXR5JDEgPyBOb3JtYWxQcmlvcml0eSQxIDogcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHk7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSBOb1ByaW9yaXR5JDE7XG5cbiAgICB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCwgZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RNb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmliZXIsIGVmZmVjdCkge1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUoZWZmZWN0KSB7XG4gIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCBBTEwgcGVuZGluZyBwYXNzaXZlIGVmZmVjdCBkZXN0cm95IGZ1bmN0aW9ucyBhcmUgY2FsbGVkXG4gIC8vIGJlZm9yZSBBTlkgcGFzc2l2ZSBlZmZlY3QgY3JlYXRlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxuICAvLyBPdGhlcndpc2UgZWZmZWN0cyBpbiBzaWJsaW5nIGNvbXBvbmVudHMgbWlnaHQgaW50ZXJmZXJlIHdpdGggZWFjaCBvdGhlci5cbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBtYXkgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRlIGEgcmVmXG4gIC8vIHZhbHVlIHNldCBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudC5cbiAgLy8gTGF5b3V0IGVmZmVjdHMgaGF2ZSB0aGUgc2FtZSBjb25zdHJhaW50LlxuICAvLyBGaXJzdCBwYXNzOiBEZXN0cm95IHN0YWxlIHBhc3NpdmUgZWZmZWN0cy5cblxuICB2YXIgdW5tb3VudEVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRFZmZlY3RzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIF9lZmZlY3QgPSB1bm1vdW50RWZmZWN0c1tpXTtcbiAgICB2YXIgZmliZXIgPSB1bm1vdW50RWZmZWN0c1tpICsgMV07XG4gICAgdmFyIGRlc3Ryb3kgPSBfZWZmZWN0LmRlc3Ryb3k7XG4gICAgX2VmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAge1xuICAgICAgZmliZXIuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmZsYWdzICY9IH5QYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEoZmliZXIgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2Vjb25kIHBhc3M6IENyZWF0ZSBuZXcgcGFzc2l2ZSBlZmZlY3RzLlxuXG5cbiAgdmFyIG1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vdW50RWZmZWN0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdDIgPSBtb3VudEVmZmVjdHNbX2ldO1xuICAgIHZhciBfZmliZXIgPSBtb3VudEVmZmVjdHNbX2kgKyAxXTtcblxuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihfZmliZXIpO1xuXG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBpbnZva2VQYXNzaXZlRWZmZWN0Q3JlYXRlLCBudWxsLCBfZWZmZWN0Mik7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGlmICghKF9maWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgYmUgd29ya2luZyBvbiBhbiBlZmZlY3QuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2Vycm9yNCA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihfZmliZXIsIF9lcnJvcjQpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfSAvLyBOb3RlOiBUaGlzIGN1cnJlbnRseSBhc3N1bWVzIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMgb24gdGhlIHJvb3QgZmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgcm9vdCBpcyBub3QgcGFydCBvZiBpdHMgb3duIGVmZmVjdCBsaXN0LlxuICAvLyBUaGlzIGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG5cbiAgdmFyIGVmZmVjdCA9IHJvb3QuY3VycmVudC5maXJzdEVmZmVjdDtcblxuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHROZXh0RWZmZWN0ID0gZWZmZWN0Lm5leHRFZmZlY3Q7IC8vIFJlbW92ZSBuZXh0RWZmZWN0IHBvaW50ZXIgdG8gYXNzaXN0IEdDXG5cbiAgICBlZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgZWZmZWN0ID0gbmV4dE5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKSB7XG4gIGlmICghaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbnZhciBvblVuY2F1Z2h0RXJyb3IgPSBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSk7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qocm9vdEZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkLlxuICAgICAgICAgIC8vIFdlIGNhbid0IHNjaGVkdWxlIGFueSBmb2xsb3cgdXAgd29yayBmb3IgdGhlIHJvb3QgYmVjYXVzZSB0aGUgZmliZXIgaXMgYWxyZWFkeSB1bm1vdW50ZWQsXG4gICAgICAgICAgLy8gYnV0IHdlIGNhbiBzdGlsbCBjYWxsIHRoZSBsb2ctb25seSBib3VuZGFyeSBzbyB0aGUgZXJyb3IgaXNuJ3Qgc3dhbGxvd2VkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIG9ubHkgYSB0ZW1wb3JhcnkgYmFuZGFpZCBmb3IgdGhlIG9sZCByZWNvbmNpbGVyIGZvcmsuXG4gICAgICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNwZWNpYWwgY2FzZSBvbmNlIHRoZSBuZXcgZm9yayBpcyBtZXJnZWQuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JUb0lnbm9yZSkgey8vIFRPRE8gSWdub3JlIHRoaXMgZXJyb3I/IFJldGhyb3cgaXQ/XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhbiBlZGdlIGNhc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93KCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBwaW5nZWRMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7XG4gIH0gLy8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG5cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAge1xuICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiAoQmxvY2tpbmdNb2RlIHwgQ29uY3VycmVudE1vZGUpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBJbmRldGVybWluYXRlQ29tcG9uZW50ICYmIHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gQmxvY2spIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyB1bm1vdW50cyBmb3IgdGhpcyBGaWJlcixcbiAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhleSB3b3VsZCBoYXZlIHByZXZlbnRlZCB0aGlzIHVwZGF0ZS5cblxuXG4gICAgaWYgKChmaWJlci5mbGFncyAmIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIDsgZWxzZSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiAlcy4nLCB0YWcgPT09IENsYXNzQ29tcG9uZW50ID8gJ3RoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QnIDogJ2EgdXNlRWZmZWN0IGNsZWFudXAgZnVuY3Rpb24nKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsodW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7IC8vIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIHNvbWV0aW1lcyBzZXRzIGFuIGV4cGFuZG8gYF9zdXBwcmVzc0xvZ2dpbmdgLlxuICAgICAgICAvLyBSZXRocm93IHRoaXMgZXJyb3IgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgb25lLlxuXG4gICAgICAgIHRocm93IHJlcGxheUVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBicmFuY2ggaXMgcmVhY2hhYmxlIGlmIHRoZSByZW5kZXIgcGhhc2UgaXMgaW1wdXJlLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnICsgJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcgKyAnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsIHNldFN0YXRlQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhICdzaGFyZWQnIHZhcmlhYmxlIHRoYXQgY2hhbmdlcyB3aGVuIGFjdCgpIG9wZW5zL2Nsb3NlcyBpbiB0ZXN0cy5cblxuXG52YXIgSXNUaGlzUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuZnVuY3Rpb24gd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IHRydWUgJiYgSXNUaGlzUmVuZGVyZXJBY3RpbmcuY3VycmVudCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgdGhlIHdyb25nIGFjdCgpIGFyb3VuZCB5b3VyIHRlc3QgaW50ZXJhY3Rpb25zLlxcblwiICsgJ0JlIHN1cmUgdG8gdXNlIHRoZSBtYXRjaGluZyB2ZXJzaW9uIG9mIGFjdCgpIGNvcnJlc3BvbmRpbmcgdG8geW91ciByZW5kZXJlcjpcXG5cXG4nICsgJy8vIGZvciByZWFjdC1kb206XFxuJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdpbXBvcnQge2FjdH0gZnInICsgXCJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xcblwiICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7XFxuXFxuJyArICcvLyBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlcjpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCBUZXN0UmVuZGVyZXIgZnInICsgXCJvbSByZWFjdC10ZXN0LXJlbmRlcmVyJztcXG5cIiArICdjb25zdCB7YWN0fSA9IFRlc3RSZW5kZXJlcjtcXG4nICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7Jyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSkgIT09IE5vTW9kZSAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyByYW4gYW4gZWZmZWN0LCBidXQgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcgKyAnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRldiA9IHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRFVjsgLy8gSW4gdGVzdHMsIHdlIHdhbnQgdG8gZW5mb3JjZSBhIG1vY2tlZCBzY2hlZHVsZXIuXG5cbnZhciBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IGZhbHNlOyAvLyBUT0RPIEJlZm9yZSB3ZSByZWxlYXNlIGNvbmN1cnJlbnQgbW9kZSwgcmV2aXNpdCB0aGlzIGFuZCBkZWNpZGUgd2hldGhlciBhIG1vY2tlZFxuLy8gc2NoZWR1bGVyIGlzIHRoZSBhY3R1YWwgcmVjb21tZW5kYXRpb24uIFRoZSBhbHRlcm5hdGl2ZSBjb3VsZCBiZSBhIHRlc3RpbmcgYnVpbGQsXG4vLyBhIG5ldyBsaWIsIG9yIHdoYXRldmVyOyB3ZSBkdW5ubyBqdXN0IHlldC4gVGhpcyBtZXNzYWdlIGlzIGZvciBlYXJseSBhZG9wdGVyc1xuLy8gdG8gZ2V0IHRoZWlyIHRlc3RzIHJpZ2h0LlxuXG5mdW5jdGlvbiB3YXJuSWZVbm1vY2tlZFNjaGVkdWxlcihmaWJlcikge1xuICB7XG4gICAgaWYgKGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID09PSBmYWxzZSAmJiBTY2hlZHVsZXIudW5zdGFibGVfZmx1c2hBbGxXaXRob3V0QXNzZXJ0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmaWJlci5tb2RlICYgQmxvY2tpbmdNb2RlIHx8IGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0luIENvbmN1cnJlbnQgb3IgU3luYyBtb2RlcywgdGhlIFwic2NoZWR1bGVyXCIgbW9kdWxlIG5lZWRzIHRvIGJlIG1vY2tlZCAnICsgJ3RvIGd1YXJhbnRlZSBjb25zaXN0ZW50IGJlaGF2aW91ciBhY3Jvc3MgdGVzdHMgYW5kIGJyb3dzZXJzLiAnICsgJ0ZvciBleGFtcGxlLCB3aXRoIGplc3Q6IFxcbicgKyAvLyBCcmVhayB1cCByZXF1aXJlcyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgXCJqZXN0Lm1vY2soJ3NjaGVkdWxlcicsICgpID0+IHJlcXVpcmVcIiArIFwiKCdzY2hlZHVsZXIvdW5zdGFibGVfbW9jaycpKTtcXG5cXG5cIiArICdGb3IgbW9yZSBpbmZvLCB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbW9jay1zY2hlZHVsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpIHtcbiAgLy8gSW50ZXJhY3Rpb24gdGhyZWFkcyBhcmUgdW5pcXVlIHBlciByb290IGFuZCBleHBpcmF0aW9uIHRpbWUuXG4gIC8vIE5PVEU6IEludGVudGlvbmFsbHkgdW5zb3VuZCBjYXN0LiBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgaXQncyBhIG51bWJlclxuICAvLyBhbmQgaXQgcmVwcmVzZW50cyBhIGJhdGNoIG9mIHdvcmsuIENvdWxkIG1ha2UgYSBoZWxwZXIgZnVuY3Rpb24gaW5zdGVhZCxcbiAgLy8gYnV0IG1laCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgcmV0dXJuIGxhbmUgKiAxMDAwICsgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEO1xufVxuXG5mdW5jdGlvbiBtYXJrU3Bhd25lZFdvcmsobGFuZSkge1xuXG4gIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9PT0gbnVsbCkge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gW2xhbmVdO1xuICB9IGVsc2Uge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyLnB1c2gobGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgaW50ZXJhY3Rpb25zKSB7XG5cbiAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcDtcbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5nZXQobGFuZSk7XG5cbiAgICBpZiAocGVuZGluZ0ludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nSW50ZXJhY3Rpb25zLmhhcyhpbnRlcmFjdGlvbikpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChsYW5lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpOyAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuXG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lKTtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSkge1xuXG4gIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUsIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcykge1xuICAvLyB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LCBBbmQgc28gdGhhdCBjYXNjYWRpbmdcbiAgLy8gd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldCgpO1xuICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZExhbmUpIHtcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShsYW5lcywgc2NoZWR1bGVkTGFuZSkpIHtcbiAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBTdG9yZSB0aGUgY3VycmVudCBzZXQgb2YgaW50ZXJhY3Rpb25zIG9uIHRoZSBGaWJlclJvb3QgZm9yIGEgZmV3IHJlYXNvbnM6XG4gIC8vIFdlIGNhbiByZS11c2UgaXQgaW4gaG90IGZ1bmN0aW9ucyBsaWtlIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCgpXG4gIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LiBXZSB3aWxsIGFsc28gdXNlIGl0IGluIGNvbW1pdFdvcmsoKSB0b1xuICAvLyBwYXNzIHRvIGFueSBQcm9maWxlciBvblJlbmRlcigpIGhvb2tzLiBUaGlzIGFsc28gcHJvdmlkZXMgRGV2VG9vbHMgd2l0aCBhXG4gIC8vIHdheSB0byBhY2Nlc3MgaXQgd2hlbiB0aGUgb25Db21taXRSb290KCkgaG9vayBpcyBjYWxsZWQuXG5cbiAgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyA9IGludGVyYWN0aW9ucztcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdWJzY3JpYmVyIHRocm93cywgcmV0aHJvdyBpdCBpbiBhIHNlcGFyYXRlIHRhc2tcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1YnNjcmliZXI7XG5cbiAgdHJ5IHtcbiAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIEZJWE1FOiBNb3JlIHRoYW4gb25lIGxhbmUgY2FuIGZpbmlzaCBpbiBhIHNpbmdsZSBjb21taXQuXG4gICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAvLyBVbmxlc3MgdGhlIHJlbmRlciB3YXMgc3VzcGVuZGVkIG9yIGNhc2NhZGluZyB3b3JrIHdhcyBzY2hlZHVsZWQsXG4gICAgLy8gSW4gd2hpY2ggY2FzZeKAkyBsZWF2ZSBwZW5kaW5nIGludGVyYWN0aW9ucyB1bnRpbCB0aGUgc3Vic2VxdWVudCByZW5kZXIuXG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIGxhbmUpIHtcbiAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIGNvdW50IGlmIHdlJ3JlIGRvbmUuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHdvcmsgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHksXG4gICAgICAvLyBUaGF0IGluZGljYXRlcyB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBzdXNwZW5zZSBkYXRhLlxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQsIGxhbmUpKSB7XG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5kZWxldGUobGFuZSk7XG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBgYWN0YCB0ZXN0aW5nIEFQSVxuXG5mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSB7XG4gIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG4gIHJldHVybiAgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPiAwO1xufVxuLy8gc28gd2UgY2FuIHRlbGwgaWYgYW55IGFzeW5jIGFjdCgpIGNhbGxzIHRyeSB0byBydW4gaW4gcGFyYWxsZWwuXG5cblxudmFyIGFjdGluZ1VwZGF0ZXNTY29wZURlcHRoID0gMDtcblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG59XG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDsgLy8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG5cbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIGRlYnVnQ291bnRlciA9IDE7XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cblxuICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcpIHtcbiAgdmFyIG1vZGU7XG5cbiAgaWYgKHRhZyA9PT0gQ29uY3VycmVudFJvb3QpIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGUgfCBCbG9ja2luZ01vZGUgfCBTdHJpY3RNb2RlO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gQmxvY2tpbmdSb290KSB7XG4gICAgbW9kZSA9IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSB7XG4gICAgbW9kZSA9IE5vTW9kZTtcbiAgfVxuXG4gIGlmICggaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBEZWJ1Z1RyYWNpbmdNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21MZWdhY3lIaWRkZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBCbG9jaztcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIGFzIGEgcHJvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTsgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIudHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBTdXNwZW5zZUNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBUaGUgU3VzcGVuc2VMaXN0Q29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gICAgLy8gaW5zdGVhZC5cbiAgICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBPZmZzY3JlZW5Db21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoTGVnYWN5SGlkZGVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBMZWdhY3lIaWRkZW4gZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb01vZGUpOyAvLyBUT0RPOiBUaGVzZSBzaG91bGQgbm90IG5lZWQgYSB0eXBlLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gJ0RFTEVURUQnO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5uZXh0RWZmZWN0ID0gc291cmNlLm5leHRFZmZlY3Q7XG4gIHRhcmdldC5maXJzdEVmZmVjdCA9IHNvdXJjZS5maXJzdEVmZmVjdDtcbiAgdGFyZ2V0Lmxhc3RFZmZlY3QgPSBzb3VyY2UubGFzdEVmZmVjdDtcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudCA9IHNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7XG4gIHRhcmdldC5fZGVidWdIb29rVHlwZXMgPSBzb3VyY2UuX2RlYnVnSG9va1R5cGVzO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5oeWRyYXRlID0gaHlkcmF0ZTtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdGhpcy5ldmVudFRpbWVzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTtcbiAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5tdXRhYmxlUmVhZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG5cbiAge1xuICAgIHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgdGhpcy5pbnRlcmFjdGlvblRocmVhZElEID0gdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpO1xuICAgIHRoaXMubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQmxvY2tpbmdSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUJsb2NraW5nUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVnYWN5Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVMZWdhY3lSb290KCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaHlkcmF0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpIHtcbiAgdmFyIGdldFZlcnNpb24gPSBtdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbiAgLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuXG4gIGlmIChyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPT0gbnVsbCkge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcbiAgfSBlbHNlIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBPYmplY3Qua2V5cyhjb21wb25lbnQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChob3N0RmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGN1cnJlbnQkMSk7XG4gICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoY3VycmVudCQxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKGN1cnJlbnQudHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsIHVwZGF0ZSk7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVubmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMihwcmlvcml0eSwgZm4pIHtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICB9XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaG9zdEZpYmVyLnRhZyA9PT0gRnVuZGFtZW50YWxDb21wb25lbnQpIHtcbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSB8fCBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIC8vIFJlYWN0IFJlZnJlc2hcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6ICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogIHNjaGVkdWxlUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSb290OiAgc2NoZWR1bGVSb290ICxcbiAgICBzZXRSZWZyZXNoSGFuZGxlcjogIHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiAgZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgQ29uY3VycmVudFJvb3QsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucyk7XG59XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhyb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoZSAnICsgJ3Jvb3QgY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgXCJyb290LnVubW91bnQoKSB0byBlbXB0eSBhIHJvb3QncyBjb250YWluZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbn07XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NQmxvY2tpbmdSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICB1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICAvLyBUYWcgaXMgZWl0aGVyIExlZ2FjeVJvb3Qgb3IgQ29uY3VycmVudCBSb290XG4gIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgdmFyIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGlvbk9wdGlvbnMgfHwgbnVsbDtcbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlcyB8fCBudWxsO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHRhZywgaHlkcmF0ZSk7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgY29udGFpbmVyTm9kZVR5cGUgPSBjb250YWluZXIubm9kZVR5cGU7XG5cbiAge1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKG11dGFibGVTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlc1tpXTtcbiAgICAgIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RET01CbG9ja2luZ1Jvb3QoY29udGFpbmVyLCBMZWdhY3lSb290LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3M7XG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbntcbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSkge1xuICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTsgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxOC4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlID8ge1xuICAgIGh5ZHJhdGU6IHRydWVcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9IC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG5cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgZmliZXJSb290O1xuXG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgZmliZXJSb290ID0gcm9vdC5faW50ZXJuYWxSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIFVwZGF0ZVxuXG5cbiAgICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIGZpYmVyUm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB7XG4gICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnRPckVsZW1lbnQsICdmaW5kRE9NTm9kZScpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGNyZWF0ZVJvb3QoY29udGFpbmVyLCB7aHlkcmF0ZTogdHJ1ZX0pLnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuXG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lck5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInBhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50XCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgIHtcbiAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcblxuICAgICAgaWYgKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOyAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cblxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc2V0QXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbihhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5JDIpO1xudmFyIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gZmFsc2U7XG5cbntcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBNYXAgaGFzIG5vIHByb3RvdHlwZVxuICBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcbiAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnJvcignUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyk7XG5zZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsIGRpc2NyZXRlVXBkYXRlcyQxLCBmbHVzaERpc2NyZXRlVXBkYXRlcywgYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKTtcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICAvLyAkRmxvd0ZpeE1lIFRoZSBGbG93IHR5cGUgaXMgb3BhcXVlIGJ1dCB0aGVyZSdzIG5vIHdheSB0byBhY3R1YWxseSBjcmVhdGUgaXQuXG5cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcblxuICAgICAgd2FybignVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIGtleSk7XG59XG5cbnZhciBJbnRlcm5hbHMgPSB7XG4gIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0VGVzdFV0aWxzLmpzLCBhbmQgUmVhY3RUZXN0VXRpbHNBY3QuanMuXG4gIC8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gIEV2ZW50czogW2dldEluc3RhbmNlRnJvbU5vZGUsIGdldE5vZGVGcm9tSW5zdGFuY2UsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsIGVucXVldWVTdGF0ZVJlc3RvcmUsIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLCBmbHVzaFBhc3NpdmVFZmZlY3RzLCAvLyBUT0RPOiBUaGlzIGlzIHJlbGF0ZWQgdG8gYGFjdGAsIG5vdCBldmVudHMuIE1vdmUgdG8gc2VwYXJhdGUga2V5P1xuICBJc1RoaXNSZW5kZXJlckFjdGluZ11cbn07XG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogIDEgLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sOyAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEludGVybmFscztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsJDE7XG5leHBvcnRzLmZpbmRET01Ob2RlID0gZmluZERPTU5vZGU7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXMkMTtcbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlUG9ydGFsID0gdW5zdGFibGVfY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLHI9cmVxdWlyZShcInNjaGVkdWxlclwiKTtmdW5jdGlvbiB5KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifWlmKCFhYSl0aHJvdyBFcnJvcih5KDIyNykpO3ZhciBiYT1uZXcgU2V0LGNhPXt9O2Z1bmN0aW9uIGRhKGEsYil7ZWEoYSxiKTtlYShhK1wiQ2FwdHVyZVwiLGIpfVxuZnVuY3Rpb24gZWEoYSxiKXtjYVthXT1iO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspYmEuYWRkKGJbYV0pfVxudmFyIGZhPSEoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxoYT0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8saWE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbmphPXt9LGthPXt9O2Z1bmN0aW9uIGxhKGEpe2lmKGlhLmNhbGwoa2EsYSkpcmV0dXJuITA7aWYoaWEuY2FsbChqYSxhKSlyZXR1cm4hMTtpZihoYS50ZXN0KGEpKXJldHVybiBrYVthXT0hMDtqYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBtYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIG5hKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fG1hKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gQihhLGIsYyxkLGUsZixnKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1iO3RoaXMuc2FuaXRpemVVUkw9Zjt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPWd9dmFyIEQ9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwwLCExLGEsbnVsbCwhMSwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07RFtiXT1uZXcgQihiLDEsITEsYVsxXSxudWxsLCExLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwyLCExLGEsbnVsbCwhMSwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTtcbltcImNoZWNrZWRcIixcIm11bHRpcGxlXCIsXCJtdXRlZFwiLFwic2VsZWN0ZWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsMywhMCxhLG51bGwsITEsITEpfSk7W1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtEW2FdPW5ldyBCKGEsNCwhMSxhLG51bGwsITEsITEpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw2LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO3ZhciBvYT0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIHBhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKG9hLFxucGEpO0RbYl09bmV3IEIoYiwxLCExLGEsbnVsbCwhMSwhMSl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwhMSwhMSl9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShvYSxwYSk7RFtiXT1uZXcgQihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCExLCExKX0pO1tcInRhYkluZGV4XCIsXCJjcm9zc09yaWdpblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuRC54bGlua0hyZWY9bmV3IEIoXCJ4bGlua0hyZWZcIiwxLCExLFwieGxpbms6aHJlZlwiLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCEwLCExKTtbXCJzcmNcIixcImhyZWZcIixcImFjdGlvblwiLFwiZm9ybUFjdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0RbYV09bmV3IEIoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCEwLCEwKX0pO1xuZnVuY3Rpb24gcWEoYSxiLGMsZCl7dmFyIGU9RC5oYXNPd25Qcm9wZXJ0eShiKT9EW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwobmEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP2xhKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG52YXIgcmE9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsc2E9NjAxMDMsdGE9NjAxMDYsdWE9NjAxMDcsd2E9NjAxMDgseGE9NjAxMTQseWE9NjAxMDksemE9NjAxMTAsQWE9NjAxMTIsQmE9NjAxMTMsQ2E9NjAxMjAsRGE9NjAxMTUsRWE9NjAxMTYsRmE9NjAxMjEsR2E9NjAxMjgsSGE9NjAxMjksSWE9NjAxMzAsSmE9NjAxMzE7XG5pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yKXt2YXIgRT1TeW1ib2wuZm9yO3NhPUUoXCJyZWFjdC5lbGVtZW50XCIpO3RhPUUoXCJyZWFjdC5wb3J0YWxcIik7dWE9RShcInJlYWN0LmZyYWdtZW50XCIpO3dhPUUoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTt4YT1FKFwicmVhY3QucHJvZmlsZXJcIik7eWE9RShcInJlYWN0LnByb3ZpZGVyXCIpO3phPUUoXCJyZWFjdC5jb250ZXh0XCIpO0FhPUUoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtCYT1FKFwicmVhY3Quc3VzcGVuc2VcIik7Q2E9RShcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7RGE9RShcInJlYWN0Lm1lbW9cIik7RWE9RShcInJlYWN0LmxhenlcIik7RmE9RShcInJlYWN0LmJsb2NrXCIpO0UoXCJyZWFjdC5zY29wZVwiKTtHYT1FKFwicmVhY3Qub3BhcXVlLmlkXCIpO0hhPUUoXCJyZWFjdC5kZWJ1Z190cmFjZV9tb2RlXCIpO0lhPUUoXCJyZWFjdC5vZmZzY3JlZW5cIik7SmE9RShcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIil9XG52YXIgS2E9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIExhKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1LYSYmYVtLYV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgTWE7ZnVuY3Rpb24gTmEoYSl7aWYodm9pZCAwPT09TWEpdHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGMpe3ZhciBiPWMuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7TWE9YiYmYlsxXXx8XCJcIn1yZXR1cm5cIlxcblwiK01hK2F9dmFyIE9hPSExO1xuZnVuY3Rpb24gUGEoYSxiKXtpZighYXx8T2EpcmV0dXJuXCJcIjtPYT0hMDt2YXIgYz1FcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT12b2lkIDA7dHJ5e2lmKGIpaWYoYj1mdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJwcm9wc1wiLHtzZXQ6ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcigpO319KSxcIm9iamVjdFwiPT09dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuY29uc3RydWN0KXt0cnl7UmVmbGVjdC5jb25zdHJ1Y3QoYixbXSl9Y2F0Y2goayl7dmFyIGQ9a31SZWZsZWN0LmNvbnN0cnVjdChhLFtdLGIpfWVsc2V7dHJ5e2IuY2FsbCgpfWNhdGNoKGspe2Q9a31hLmNhbGwoYi5wcm90b3R5cGUpfWVsc2V7dHJ5e3Rocm93IEVycm9yKCk7fWNhdGNoKGspe2Q9a31hKCl9fWNhdGNoKGspe2lmKGsmJmQmJlwic3RyaW5nXCI9PT10eXBlb2Ygay5zdGFjayl7Zm9yKHZhciBlPWsuc3RhY2suc3BsaXQoXCJcXG5cIiksXG5mPWQuc3RhY2suc3BsaXQoXCJcXG5cIiksZz1lLmxlbmd0aC0xLGg9Zi5sZW5ndGgtMTsxPD1nJiYwPD1oJiZlW2ddIT09ZltoXTspaC0tO2Zvcig7MTw9ZyYmMDw9aDtnLS0saC0tKWlmKGVbZ10hPT1mW2hdKXtpZigxIT09Z3x8MSE9PWgpe2RvIGlmKGctLSxoLS0sMD5ofHxlW2ddIT09ZltoXSlyZXR1cm5cIlxcblwiK2VbZ10ucmVwbGFjZShcIiBhdCBuZXcgXCIsXCIgYXQgXCIpO3doaWxlKDE8PWcmJjA8PWgpfWJyZWFrfX19ZmluYWxseXtPYT0hMSxFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT1jfXJldHVybihhPWE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOlwiXCIpP05hKGEpOlwiXCJ9XG5mdW5jdGlvbiBRYShhKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gTmEoYS50eXBlKTtjYXNlIDE2OnJldHVybiBOYShcIkxhenlcIik7Y2FzZSAxMzpyZXR1cm4gTmEoXCJTdXNwZW5zZVwiKTtjYXNlIDE5OnJldHVybiBOYShcIlN1c3BlbnNlTGlzdFwiKTtjYXNlIDA6Y2FzZSAyOmNhc2UgMTU6cmV0dXJuIGE9UGEoYS50eXBlLCExKSxhO2Nhc2UgMTE6cmV0dXJuIGE9UGEoYS50eXBlLnJlbmRlciwhMSksYTtjYXNlIDIyOnJldHVybiBhPVBhKGEudHlwZS5fcmVuZGVyLCExKSxhO2Nhc2UgMTpyZXR1cm4gYT1QYShhLnR5cGUsITApLGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFJhKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGEuZGlzcGxheU5hbWV8fGEubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIGE7c3dpdGNoKGEpe2Nhc2UgdWE6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2UgdGE6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIHhhOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIHdhOnJldHVyblwiU3RyaWN0TW9kZVwiO2Nhc2UgQmE6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgQ2E6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIn1pZihcIm9iamVjdFwiPT09dHlwZW9mIGEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgemE6cmV0dXJuKGEuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgeWE6cmV0dXJuKGEuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgQWE6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7XG5yZXR1cm4gYS5kaXNwbGF5TmFtZXx8KFwiXCIhPT1iP1wiRm9yd2FyZFJlZihcIitiK1wiKVwiOlwiRm9yd2FyZFJlZlwiKTtjYXNlIERhOnJldHVybiBSYShhLnR5cGUpO2Nhc2UgRmE6cmV0dXJuIFJhKGEuX3JlbmRlcik7Y2FzZSBFYTpiPWEuX3BheWxvYWQ7YT1hLl9pbml0O3RyeXtyZXR1cm4gUmEoYShiKSl9Y2F0Y2goYyl7fX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBTYShhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcInVuZGVmaW5lZFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19ZnVuY3Rpb24gVGEoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIFVhKGEpe3ZhciBiPVRhKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpe3ZhciBlPWMuZ2V0LGY9Yy5zZXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtmLmNhbGwodGhpcyxhKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZX0pO3JldHVybntnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPVxubnVsbDtkZWxldGUgYVtiXX19fX1mdW5jdGlvbiBWYShhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9VWEoYSkpfWZ1bmN0aW9uIFdhKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD1UYShhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfWZ1bmN0aW9uIFhhKGEpe2E9YXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6dm9pZCAwKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBhLmFjdGl2ZUVsZW1lbnR8fGEuYm9keX1jYXRjaChiKXtyZXR1cm4gYS5ib2R5fX1cbmZ1bmN0aW9uIFlhKGEsYil7dmFyIGM9Yi5jaGVja2VkO3JldHVybiBtKHt9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOnZvaWQgMCxjaGVja2VkOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWR9KX1mdW5jdGlvbiBaYShhLGIpe3ZhciBjPW51bGw9PWIuZGVmYXVsdFZhbHVlP1wiXCI6Yi5kZWZhdWx0VmFsdWUsZD1udWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQ7Yz1TYShudWxsIT1iLnZhbHVlP2IudmFsdWU6Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpkLGluaXRpYWxWYWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fWZ1bmN0aW9uICRhKGEsYil7Yj1iLmNoZWNrZWQ7bnVsbCE9YiYmcWEoYSxcImNoZWNrZWRcIixiLCExKX1cbmZ1bmN0aW9uIGFiKGEsYil7JGEoYSxiKTt2YXIgYz1TYShiLnZhbHVlKSxkPWIudHlwZTtpZihudWxsIT1jKWlmKFwibnVtYmVyXCI9PT1kKXtpZigwPT09YyYmXCJcIj09PWEudmFsdWV8fGEudmFsdWUhPWMpYS52YWx1ZT1cIlwiK2N9ZWxzZSBhLnZhbHVlIT09XCJcIitjJiYoYS52YWx1ZT1cIlwiK2MpO2Vsc2UgaWYoXCJzdWJtaXRcIj09PWR8fFwicmVzZXRcIj09PWQpe2EucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7cmV0dXJufWIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKT9iYihhLGIudHlwZSxjKTpiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpJiZiYihhLGIudHlwZSxTYShiLmRlZmF1bHRWYWx1ZSkpO251bGw9PWIuY2hlY2tlZCYmbnVsbCE9Yi5kZWZhdWx0Q2hlY2tlZCYmKGEuZGVmYXVsdENoZWNrZWQ9ISFiLmRlZmF1bHRDaGVja2VkKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXtpZihiLmhhc093blByb3BlcnR5KFwidmFsdWVcIil8fGIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikpe3ZhciBkPWIudHlwZTtpZighKFwic3VibWl0XCIhPT1kJiZcInJlc2V0XCIhPT1kfHx2b2lkIDAhPT1iLnZhbHVlJiZudWxsIT09Yi52YWx1ZSkpcmV0dXJuO2I9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO2N8fGI9PT1hLnZhbHVlfHwoYS52YWx1ZT1iKTthLmRlZmF1bHRWYWx1ZT1ifWM9YS5uYW1lO1wiXCIhPT1jJiYoYS5uYW1lPVwiXCIpO2EuZGVmYXVsdENoZWNrZWQ9ISFhLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XCJcIiE9PWMmJihhLm5hbWU9Yyl9XG5mdW5jdGlvbiBiYihhLGIsYyl7aWYoXCJudW1iZXJcIiE9PWJ8fFhhKGEub3duZXJEb2N1bWVudCkhPT1hKW51bGw9PWM/YS5kZWZhdWx0VmFsdWU9XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlOmEuZGVmYXVsdFZhbHVlIT09XCJcIitjJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitjKX1mdW5jdGlvbiBkYihhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsIT1hJiYoYis9YSl9KTtyZXR1cm4gYn1mdW5jdGlvbiBlYihhLGIpe2E9bSh7Y2hpbGRyZW46dm9pZCAwfSxiKTtpZihiPWRiKGIuY2hpbGRyZW4pKWEuY2hpbGRyZW49YjtyZXR1cm4gYX1cbmZ1bmN0aW9uIGZiKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitTYShjKTtiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gZ2IoYSxiKXtpZihudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKXRocm93IEVycm9yKHkoOTEpKTtyZXR1cm4gbSh7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBoYihhLGIpe3ZhciBjPWIudmFsdWU7aWYobnVsbD09Yyl7Yz1iLmNoaWxkcmVuO2I9Yi5kZWZhdWx0VmFsdWU7aWYobnVsbCE9Yyl7aWYobnVsbCE9Yil0aHJvdyBFcnJvcih5KDkyKSk7aWYoQXJyYXkuaXNBcnJheShjKSl7aWYoISgxPj1jLmxlbmd0aCkpdGhyb3cgRXJyb3IoeSg5MykpO2M9Y1swXX1iPWN9bnVsbD09YiYmKGI9XCJcIik7Yz1ifWEuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlNhKGMpfX1cbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9U2EoYi52YWx1ZSksZD1TYShiLmRlZmF1bHRWYWx1ZSk7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1jJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWQmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2QpfWZ1bmN0aW9uIGpiKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJlwiXCIhPT1iJiZudWxsIT09YiYmKGEudmFsdWU9Yil9dmFyIGtiPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIGxiKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gbWIoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2xiKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG5iLG9iPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PWtiLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle25iPW5ifHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO25iLmlubmVySFRNTD1cIjxzdmc+XCIrYi52YWx1ZU9mKCkudG9TdHJpbmcoKStcIjwvc3ZnPlwiO2ZvcihiPW5iLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIHBiKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgcWI9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwLGZpbGxPcGFjaXR5OiEwLFxuZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0scmI9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKHFiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JiLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7cWJbYl09cWJbYV19KX0pO2Z1bmN0aW9uIHNiKGEsYixjKXtyZXR1cm4gbnVsbD09Ynx8XCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJcIj09PWI/XCJcIjpjfHxcIm51bWJlclwiIT09dHlwZW9mIGJ8fDA9PT1ifHxxYi5oYXNPd25Qcm9wZXJ0eShhKSYmcWJbYV0/KFwiXCIrYikudHJpbSgpOmIrXCJweFwifVxuZnVuY3Rpb24gdGIoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpLGU9c2IoYyxiW2NdLGQpO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgdWI9bSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIHZiKGEsYil7aWYoYil7aWYodWJbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDEzNyxhKSk7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl7aWYobnVsbCE9Yi5jaGlsZHJlbil0aHJvdyBFcnJvcih5KDYwKSk7aWYoIShcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcih5KDYxKSk7fWlmKG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZSl0aHJvdyBFcnJvcih5KDYyKSk7fX1cbmZ1bmN0aW9uIHdiKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX1mdW5jdGlvbiB4YihhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHliPW51bGwsemI9bnVsbCxBYj1udWxsO1xuZnVuY3Rpb24gQmIoYSl7aWYoYT1DYihhKSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHliKXRocm93IEVycm9yKHkoMjgwKSk7dmFyIGI9YS5zdGF0ZU5vZGU7YiYmKGI9RGIoYikseWIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpKX19ZnVuY3Rpb24gRWIoYSl7emI/QWI/QWIucHVzaChhKTpBYj1bYV06emI9YX1mdW5jdGlvbiBGYigpe2lmKHpiKXt2YXIgYT16YixiPUFiO0FiPXpiPW51bGw7QmIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKUJiKGJbYV0pfX1mdW5jdGlvbiBHYihhLGIpe3JldHVybiBhKGIpfWZ1bmN0aW9uIEhiKGEsYixjLGQsZSl7cmV0dXJuIGEoYixjLGQsZSl9ZnVuY3Rpb24gSWIoKXt9dmFyIEpiPUdiLEtiPSExLExiPSExO2Z1bmN0aW9uIE1iKCl7aWYobnVsbCE9PXpifHxudWxsIT09QWIpSWIoKSxGYigpfVxuZnVuY3Rpb24gTmIoYSxiLGMpe2lmKExiKXJldHVybiBhKGIsYyk7TGI9ITA7dHJ5e3JldHVybiBKYihhLGIsYyl9ZmluYWxseXtMYj0hMSxNYigpfX1cbmZ1bmN0aW9uIE9iKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYobnVsbD09PWMpcmV0dXJuIG51bGw7dmFyIGQ9RGIoYyk7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRW50ZXJcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2lmKGMmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGMpdGhyb3cgRXJyb3IoeSgyMzEsYix0eXBlb2YgYykpO3JldHVybiBjfXZhciBQYj0hMTtpZihmYSl0cnl7dmFyIFFiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShRYixcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7UGI9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsUWIsUWIpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLFFiLFFiKX1jYXRjaChhKXtQYj0hMX1mdW5jdGlvbiBSYihhLGIsYyxkLGUsZixnLGgsayl7dmFyIGw9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMsbCl9Y2F0Y2gobil7dGhpcy5vbkVycm9yKG4pfX12YXIgU2I9ITEsVGI9bnVsbCxVYj0hMSxWYj1udWxsLFdiPXtvbkVycm9yOmZ1bmN0aW9uKGEpe1NiPSEwO1RiPWF9fTtmdW5jdGlvbiBYYihhLGIsYyxkLGUsZixnLGgsayl7U2I9ITE7VGI9bnVsbDtSYi5hcHBseShXYixhcmd1bWVudHMpfVxuZnVuY3Rpb24gWWIoYSxiLGMsZCxlLGYsZyxoLGspe1hiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihTYil7aWYoU2Ipe3ZhciBsPVRiO1NiPSExO1RiPW51bGx9ZWxzZSB0aHJvdyBFcnJvcih5KDE5OCkpO1VifHwoVWI9ITAsVmI9bCl9fWZ1bmN0aW9uIFpiKGEpe3ZhciBiPWEsYz1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7Yi5yZXR1cm47KWI9Yi5yZXR1cm47ZWxzZXthPWI7ZG8gYj1hLDAhPT0oYi5mbGFncyYxMDI2KSYmKGM9Yi5yZXR1cm4pLGE9Yi5yZXR1cm47d2hpbGUoYSl9cmV0dXJuIDM9PT1iLnRhZz9jOm51bGx9ZnVuY3Rpb24gJGIoYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9YS5tZW1vaXplZFN0YXRlO251bGw9PT1iJiYoYT1hLmFsdGVybmF0ZSxudWxsIT09YSYmKGI9YS5tZW1vaXplZFN0YXRlKSk7aWYobnVsbCE9PWIpcmV0dXJuIGIuZGVoeWRyYXRlZH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBhYyhhKXtpZihaYihhKSE9PWEpdGhyb3cgRXJyb3IoeSgxODgpKTt9XG5mdW5jdGlvbiBiYyhhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYil7Yj1aYihhKTtpZihudWxsPT09Yil0aHJvdyBFcnJvcih5KDE4OCkpO3JldHVybiBiIT09YT9udWxsOmF9Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWMucmV0dXJuO2lmKG51bGw9PT1lKWJyZWFrO3ZhciBmPWUuYWx0ZXJuYXRlO2lmKG51bGw9PT1mKXtkPWUucmV0dXJuO2lmKG51bGwhPT1kKXtjPWQ7Y29udGludWV9YnJlYWt9aWYoZS5jaGlsZD09PWYuY2hpbGQpe2ZvcihmPWUuY2hpbGQ7Zjspe2lmKGY9PT1jKXJldHVybiBhYyhlKSxhO2lmKGY9PT1kKXJldHVybiBhYyhlKSxiO2Y9Zi5zaWJsaW5nfXRocm93IEVycm9yKHkoMTg4KSk7fWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2Zvcih2YXIgZz0hMSxoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PVxuYyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpdGhyb3cgRXJyb3IoeSgxODkpKTt9fWlmKGMuYWx0ZXJuYXRlIT09ZCl0aHJvdyBFcnJvcih5KDE5MCkpO31pZigzIT09Yy50YWcpdGhyb3cgRXJyb3IoeSgxODgpKTtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIGNjKGEpe2E9YmMoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkLnJldHVybj1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBkYyhhLGIpe2Zvcih2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09Yjspe2lmKGI9PT1hfHxiPT09YylyZXR1cm4hMDtiPWIucmV0dXJufXJldHVybiExfXZhciBlYyxmYyxnYyxoYyxpYz0hMSxqYz1bXSxrYz1udWxsLGxjPW51bGwsbWM9bnVsbCxuYz1uZXcgTWFwLG9jPW5ldyBNYXAscGM9W10scWM9XCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gcmMoYSxiLGMsZCxlKXtyZXR1cm57YmxvY2tlZE9uOmEsZG9tRXZlbnROYW1lOmIsZXZlbnRTeXN0ZW1GbGFnczpjfDE2LG5hdGl2ZUV2ZW50OmUsdGFyZ2V0Q29udGFpbmVyczpbZF19fWZ1bmN0aW9uIHNjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6Y2FzZSBcImZvY3Vzb3V0XCI6a2M9bnVsbDticmVhaztjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdsZWF2ZVwiOmxjPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJtb3VzZW91dFwiOm1jPW51bGw7YnJlYWs7Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpuYy5kZWxldGUoYi5wb2ludGVySWQpO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpvYy5kZWxldGUoYi5wb2ludGVySWQpfX1cbmZ1bmN0aW9uIHRjKGEsYixjLGQsZSxmKXtpZihudWxsPT09YXx8YS5uYXRpdmVFdmVudCE9PWYpcmV0dXJuIGE9cmMoYixjLGQsZSxmKSxudWxsIT09YiYmKGI9Q2IoYiksbnVsbCE9PWImJmZjKGIpKSxhO2EuZXZlbnRTeXN0ZW1GbGFnc3w9ZDtiPWEudGFyZ2V0Q29udGFpbmVycztudWxsIT09ZSYmLTE9PT1iLmluZGV4T2YoZSkmJmIucHVzaChlKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHVjKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJmb2N1c2luXCI6cmV0dXJuIGtjPXRjKGtjLGEsYixjLGQsZSksITA7Y2FzZSBcImRyYWdlbnRlclwiOnJldHVybiBsYz10YyhsYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJtb3VzZW92ZXJcIjpyZXR1cm4gbWM9dGMobWMsYSxiLGMsZCxlKSwhMDtjYXNlIFwicG9pbnRlcm92ZXJcIjp2YXIgZj1lLnBvaW50ZXJJZDtuYy5zZXQoZix0YyhuYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSk7cmV0dXJuITA7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6cmV0dXJuIGY9ZS5wb2ludGVySWQsb2Muc2V0KGYsdGMob2MuZ2V0KGYpfHxudWxsLGEsYixjLGQsZSkpLCEwfXJldHVybiExfVxuZnVuY3Rpb24gdmMoYSl7dmFyIGI9d2MoYS50YXJnZXQpO2lmKG51bGwhPT1iKXt2YXIgYz1aYihiKTtpZihudWxsIT09YylpZihiPWMudGFnLDEzPT09Yil7aWYoYj0kYihjKSxudWxsIT09Yil7YS5ibG9ja2VkT249YjtoYyhhLmxhbmVQcmlvcml0eSxmdW5jdGlvbigpe3IudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KGEucHJpb3JpdHksZnVuY3Rpb24oKXtnYyhjKX0pfSk7cmV0dXJufX1lbHNlIGlmKDM9PT1iJiZjLnN0YXRlTm9kZS5oeWRyYXRlKXthLmJsb2NrZWRPbj0zPT09Yy50YWc/Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpudWxsO3JldHVybn19YS5ibG9ja2VkT249bnVsbH1cbmZ1bmN0aW9uIHhjKGEpe2lmKG51bGwhPT1hLmJsb2NrZWRPbilyZXR1cm4hMTtmb3IodmFyIGI9YS50YXJnZXRDb250YWluZXJzOzA8Yi5sZW5ndGg7KXt2YXIgYz15YyhhLmRvbUV2ZW50TmFtZSxhLmV2ZW50U3lzdGVtRmxhZ3MsYlswXSxhLm5hdGl2ZUV2ZW50KTtpZihudWxsIT09YylyZXR1cm4gYj1DYihjKSxudWxsIT09YiYmZmMoYiksYS5ibG9ja2VkT249YywhMTtiLnNoaWZ0KCl9cmV0dXJuITB9ZnVuY3Rpb24gemMoYSxiLGMpe3hjKGEpJiZjLmRlbGV0ZShiKX1cbmZ1bmN0aW9uIEFjKCl7Zm9yKGljPSExOzA8amMubGVuZ3RoOyl7dmFyIGE9amNbMF07aWYobnVsbCE9PWEuYmxvY2tlZE9uKXthPUNiKGEuYmxvY2tlZE9uKTtudWxsIT09YSYmZWMoYSk7YnJlYWt9Zm9yKHZhciBiPWEudGFyZ2V0Q29udGFpbmVyczswPGIubGVuZ3RoOyl7dmFyIGM9eWMoYS5kb21FdmVudE5hbWUsYS5ldmVudFN5c3RlbUZsYWdzLGJbMF0sYS5uYXRpdmVFdmVudCk7aWYobnVsbCE9PWMpe2EuYmxvY2tlZE9uPWM7YnJlYWt9Yi5zaGlmdCgpfW51bGw9PT1hLmJsb2NrZWRPbiYmamMuc2hpZnQoKX1udWxsIT09a2MmJnhjKGtjKSYmKGtjPW51bGwpO251bGwhPT1sYyYmeGMobGMpJiYobGM9bnVsbCk7bnVsbCE9PW1jJiZ4YyhtYykmJihtYz1udWxsKTtuYy5mb3JFYWNoKHpjKTtvYy5mb3JFYWNoKHpjKX1cbmZ1bmN0aW9uIEJjKGEsYil7YS5ibG9ja2VkT249PT1iJiYoYS5ibG9ja2VkT249bnVsbCxpY3x8KGljPSEwLHIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LEFjKSkpfVxuZnVuY3Rpb24gQ2MoYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gQmMoYixhKX1pZigwPGpjLmxlbmd0aCl7QmMoamNbMF0sYSk7Zm9yKHZhciBjPTE7YzxqYy5sZW5ndGg7YysrKXt2YXIgZD1qY1tjXTtkLmJsb2NrZWRPbj09PWEmJihkLmJsb2NrZWRPbj1udWxsKX19bnVsbCE9PWtjJiZCYyhrYyxhKTtudWxsIT09bGMmJkJjKGxjLGEpO251bGwhPT1tYyYmQmMobWMsYSk7bmMuZm9yRWFjaChiKTtvYy5mb3JFYWNoKGIpO2ZvcihjPTA7YzxwYy5sZW5ndGg7YysrKWQ9cGNbY10sZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCk7Zm9yKDswPHBjLmxlbmd0aCYmKGM9cGNbMF0sbnVsbD09PWMuYmxvY2tlZE9uKTspdmMoYyksbnVsbD09PWMuYmxvY2tlZE9uJiZwYy5zaGlmdCgpfVxuZnVuY3Rpb24gRGMoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtyZXR1cm4gY312YXIgRWM9e2FuaW1hdGlvbmVuZDpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjpEYyhcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OkRjKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOkRjKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sRmM9e30sR2M9e307XG5mYSYmKEdjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIEVjLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIEVjLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIEVjLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7ZnVuY3Rpb24gSGMoYSl7aWYoRmNbYV0pcmV0dXJuIEZjW2FdO2lmKCFFY1thXSlyZXR1cm4gYTt2YXIgYj1FY1thXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiBHYylyZXR1cm4gRmNbYV09YltjXTtyZXR1cm4gYX1cbnZhciBJYz1IYyhcImFuaW1hdGlvbmVuZFwiKSxKYz1IYyhcImFuaW1hdGlvbml0ZXJhdGlvblwiKSxLYz1IYyhcImFuaW1hdGlvbnN0YXJ0XCIpLExjPUhjKFwidHJhbnNpdGlvbmVuZFwiKSxNYz1uZXcgTWFwLE5jPW5ldyBNYXAsT2M9W1wiYWJvcnRcIixcImFib3J0XCIsSWMsXCJhbmltYXRpb25FbmRcIixKYyxcImFuaW1hdGlvbkl0ZXJhdGlvblwiLEtjLFwiYW5pbWF0aW9uU3RhcnRcIixcImNhbnBsYXlcIixcImNhblBsYXlcIixcImNhbnBsYXl0aHJvdWdoXCIsXCJjYW5QbGF5VGhyb3VnaFwiLFwiZHVyYXRpb25jaGFuZ2VcIixcImR1cmF0aW9uQ2hhbmdlXCIsXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCIsXCJlbmNyeXB0ZWRcIixcImVuY3J5cHRlZFwiLFwiZW5kZWRcIixcImVuZGVkXCIsXCJlcnJvclwiLFwiZXJyb3JcIixcImdvdHBvaW50ZXJjYXB0dXJlXCIsXCJnb3RQb2ludGVyQ2FwdHVyZVwiLFwibG9hZFwiLFwibG9hZFwiLFwibG9hZGVkZGF0YVwiLFwibG9hZGVkRGF0YVwiLFwibG9hZGVkbWV0YWRhdGFcIixcImxvYWRlZE1ldGFkYXRhXCIsXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiLFxuXCJsb3N0cG9pbnRlcmNhcHR1cmVcIixcImxvc3RQb2ludGVyQ2FwdHVyZVwiLFwicGxheWluZ1wiLFwicGxheWluZ1wiLFwicHJvZ3Jlc3NcIixcInByb2dyZXNzXCIsXCJzZWVraW5nXCIsXCJzZWVraW5nXCIsXCJzdGFsbGVkXCIsXCJzdGFsbGVkXCIsXCJzdXNwZW5kXCIsXCJzdXNwZW5kXCIsXCJ0aW1ldXBkYXRlXCIsXCJ0aW1lVXBkYXRlXCIsTGMsXCJ0cmFuc2l0aW9uRW5kXCIsXCJ3YWl0aW5nXCIsXCJ3YWl0aW5nXCJdO2Z1bmN0aW9uIFBjKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKz0yKXt2YXIgZD1hW2NdLGU9YVtjKzFdO2U9XCJvblwiKyhlWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSk7TmMuc2V0KGQsYik7TWMuc2V0KGQsZSk7ZGEoZSxbZF0pfX12YXIgUWM9ci51bnN0YWJsZV9ub3c7UWMoKTt2YXIgRj04O1xuZnVuY3Rpb24gUmMoYSl7aWYoMCE9PSgxJmEpKXJldHVybiBGPTE1LDE7aWYoMCE9PSgyJmEpKXJldHVybiBGPTE0LDI7aWYoMCE9PSg0JmEpKXJldHVybiBGPTEzLDQ7dmFyIGI9MjQmYTtpZigwIT09YilyZXR1cm4gRj0xMixiO2lmKDAhPT0oYSYzMikpcmV0dXJuIEY9MTEsMzI7Yj0xOTImYTtpZigwIT09YilyZXR1cm4gRj0xMCxiO2lmKDAhPT0oYSYyNTYpKXJldHVybiBGPTksMjU2O2I9MzU4NCZhO2lmKDAhPT1iKXJldHVybiBGPTgsYjtpZigwIT09KGEmNDA5NikpcmV0dXJuIEY9Nyw0MDk2O2I9NDE4NjExMiZhO2lmKDAhPT1iKXJldHVybiBGPTYsYjtiPTYyOTE0NTYwJmE7aWYoMCE9PWIpcmV0dXJuIEY9NSxiO2lmKGEmNjcxMDg4NjQpcmV0dXJuIEY9NCw2NzEwODg2NDtpZigwIT09KGEmMTM0MjE3NzI4KSlyZXR1cm4gRj0zLDEzNDIxNzcyODtiPTgwNTMwNjM2OCZhO2lmKDAhPT1iKXJldHVybiBGPTIsYjtpZigwIT09KDEwNzM3NDE4MjQmYSkpcmV0dXJuIEY9MSwxMDczNzQxODI0O1xuRj04O3JldHVybiBhfWZ1bmN0aW9uIFNjKGEpe3N3aXRjaChhKXtjYXNlIDk5OnJldHVybiAxNTtjYXNlIDk4OnJldHVybiAxMDtjYXNlIDk3OmNhc2UgOTY6cmV0dXJuIDg7Y2FzZSA5NTpyZXR1cm4gMjtkZWZhdWx0OnJldHVybiAwfX1mdW5jdGlvbiBUYyhhKXtzd2l0Y2goYSl7Y2FzZSAxNTpjYXNlIDE0OnJldHVybiA5OTtjYXNlIDEzOmNhc2UgMTI6Y2FzZSAxMTpjYXNlIDEwOnJldHVybiA5ODtjYXNlIDk6Y2FzZSA4OmNhc2UgNzpjYXNlIDY6Y2FzZSA0OmNhc2UgNTpyZXR1cm4gOTc7Y2FzZSAzOmNhc2UgMjpjYXNlIDE6cmV0dXJuIDk1O2Nhc2UgMDpyZXR1cm4gOTA7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDM1OCxhKSk7fX1cbmZ1bmN0aW9uIFVjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXM7aWYoMD09PWMpcmV0dXJuIEY9MDt2YXIgZD0wLGU9MCxmPWEuZXhwaXJlZExhbmVzLGc9YS5zdXNwZW5kZWRMYW5lcyxoPWEucGluZ2VkTGFuZXM7aWYoMCE9PWYpZD1mLGU9Rj0xNTtlbHNlIGlmKGY9YyYxMzQyMTc3MjcsMCE9PWYpe3ZhciBrPWYmfmc7MCE9PWs/KGQ9UmMoayksZT1GKTooaCY9ZiwwIT09aCYmKGQ9UmMoaCksZT1GKSl9ZWxzZSBmPWMmfmcsMCE9PWY/KGQ9UmMoZiksZT1GKTowIT09aCYmKGQ9UmMoaCksZT1GKTtpZigwPT09ZClyZXR1cm4gMDtkPTMxLVZjKGQpO2Q9YyYoKDA+ZD8wOjE8PGQpPDwxKS0xO2lmKDAhPT1iJiZiIT09ZCYmMD09PShiJmcpKXtSYyhiKTtpZihlPD1GKXJldHVybiBiO0Y9ZX1iPWEuZW50YW5nbGVkTGFuZXM7aWYoMCE9PWIpZm9yKGE9YS5lbnRhbmdsZW1lbnRzLGImPWQ7MDxiOyljPTMxLVZjKGIpLGU9MTw8YyxkfD1hW2NdLGImPX5lO3JldHVybiBkfVxuZnVuY3Rpb24gV2MoYSl7YT1hLnBlbmRpbmdMYW5lcyYtMTA3Mzc0MTgyNTtyZXR1cm4gMCE9PWE/YTphJjEwNzM3NDE4MjQ/MTA3Mzc0MTgyNDowfWZ1bmN0aW9uIFhjKGEsYil7c3dpdGNoKGEpe2Nhc2UgMTU6cmV0dXJuIDE7Y2FzZSAxNDpyZXR1cm4gMjtjYXNlIDEyOnJldHVybiBhPVljKDI0Jn5iKSwwPT09YT9YYygxMCxiKTphO2Nhc2UgMTA6cmV0dXJuIGE9WWMoMTkyJn5iKSwwPT09YT9YYyg4LGIpOmE7Y2FzZSA4OnJldHVybiBhPVljKDM1ODQmfmIpLDA9PT1hJiYoYT1ZYyg0MTg2MTEyJn5iKSwwPT09YSYmKGE9NTEyKSksYTtjYXNlIDI6cmV0dXJuIGI9WWMoODA1MzA2MzY4Jn5iKSwwPT09YiYmKGI9MjY4NDM1NDU2KSxifXRocm93IEVycm9yKHkoMzU4LGEpKTt9ZnVuY3Rpb24gWWMoYSl7cmV0dXJuIGEmLWF9ZnVuY3Rpb24gWmMoYSl7Zm9yKHZhciBiPVtdLGM9MDszMT5jO2MrKyliLnB1c2goYSk7cmV0dXJuIGJ9XG5mdW5jdGlvbiAkYyhhLGIsYyl7YS5wZW5kaW5nTGFuZXN8PWI7dmFyIGQ9Yi0xO2Euc3VzcGVuZGVkTGFuZXMmPWQ7YS5waW5nZWRMYW5lcyY9ZDthPWEuZXZlbnRUaW1lcztiPTMxLVZjKGIpO2FbYl09Y312YXIgVmM9TWF0aC5jbHozMj9NYXRoLmNsejMyOmFkLGJkPU1hdGgubG9nLGNkPU1hdGguTE4yO2Z1bmN0aW9uIGFkKGEpe3JldHVybiAwPT09YT8zMjozMS0oYmQoYSkvY2R8MCl8MH12YXIgZGQ9ci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxlZD1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxmZD0hMDtmdW5jdGlvbiBnZChhLGIsYyxkKXtLYnx8SWIoKTt2YXIgZT1oZCxmPUtiO0tiPSEwO3RyeXtIYihlLGEsYixjLGQpfWZpbmFsbHl7KEtiPWYpfHxNYigpfX1mdW5jdGlvbiBpZChhLGIsYyxkKXtlZChkZCxoZC5iaW5kKG51bGwsYSxiLGMsZCkpfVxuZnVuY3Rpb24gaGQoYSxiLGMsZCl7aWYoZmQpe3ZhciBlO2lmKChlPTA9PT0oYiY0KSkmJjA8amMubGVuZ3RoJiYtMTxxYy5pbmRleE9mKGEpKWE9cmMobnVsbCxhLGIsYyxkKSxqYy5wdXNoKGEpO2Vsc2V7dmFyIGY9eWMoYSxiLGMsZCk7aWYobnVsbD09PWYpZSYmc2MoYSxkKTtlbHNle2lmKGUpe2lmKC0xPHFjLmluZGV4T2YoYSkpe2E9cmMoZixhLGIsYyxkKTtqYy5wdXNoKGEpO3JldHVybn1pZih1YyhmLGEsYixjLGQpKXJldHVybjtzYyhhLGQpfWpkKGEsYixkLG51bGwsYyl9fX19XG5mdW5jdGlvbiB5YyhhLGIsYyxkKXt2YXIgZT14YihkKTtlPXdjKGUpO2lmKG51bGwhPT1lKXt2YXIgZj1aYihlKTtpZihudWxsPT09ZillPW51bGw7ZWxzZXt2YXIgZz1mLnRhZztpZigxMz09PWcpe2U9JGIoZik7aWYobnVsbCE9PWUpcmV0dXJuIGU7ZT1udWxsfWVsc2UgaWYoMz09PWcpe2lmKGYuc3RhdGVOb2RlLmh5ZHJhdGUpcmV0dXJuIDM9PT1mLnRhZz9mLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOm51bGw7ZT1udWxsfWVsc2UgZiE9PWUmJihlPW51bGwpfX1qZChhLGIsZCxlLGMpO3JldHVybiBudWxsfXZhciBrZD1udWxsLGxkPW51bGwsbWQ9bnVsbDtcbmZ1bmN0aW9uIG5kKCl7aWYobWQpcmV0dXJuIG1kO3ZhciBhLGI9bGQsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4ga2Q/a2QudmFsdWU6a2QudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gbWQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1mdW5jdGlvbiBvZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iOzEwPT09YSYmKGE9MTMpO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1mdW5jdGlvbiBwZCgpe3JldHVybiEwfWZ1bmN0aW9uIHFkKCl7cmV0dXJuITF9XG5mdW5jdGlvbiByZChhKXtmdW5jdGlvbiBiKGIsZCxlLGYsZyl7dGhpcy5fcmVhY3ROYW1lPWI7dGhpcy5fdGFyZ2V0SW5zdD1lO3RoaXMudHlwZT1kO3RoaXMubmF0aXZlRXZlbnQ9Zjt0aGlzLnRhcmdldD1nO3RoaXMuY3VycmVudFRhcmdldD1udWxsO2Zvcih2YXIgYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJihiPWFbY10sdGhpc1tjXT1iP2IoZik6ZltjXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWYuZGVmYXVsdFByZXZlbnRlZD9mLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1mLnJldHVyblZhbHVlKT9wZDpxZDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXFkO3JldHVybiB0aGlzfW0oYi5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJlxuKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPXBkKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXBkKX0scGVyc2lzdDpmdW5jdGlvbigpe30saXNQZXJzaXN0ZW50OnBkfSk7cmV0dXJuIGJ9XG52YXIgc2Q9e2V2ZW50UGhhc2U6MCxidWJibGVzOjAsY2FuY2VsYWJsZTowLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6MCxpc1RydXN0ZWQ6MH0sdGQ9cmQoc2QpLHVkPW0oe30sc2Qse3ZpZXc6MCxkZXRhaWw6MH0pLHZkPXJkKHVkKSx3ZCx4ZCx5ZCxBZD1tKHt9LHVkLHtzY3JlZW5YOjAsc2NyZWVuWTowLGNsaWVudFg6MCxjbGllbnRZOjAscGFnZVg6MCxwYWdlWTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGFsdEtleTowLG1ldGFLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkLGJ1dHRvbjowLGJ1dHRvbnM6MCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hLnJlbGF0ZWRUYXJnZXQ/YS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50OmEucmVsYXRlZFRhcmdldH0sbW92ZW1lbnRYOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRYXCJpblxuYSlyZXR1cm4gYS5tb3ZlbWVudFg7YSE9PXlkJiYoeWQmJlwibW91c2Vtb3ZlXCI9PT1hLnR5cGU/KHdkPWEuc2NyZWVuWC15ZC5zY3JlZW5YLHhkPWEuc2NyZWVuWS15ZC5zY3JlZW5ZKTp4ZD13ZD0wLHlkPWEpO3JldHVybiB3ZH0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe3JldHVyblwibW92ZW1lbnRZXCJpbiBhP2EubW92ZW1lbnRZOnhkfX0pLEJkPXJkKEFkKSxDZD1tKHt9LEFkLHtkYXRhVHJhbnNmZXI6MH0pLERkPXJkKENkKSxFZD1tKHt9LHVkLHtyZWxhdGVkVGFyZ2V0OjB9KSxGZD1yZChFZCksR2Q9bSh7fSxzZCx7YW5pbWF0aW9uTmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksSGQ9cmQoR2QpLElkPW0oe30sc2Qse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KSxKZD1yZChJZCksS2Q9bSh7fSxzZCx7ZGF0YTowfSksTGQ9cmQoS2QpLE1kPXtFc2M6XCJFc2NhcGVcIixcblNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LE5kPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLDExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLFxuMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifSxPZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gUGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1PZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIHpkKCl7cmV0dXJuIFBkfVxudmFyIFFkPW0oe30sdWQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9TWRbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9b2QoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP05kW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sY29kZTowLGxvY2F0aW9uOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLHJlcGVhdDowLGxvY2FsZTowLGdldE1vZGlmaWVyU3RhdGU6emQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP29kKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/b2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KSxSZD1yZChRZCksU2Q9bSh7fSxBZCx7cG9pbnRlcklkOjAsd2lkdGg6MCxoZWlnaHQ6MCxwcmVzc3VyZTowLHRhbmdlbnRpYWxQcmVzc3VyZTowLHRpbHRYOjAsdGlsdFk6MCx0d2lzdDowLHBvaW50ZXJUeXBlOjAsaXNQcmltYXJ5OjB9KSxUZD1yZChTZCksVWQ9bSh7fSx1ZCx7dG91Y2hlczowLHRhcmdldFRvdWNoZXM6MCxjaGFuZ2VkVG91Y2hlczowLGFsdEtleTowLG1ldGFLZXk6MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxnZXRNb2RpZmllclN0YXRlOnpkfSksVmQ9cmQoVWQpLFdkPW0oe30sc2Qse3Byb3BlcnR5TmFtZTowLGVsYXBzZWRUaW1lOjAscHNldWRvRWxlbWVudDowfSksWGQ9cmQoV2QpLFlkPW0oe30sQWQse2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LFxuZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOjAsZGVsdGFNb2RlOjB9KSxaZD1yZChZZCksJGQ9WzksMTMsMjcsMzJdLGFlPWZhJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxiZT1udWxsO2ZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihiZT1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBjZT1mYSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIWJlLGRlPWZhJiYoIWFlfHxiZSYmODxiZSYmMTE+PWJlKSxlZT1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxmZT0hMTtcbmZ1bmN0aW9uIGdlKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJrZXl1cFwiOnJldHVybi0xIT09JGQuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJrZXlkb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcImZvY3Vzb3V0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gaGUoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgaWU9ITE7ZnVuY3Rpb24gamUoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uZW5kXCI6cmV0dXJuIGhlKGIpO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtmZT0hMDtyZXR1cm4gZWU7Y2FzZSBcInRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09ZWUmJmZlP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGtlKGEsYil7aWYoaWUpcmV0dXJuXCJjb21wb3NpdGlvbmVuZFwiPT09YXx8IWFlJiZnZShhLGIpPyhhPW5kKCksbWQ9bGQ9a2Q9bnVsbCxpZT0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwicGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwia2V5cHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gZGUmJlwia29cIiE9PWIubG9jYWxlP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGxlPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O2Z1bmN0aW9uIG1lKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhbGVbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIG5lKGEsYixjLGQpe0ViKGQpO2I9b2UoYixcIm9uQ2hhbmdlXCIpOzA8Yi5sZW5ndGgmJihjPW5ldyB0ZChcIm9uQ2hhbmdlXCIsXCJjaGFuZ2VcIixudWxsLGMsZCksYS5wdXNoKHtldmVudDpjLGxpc3RlbmVyczpifSkpfXZhciBwZT1udWxsLHFlPW51bGw7ZnVuY3Rpb24gcmUoYSl7c2UoYSwwKX1mdW5jdGlvbiB0ZShhKXt2YXIgYj11ZShhKTtpZihXYShiKSlyZXR1cm4gYX1cbmZ1bmN0aW9uIHZlKGEsYil7aWYoXCJjaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIHdlPSExO2lmKGZhKXt2YXIgeGU7aWYoZmEpe3ZhciB5ZT1cIm9uaW5wdXRcImluIGRvY3VtZW50O2lmKCF5ZSl7dmFyIHplPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7emUuc2V0QXR0cmlidXRlKFwib25pbnB1dFwiLFwicmV0dXJuO1wiKTt5ZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgemUub25pbnB1dH14ZT15ZX1lbHNlIHhlPSExO3dlPXhlJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpfWZ1bmN0aW9uIEFlKCl7cGUmJihwZS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkscWU9cGU9bnVsbCl9ZnVuY3Rpb24gQmUoYSl7aWYoXCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJnRlKHFlKSl7dmFyIGI9W107bmUoYixxZSxhLHhiKGEpKTthPXJlO2lmKEtiKWEoYik7ZWxzZXtLYj0hMDt0cnl7R2IoYSxiKX1maW5hbGx5e0tiPSExLE1iKCl9fX19XG5mdW5jdGlvbiBDZShhLGIsYyl7XCJmb2N1c2luXCI9PT1hPyhBZSgpLHBlPWIscWU9YyxwZS5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixCZSkpOlwiZm9jdXNvdXRcIj09PWEmJkFlKCl9ZnVuY3Rpb24gRGUoYSl7aWYoXCJzZWxlY3Rpb25jaGFuZ2VcIj09PWF8fFwia2V5dXBcIj09PWF8fFwia2V5ZG93blwiPT09YSlyZXR1cm4gdGUocWUpfWZ1bmN0aW9uIEVlKGEsYil7aWYoXCJjbGlja1wiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gRmUoYSxiKXtpZihcImlucHV0XCI9PT1hfHxcImNoYW5nZVwiPT09YSlyZXR1cm4gdGUoYil9ZnVuY3Rpb24gR2UoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBIZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgT2JqZWN0LmlzP09iamVjdC5pczpHZSxJZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gSmUoYSxiKXtpZihIZShhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIUllLmNhbGwoYixjW2RdKXx8IUhlKGFbY1tkXV0sYltjW2RdXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gS2UoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gTGUoYSxiKXt2YXIgYz1LZShhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1LZShjKX19ZnVuY3Rpb24gTWUoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9NZShhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBOZSgpe2Zvcih2YXIgYT13aW5kb3csYj1YYSgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj1YYShhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBPZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIFBlPWZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsUWU9bnVsbCxSZT1udWxsLFNlPW51bGwsVGU9ITE7XG5mdW5jdGlvbiBVZShhLGIsYyl7dmFyIGQ9Yy53aW5kb3c9PT1jP2MuZG9jdW1lbnQ6OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7VGV8fG51bGw9PVFlfHxRZSE9PVhhKGQpfHwoZD1RZSxcInNlbGVjdGlvblN0YXJ0XCJpbiBkJiZPZShkKT9kPXtzdGFydDpkLnNlbGVjdGlvblN0YXJ0LGVuZDpkLnNlbGVjdGlvbkVuZH06KGQ9KGQub3duZXJEb2N1bWVudCYmZC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGQ9e2FuY2hvck5vZGU6ZC5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpkLmFuY2hvck9mZnNldCxmb2N1c05vZGU6ZC5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6ZC5mb2N1c09mZnNldH0pLFNlJiZKZShTZSxkKXx8KFNlPWQsZD1vZShSZSxcIm9uU2VsZWN0XCIpLDA8ZC5sZW5ndGgmJihiPW5ldyB0ZChcIm9uU2VsZWN0XCIsXCJzZWxlY3RcIixudWxsLGIsYyksYS5wdXNoKHtldmVudDpiLGxpc3RlbmVyczpkfSksYi50YXJnZXQ9UWUpKSl9XG5QYyhcImNhbmNlbCBjYW5jZWwgY2xpY2sgY2xpY2sgY2xvc2UgY2xvc2UgY29udGV4dG1lbnUgY29udGV4dE1lbnUgY29weSBjb3B5IGN1dCBjdXQgYXV4Y2xpY2sgYXV4Q2xpY2sgZGJsY2xpY2sgZG91YmxlQ2xpY2sgZHJhZ2VuZCBkcmFnRW5kIGRyYWdzdGFydCBkcmFnU3RhcnQgZHJvcCBkcm9wIGZvY3VzaW4gZm9jdXMgZm9jdXNvdXQgYmx1ciBpbnB1dCBpbnB1dCBpbnZhbGlkIGludmFsaWQga2V5ZG93biBrZXlEb3duIGtleXByZXNzIGtleVByZXNzIGtleXVwIGtleVVwIG1vdXNlZG93biBtb3VzZURvd24gbW91c2V1cCBtb3VzZVVwIHBhc3RlIHBhc3RlIHBhdXNlIHBhdXNlIHBsYXkgcGxheSBwb2ludGVyY2FuY2VsIHBvaW50ZXJDYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlckRvd24gcG9pbnRlcnVwIHBvaW50ZXJVcCByYXRlY2hhbmdlIHJhdGVDaGFuZ2UgcmVzZXQgcmVzZXQgc2Vla2VkIHNlZWtlZCBzdWJtaXQgc3VibWl0IHRvdWNoY2FuY2VsIHRvdWNoQ2FuY2VsIHRvdWNoZW5kIHRvdWNoRW5kIHRvdWNoc3RhcnQgdG91Y2hTdGFydCB2b2x1bWVjaGFuZ2Ugdm9sdW1lQ2hhbmdlXCIuc3BsaXQoXCIgXCIpLFxuMCk7UGMoXCJkcmFnIGRyYWcgZHJhZ2VudGVyIGRyYWdFbnRlciBkcmFnZXhpdCBkcmFnRXhpdCBkcmFnbGVhdmUgZHJhZ0xlYXZlIGRyYWdvdmVyIGRyYWdPdmVyIG1vdXNlbW92ZSBtb3VzZU1vdmUgbW91c2VvdXQgbW91c2VPdXQgbW91c2VvdmVyIG1vdXNlT3ZlciBwb2ludGVybW92ZSBwb2ludGVyTW92ZSBwb2ludGVyb3V0IHBvaW50ZXJPdXQgcG9pbnRlcm92ZXIgcG9pbnRlck92ZXIgc2Nyb2xsIHNjcm9sbCB0b2dnbGUgdG9nZ2xlIHRvdWNobW92ZSB0b3VjaE1vdmUgd2hlZWwgd2hlZWxcIi5zcGxpdChcIiBcIiksMSk7UGMoT2MsMik7Zm9yKHZhciBWZT1cImNoYW5nZSBzZWxlY3Rpb25jaGFuZ2UgdGV4dElucHV0IGNvbXBvc2l0aW9uc3RhcnQgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb251cGRhdGVcIi5zcGxpdChcIiBcIiksV2U9MDtXZTxWZS5sZW5ndGg7V2UrKylOYy5zZXQoVmVbV2VdLDApO2VhKFwib25Nb3VzZUVudGVyXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7XG5lYShcIm9uTW91c2VMZWF2ZVwiLFtcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl0pO2VhKFwib25Qb2ludGVyRW50ZXJcIixbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXSk7ZWEoXCJvblBvaW50ZXJMZWF2ZVwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtkYShcIm9uQ2hhbmdlXCIsXCJjaGFuZ2UgY2xpY2sgZm9jdXNpbiBmb2N1c291dCBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZGEoXCJvblNlbGVjdFwiLFwiZm9jdXNvdXQgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1c2luIGtleWRvd24ga2V5dXAgbW91c2Vkb3duIG1vdXNldXAgc2VsZWN0aW9uY2hhbmdlXCIuc3BsaXQoXCIgXCIpKTtkYShcIm9uQmVmb3JlSW5wdXRcIixbXCJjb21wb3NpdGlvbmVuZFwiLFwia2V5cHJlc3NcIixcInRleHRJbnB1dFwiLFwicGFzdGVcIl0pO2RhKFwib25Db21wb3NpdGlvbkVuZFwiLFwiY29tcG9zaXRpb25lbmQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO1xuZGEoXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcImNvbXBvc2l0aW9uc3RhcnQgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO2RhKFwib25Db21wb3NpdGlvblVwZGF0ZVwiLFwiY29tcG9zaXRpb251cGRhdGUgZm9jdXNvdXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIikpO3ZhciBYZT1cImFib3J0IGNhbnBsYXkgY2FucGxheXRocm91Z2ggZHVyYXRpb25jaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgbG9hZGVkZGF0YSBsb2FkZWRtZXRhZGF0YSBsb2Fkc3RhcnQgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVjaGFuZ2Ugc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcIiBcIiksWWU9bmV3IFNldChcImNhbmNlbCBjbG9zZSBpbnZhbGlkIGxvYWQgc2Nyb2xsIHRvZ2dsZVwiLnNwbGl0KFwiIFwiKS5jb25jYXQoWGUpKTtcbmZ1bmN0aW9uIFplKGEsYixjKXt2YXIgZD1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1jO1liKGQsYix2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiBzZShhLGIpe2I9MCE9PShiJjQpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdLGU9ZC5ldmVudDtkPWQubGlzdGVuZXJzO2E6e3ZhciBmPXZvaWQgMDtpZihiKWZvcih2YXIgZz1kLmxlbmd0aC0xOzA8PWc7Zy0tKXt2YXIgaD1kW2ddLGs9aC5pbnN0YW5jZSxsPWguY3VycmVudFRhcmdldDtoPWgubGlzdGVuZXI7aWYoayE9PWYmJmUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlicmVhayBhO1plKGUsaCxsKTtmPWt9ZWxzZSBmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKXtoPWRbZ107az1oLmluc3RhbmNlO2w9aC5jdXJyZW50VGFyZ2V0O2g9aC5saXN0ZW5lcjtpZihrIT09ZiYmZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGE7WmUoZSxoLGwpO2Y9a319fWlmKFViKXRocm93IGE9VmIsVWI9ITEsVmI9bnVsbCxhO31cbmZ1bmN0aW9uIEcoYSxiKXt2YXIgYz0kZShiKSxkPWErXCJfX2J1YmJsZVwiO2MuaGFzKGQpfHwoYWYoYixhLDIsITEpLGMuYWRkKGQpKX12YXIgYmY9XCJfcmVhY3RMaXN0ZW5pbmdcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtmdW5jdGlvbiBjZihhKXthW2JmXXx8KGFbYmZdPSEwLGJhLmZvckVhY2goZnVuY3Rpb24oYil7WWUuaGFzKGIpfHxkZihiLCExLGEsbnVsbCk7ZGYoYiwhMCxhLG51bGwpfSkpfVxuZnVuY3Rpb24gZGYoYSxiLGMsZCl7dmFyIGU9NDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOjAsZj1jO1wic2VsZWN0aW9uY2hhbmdlXCI9PT1hJiY5IT09Yy5ub2RlVHlwZSYmKGY9Yy5vd25lckRvY3VtZW50KTtpZihudWxsIT09ZCYmIWImJlllLmhhcyhhKSl7aWYoXCJzY3JvbGxcIiE9PWEpcmV0dXJuO2V8PTI7Zj1kfXZhciBnPSRlKGYpLGg9YStcIl9fXCIrKGI/XCJjYXB0dXJlXCI6XCJidWJibGVcIik7Zy5oYXMoaCl8fChiJiYoZXw9NCksYWYoZixhLGUsYiksZy5hZGQoaCkpfVxuZnVuY3Rpb24gYWYoYSxiLGMsZCl7dmFyIGU9TmMuZ2V0KGIpO3N3aXRjaCh2b2lkIDA9PT1lPzI6ZSl7Y2FzZSAwOmU9Z2Q7YnJlYWs7Y2FzZSAxOmU9aWQ7YnJlYWs7ZGVmYXVsdDplPWhkfWM9ZS5iaW5kKG51bGwsYixjLGEpO2U9dm9pZCAwOyFQYnx8XCJ0b3VjaHN0YXJ0XCIhPT1iJiZcInRvdWNobW92ZVwiIT09YiYmXCJ3aGVlbFwiIT09Ynx8KGU9ITApO2Q/dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtjYXB0dXJlOiEwLHBhc3NpdmU6ZX0pOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITApOnZvaWQgMCE9PWU/YS5hZGRFdmVudExpc3RlbmVyKGIsYyx7cGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBqZChhLGIsYyxkLGUpe3ZhciBmPWQ7aWYoMD09PShiJjEpJiYwPT09KGImMikmJm51bGwhPT1kKWE6Zm9yKDs7KXtpZihudWxsPT09ZClyZXR1cm47dmFyIGc9ZC50YWc7aWYoMz09PWd8fDQ9PT1nKXt2YXIgaD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGg9PT1lfHw4PT09aC5ub2RlVHlwZSYmaC5wYXJlbnROb2RlPT09ZSlicmVhaztpZig0PT09Zylmb3IoZz1kLnJldHVybjtudWxsIT09Zzspe3ZhciBrPWcudGFnO2lmKDM9PT1rfHw0PT09aylpZihrPWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saz09PWV8fDg9PT1rLm5vZGVUeXBlJiZrLnBhcmVudE5vZGU9PT1lKXJldHVybjtnPWcucmV0dXJufWZvcig7bnVsbCE9PWg7KXtnPXdjKGgpO2lmKG51bGw9PT1nKXJldHVybjtrPWcudGFnO2lmKDU9PT1rfHw2PT09ayl7ZD1mPWc7Y29udGludWUgYX1oPWgucGFyZW50Tm9kZX19ZD1kLnJldHVybn1OYihmdW5jdGlvbigpe3ZhciBkPWYsZT14YihjKSxnPVtdO1xuYTp7dmFyIGg9TWMuZ2V0KGEpO2lmKHZvaWQgMCE9PWgpe3ZhciBrPXRkLHg9YTtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PW9kKGMpKWJyZWFrIGE7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjprPVJkO2JyZWFrO2Nhc2UgXCJmb2N1c2luXCI6eD1cImZvY3VzXCI7az1GZDticmVhaztjYXNlIFwiZm9jdXNvdXRcIjp4PVwiYmx1clwiO2s9RmQ7YnJlYWs7Y2FzZSBcImJlZm9yZWJsdXJcIjpjYXNlIFwiYWZ0ZXJibHVyXCI6az1GZDticmVhaztjYXNlIFwiY2xpY2tcIjppZigyPT09Yy5idXR0b24pYnJlYWsgYTtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOms9QmQ7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6az1cbkRkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOms9VmQ7YnJlYWs7Y2FzZSBJYzpjYXNlIEpjOmNhc2UgS2M6az1IZDticmVhaztjYXNlIExjOms9WGQ7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOms9dmQ7YnJlYWs7Y2FzZSBcIndoZWVsXCI6az1aZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjprPUpkO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOms9VGR9dmFyIHc9MCE9PShiJjQpLHo9IXcmJlwic2Nyb2xsXCI9PT1hLHU9dz9udWxsIT09aD9oK1wiQ2FwdHVyZVwiOm51bGw6aDt3PVtdO2Zvcih2YXIgdD1kLHE7bnVsbCE9PVxudDspe3E9dDt2YXIgdj1xLnN0YXRlTm9kZTs1PT09cS50YWcmJm51bGwhPT12JiYocT12LG51bGwhPT11JiYodj1PYih0LHUpLG51bGwhPXYmJncucHVzaChlZih0LHYscSkpKSk7aWYoeilicmVhazt0PXQucmV0dXJufTA8dy5sZW5ndGgmJihoPW5ldyBrKGgseCxudWxsLGMsZSksZy5wdXNoKHtldmVudDpoLGxpc3RlbmVyczp3fSkpfX1pZigwPT09KGImNykpe2E6e2g9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWE7az1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoaCYmMD09PShiJjE2KSYmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KSYmKHdjKHgpfHx4W2ZmXSkpYnJlYWsgYTtpZihrfHxoKXtoPWUud2luZG93PT09ZT9lOihoPWUub3duZXJEb2N1bWVudCk/aC5kZWZhdWx0Vmlld3x8aC5wYXJlbnRXaW5kb3c6d2luZG93O2lmKGspe2lmKHg9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCxrPWQseD14P3djKHgpOm51bGwsbnVsbCE9PVxueCYmKHo9WmIoeCkseCE9PXp8fDUhPT14LnRhZyYmNiE9PXgudGFnKSl4PW51bGx9ZWxzZSBrPW51bGwseD1kO2lmKGshPT14KXt3PUJkO3Y9XCJvbk1vdXNlTGVhdmVcIjt1PVwib25Nb3VzZUVudGVyXCI7dD1cIm1vdXNlXCI7aWYoXCJwb2ludGVyb3V0XCI9PT1hfHxcInBvaW50ZXJvdmVyXCI9PT1hKXc9VGQsdj1cIm9uUG9pbnRlckxlYXZlXCIsdT1cIm9uUG9pbnRlckVudGVyXCIsdD1cInBvaW50ZXJcIjt6PW51bGw9PWs/aDp1ZShrKTtxPW51bGw9PXg/aDp1ZSh4KTtoPW5ldyB3KHYsdCtcImxlYXZlXCIsayxjLGUpO2gudGFyZ2V0PXo7aC5yZWxhdGVkVGFyZ2V0PXE7dj1udWxsO3djKGUpPT09ZCYmKHc9bmV3IHcodSx0K1wiZW50ZXJcIix4LGMsZSksdy50YXJnZXQ9cSx3LnJlbGF0ZWRUYXJnZXQ9eix2PXcpO3o9djtpZihrJiZ4KWI6e3c9azt1PXg7dD0wO2ZvcihxPXc7cTtxPWdmKHEpKXQrKztxPTA7Zm9yKHY9dTt2O3Y9Z2YodikpcSsrO2Zvcig7MDx0LXE7KXc9Z2YodyksdC0tO2Zvcig7MDxxLXQ7KXU9XG5nZih1KSxxLS07Zm9yKDt0LS07KXtpZih3PT09dXx8bnVsbCE9PXUmJnc9PT11LmFsdGVybmF0ZSlicmVhayBiO3c9Z2Yodyk7dT1nZih1KX13PW51bGx9ZWxzZSB3PW51bGw7bnVsbCE9PWsmJmhmKGcsaCxrLHcsITEpO251bGwhPT14JiZudWxsIT09eiYmaGYoZyx6LHgsdywhMCl9fX1hOntoPWQ/dWUoZCk6d2luZG93O2s9aC5ub2RlTmFtZSYmaC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1rfHxcImlucHV0XCI9PT1rJiZcImZpbGVcIj09PWgudHlwZSl2YXIgSj12ZTtlbHNlIGlmKG1lKGgpKWlmKHdlKUo9RmU7ZWxzZXtKPURlO3ZhciBLPUNlfWVsc2Uoaz1oLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09ay50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09aC50eXBlfHxcInJhZGlvXCI9PT1oLnR5cGUpJiYoSj1FZSk7aWYoSiYmKEo9SihhLGQpKSl7bmUoZyxKLGMsZSk7YnJlYWsgYX1LJiZLKGEsaCxkKTtcImZvY3Vzb3V0XCI9PT1hJiYoSz1oLl93cmFwcGVyU3RhdGUpJiZcbksuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmYmIoaCxcIm51bWJlclwiLGgudmFsdWUpfUs9ZD91ZShkKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c2luXCI6aWYobWUoSyl8fFwidHJ1ZVwiPT09Sy5jb250ZW50RWRpdGFibGUpUWU9SyxSZT1kLFNlPW51bGw7YnJlYWs7Y2FzZSBcImZvY3Vzb3V0XCI6U2U9UmU9UWU9bnVsbDticmVhaztjYXNlIFwibW91c2Vkb3duXCI6VGU9ITA7YnJlYWs7Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwiZHJhZ2VuZFwiOlRlPSExO1VlKGcsYyxlKTticmVhaztjYXNlIFwic2VsZWN0aW9uY2hhbmdlXCI6aWYoUGUpYnJlYWs7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjpVZShnLGMsZSl9dmFyIFE7aWYoYWUpYjp7c3dpdGNoKGEpe2Nhc2UgXCJjb21wb3NpdGlvbnN0YXJ0XCI6dmFyIEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOkw9XCJvbkNvbXBvc2l0aW9uRW5kXCI7YnJlYWsgYjtcbmNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOkw9XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCI7YnJlYWsgYn1MPXZvaWQgMH1lbHNlIGllP2dlKGEsYykmJihMPVwib25Db21wb3NpdGlvbkVuZFwiKTpcImtleWRvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKEw9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIik7TCYmKGRlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGllfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09TD9cIm9uQ29tcG9zaXRpb25FbmRcIj09PUwmJmllJiYoUT1uZCgpKTooa2Q9ZSxsZD1cInZhbHVlXCJpbiBrZD9rZC52YWx1ZTprZC50ZXh0Q29udGVudCxpZT0hMCkpLEs9b2UoZCxMKSwwPEsubGVuZ3RoJiYoTD1uZXcgTGQoTCxhLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OkwsbGlzdGVuZXJzOkt9KSxRP0wuZGF0YT1ROihRPWhlKGMpLG51bGwhPT1RJiYoTC5kYXRhPVEpKSkpO2lmKFE9Y2U/amUoYSxjKTprZShhLGMpKWQ9b2UoZCxcIm9uQmVmb3JlSW5wdXRcIiksMDxkLmxlbmd0aCYmKGU9bmV3IExkKFwib25CZWZvcmVJbnB1dFwiLFxuXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9USl9c2UoZyxiKX0pfWZ1bmN0aW9uIGVmKGEsYixjKXtyZXR1cm57aW5zdGFuY2U6YSxsaXN0ZW5lcjpiLGN1cnJlbnRUYXJnZXQ6Y319ZnVuY3Rpb24gb2UoYSxiKXtmb3IodmFyIGM9YitcIkNhcHR1cmVcIixkPVtdO251bGwhPT1hOyl7dmFyIGU9YSxmPWUuc3RhdGVOb2RlOzU9PT1lLnRhZyYmbnVsbCE9PWYmJihlPWYsZj1PYihhLGMpLG51bGwhPWYmJmQudW5zaGlmdChlZihhLGYsZSkpLGY9T2IoYSxiKSxudWxsIT1mJiZkLnB1c2goZWYoYSxmLGUpKSk7YT1hLnJldHVybn1yZXR1cm4gZH1mdW5jdGlvbiBnZihhKXtpZihudWxsPT09YSlyZXR1cm4gbnVsbDtkbyBhPWEucmV0dXJuO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfVxuZnVuY3Rpb24gaGYoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yi5fcmVhY3ROYW1lLGc9W107bnVsbCE9PWMmJmMhPT1kOyl7dmFyIGg9YyxrPWguYWx0ZXJuYXRlLGw9aC5zdGF0ZU5vZGU7aWYobnVsbCE9PWsmJms9PT1kKWJyZWFrOzU9PT1oLnRhZyYmbnVsbCE9PWwmJihoPWwsZT8oaz1PYihjLGYpLG51bGwhPWsmJmcudW5zaGlmdChlZihjLGssaCkpKTplfHwoaz1PYihjLGYpLG51bGwhPWsmJmcucHVzaChlZihjLGssaCkpKSk7Yz1jLnJldHVybn0wIT09Zy5sZW5ndGgmJmEucHVzaCh7ZXZlbnQ6YixsaXN0ZW5lcnM6Z30pfWZ1bmN0aW9uIGpmKCl7fXZhciBrZj1udWxsLGxmPW51bGw7ZnVuY3Rpb24gbWYoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpyZXR1cm4hIWIuYXV0b0ZvY3VzfXJldHVybiExfVxuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm9wdGlvblwiPT09YXx8XCJub3NjcmlwdFwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9PWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfXZhciBvZj1cImZ1bmN0aW9uXCI9PT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OnZvaWQgMCxwZj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp2b2lkIDA7ZnVuY3Rpb24gcWYoYSl7MT09PWEubm9kZVR5cGU/YS50ZXh0Q29udGVudD1cIlwiOjk9PT1hLm5vZGVUeXBlJiYoYT1hLmJvZHksbnVsbCE9YSYmKGEudGV4dENvbnRlbnQ9XCJcIikpfVxuZnVuY3Rpb24gcmYoYSl7Zm9yKDtudWxsIT1hO2E9YS5uZXh0U2libGluZyl7dmFyIGI9YS5ub2RlVHlwZTtpZigxPT09Ynx8Mz09PWIpYnJlYWt9cmV0dXJuIGF9ZnVuY3Rpb24gc2YoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIHRmPTA7ZnVuY3Rpb24gdWYoYSl7cmV0dXJueyQkdHlwZW9mOkdhLHRvU3RyaW5nOmEsdmFsdWVPZjphfX12YXIgdmY9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksd2Y9XCJfX3JlYWN0RmliZXIkXCIrdmYseGY9XCJfX3JlYWN0UHJvcHMkXCIrdmYsZmY9XCJfX3JlYWN0Q29udGFpbmVyJFwiK3ZmLHlmPVwiX19yZWFjdEV2ZW50cyRcIit2ZjtcbmZ1bmN0aW9uIHdjKGEpe3ZhciBiPWFbd2ZdO2lmKGIpcmV0dXJuIGI7Zm9yKHZhciBjPWEucGFyZW50Tm9kZTtjOyl7aWYoYj1jW2ZmXXx8Y1t3Zl0pe2M9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWIuY2hpbGR8fG51bGwhPT1jJiZudWxsIT09Yy5jaGlsZClmb3IoYT1zZihhKTtudWxsIT09YTspe2lmKGM9YVt3Zl0pcmV0dXJuIGM7YT1zZihhKX1yZXR1cm4gYn1hPWM7Yz1hLnBhcmVudE5vZGV9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQ2IoYSl7YT1hW3dmXXx8YVtmZl07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnJiYxMyE9PWEudGFnJiYzIT09YS50YWc/bnVsbDphfWZ1bmN0aW9uIHVlKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTt0aHJvdyBFcnJvcih5KDMzKSk7fWZ1bmN0aW9uIERiKGEpe3JldHVybiBhW3hmXXx8bnVsbH1cbmZ1bmN0aW9uICRlKGEpe3ZhciBiPWFbeWZdO3ZvaWQgMD09PWImJihiPWFbeWZdPW5ldyBTZXQpO3JldHVybiBifXZhciB6Zj1bXSxBZj0tMTtmdW5jdGlvbiBCZihhKXtyZXR1cm57Y3VycmVudDphfX1mdW5jdGlvbiBIKGEpezA+QWZ8fChhLmN1cnJlbnQ9emZbQWZdLHpmW0FmXT1udWxsLEFmLS0pfWZ1bmN0aW9uIEkoYSxiKXtBZisrO3pmW0FmXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIENmPXt9LE09QmYoQ2YpLE49QmYoITEpLERmPUNmO1xuZnVuY3Rpb24gRWYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBDZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBGZihhKXthPWEuY2hpbGRDb250ZXh0VHlwZXM7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hfWZ1bmN0aW9uIEdmKCl7SChOKTtIKE0pfWZ1bmN0aW9uIEhmKGEsYixjKXtpZihNLmN1cnJlbnQhPT1DZil0aHJvdyBFcnJvcih5KDE2OCkpO0koTSxiKTtJKE4sYyl9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7YT1iLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBkLmdldENoaWxkQ29udGV4dClyZXR1cm4gYztkPWQuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGQpaWYoIShlIGluIGEpKXRocm93IEVycm9yKHkoMTA4LFJhKGIpfHxcIlVua25vd25cIixlKSk7cmV0dXJuIG0oe30sYyxkKX1mdW5jdGlvbiBKZihhKXthPShhPWEuc3RhdGVOb2RlKSYmYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8Q2Y7RGY9TS5jdXJyZW50O0koTSxhKTtJKE4sTi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBLZihhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IoeSgxNjkpKTtjPyhhPUlmKGEsYixEZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEgoTiksSChNKSxJKE0sYSkpOkgoTik7SShOLGMpfVxudmFyIExmPW51bGwsTWY9bnVsbCxOZj1yLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxPZj1yLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssUGY9ci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxRZj1yLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFJmPXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFNmPXIudW5zdGFibGVfbm93LFRmPXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsVWY9ci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxWZj1yLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFdmPXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksWGY9ci51bnN0YWJsZV9Mb3dQcmlvcml0eSxZZj1yLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxaZj17fSwkZj12b2lkIDAhPT1SZj9SZjpmdW5jdGlvbigpe30sYWc9bnVsbCxiZz1udWxsLGNnPSExLGRnPVNmKCksTz0xRTQ+ZGc/U2Y6ZnVuY3Rpb24oKXtyZXR1cm4gU2YoKS1kZ307XG5mdW5jdGlvbiBlZygpe3N3aXRjaChUZigpKXtjYXNlIFVmOnJldHVybiA5OTtjYXNlIFZmOnJldHVybiA5ODtjYXNlIFdmOnJldHVybiA5NztjYXNlIFhmOnJldHVybiA5NjtjYXNlIFlmOnJldHVybiA5NTtkZWZhdWx0OnRocm93IEVycm9yKHkoMzMyKSk7fX1mdW5jdGlvbiBmZyhhKXtzd2l0Y2goYSl7Y2FzZSA5OTpyZXR1cm4gVWY7Y2FzZSA5ODpyZXR1cm4gVmY7Y2FzZSA5NzpyZXR1cm4gV2Y7Y2FzZSA5NjpyZXR1cm4gWGY7Y2FzZSA5NTpyZXR1cm4gWWY7ZGVmYXVsdDp0aHJvdyBFcnJvcih5KDMzMikpO319ZnVuY3Rpb24gZ2coYSxiKXthPWZnKGEpO3JldHVybiBOZihhLGIpfWZ1bmN0aW9uIGhnKGEsYixjKXthPWZnKGEpO3JldHVybiBPZihhLGIsYyl9ZnVuY3Rpb24gaWcoKXtpZihudWxsIT09Ymcpe3ZhciBhPWJnO2JnPW51bGw7UGYoYSl9amcoKX1cbmZ1bmN0aW9uIGpnKCl7aWYoIWNnJiZudWxsIT09YWcpe2NnPSEwO3ZhciBhPTA7dHJ5e3ZhciBiPWFnO2dnKDk5LGZ1bmN0aW9uKCl7Zm9yKDthPGIubGVuZ3RoO2ErKyl7dmFyIGM9YlthXTtkbyBjPWMoITApO3doaWxlKG51bGwhPT1jKX19KTthZz1udWxsfWNhdGNoKGMpe3Rocm93IG51bGwhPT1hZyYmKGFnPWFnLnNsaWNlKGErMSkpLE9mKFVmLGlnKSxjO31maW5hbGx5e2NnPSExfX19dmFyIGtnPXJhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO2Z1bmN0aW9uIGxnKGEsYil7aWYoYSYmYS5kZWZhdWx0UHJvcHMpe2I9bSh7fSxiKTthPWEuZGVmYXVsdFByb3BzO2Zvcih2YXIgYyBpbiBhKXZvaWQgMD09PWJbY10mJihiW2NdPWFbY10pO3JldHVybiBifXJldHVybiBifXZhciBtZz1CZihudWxsKSxuZz1udWxsLG9nPW51bGwscGc9bnVsbDtmdW5jdGlvbiBxZygpe3BnPW9nPW5nPW51bGx9XG5mdW5jdGlvbiByZyhhKXt2YXIgYj1tZy5jdXJyZW50O0gobWcpO2EudHlwZS5fY29udGV4dC5fY3VycmVudFZhbHVlPWJ9ZnVuY3Rpb24gc2coYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5hbHRlcm5hdGU7aWYoKGEuY2hpbGRMYW5lcyZiKT09PWIpaWYobnVsbD09PWN8fChjLmNoaWxkTGFuZXMmYik9PT1iKWJyZWFrO2Vsc2UgYy5jaGlsZExhbmVzfD1iO2Vsc2UgYS5jaGlsZExhbmVzfD1iLG51bGwhPT1jJiYoYy5jaGlsZExhbmVzfD1iKTthPWEucmV0dXJufX1mdW5jdGlvbiB0ZyhhLGIpe25nPWE7cGc9b2c9bnVsbDthPWEuZGVwZW5kZW5jaWVzO251bGwhPT1hJiZudWxsIT09YS5maXJzdENvbnRleHQmJigwIT09KGEubGFuZXMmYikmJih1Zz0hMCksYS5maXJzdENvbnRleHQ9bnVsbCl9XG5mdW5jdGlvbiB2ZyhhLGIpe2lmKHBnIT09YSYmITEhPT1iJiYwIT09Yil7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBifHwxMDczNzQxODIzPT09YilwZz1hLGI9MTA3Mzc0MTgyMztiPXtjb250ZXh0OmEsb2JzZXJ2ZWRCaXRzOmIsbmV4dDpudWxsfTtpZihudWxsPT09b2cpe2lmKG51bGw9PT1uZyl0aHJvdyBFcnJvcih5KDMwOCkpO29nPWI7bmcuZGVwZW5kZW5jaWVzPXtsYW5lczowLGZpcnN0Q29udGV4dDpiLHJlc3BvbmRlcnM6bnVsbH19ZWxzZSBvZz1vZy5uZXh0PWJ9cmV0dXJuIGEuX2N1cnJlbnRWYWx1ZX12YXIgd2c9ITE7ZnVuY3Rpb24geGcoYSl7YS51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEubWVtb2l6ZWRTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bnVsbCxsYXN0QmFzZVVwZGF0ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsfSxlZmZlY3RzOm51bGx9fVxuZnVuY3Rpb24geWcoYSxiKXthPWEudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT09PWEmJihiLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RCYXNlVXBkYXRlOmEuZmlyc3RCYXNlVXBkYXRlLGxhc3RCYXNlVXBkYXRlOmEubGFzdEJhc2VVcGRhdGUsc2hhcmVkOmEuc2hhcmVkLGVmZmVjdHM6YS5lZmZlY3RzfSl9ZnVuY3Rpb24gemcoYSxiKXtyZXR1cm57ZXZlbnRUaW1lOmEsbGFuZTpiLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbH19ZnVuY3Rpb24gQWcoYSxiKXthPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWEpe2E9YS5zaGFyZWQ7dmFyIGM9YS5wZW5kaW5nO251bGw9PT1jP2IubmV4dD1iOihiLm5leHQ9Yy5uZXh0LGMubmV4dD1iKTthLnBlbmRpbmc9Yn19XG5mdW5jdGlvbiBCZyhhLGIpe3ZhciBjPWEudXBkYXRlUXVldWUsZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZCYmKGQ9ZC51cGRhdGVRdWV1ZSxjPT09ZCkpe3ZhciBlPW51bGwsZj1udWxsO2M9Yy5maXJzdEJhc2VVcGRhdGU7aWYobnVsbCE9PWMpe2Rve3ZhciBnPXtldmVudFRpbWU6Yy5ldmVudFRpbWUsbGFuZTpjLmxhbmUsdGFnOmMudGFnLHBheWxvYWQ6Yy5wYXlsb2FkLGNhbGxiYWNrOmMuY2FsbGJhY2ssbmV4dDpudWxsfTtudWxsPT09Zj9lPWY9ZzpmPWYubmV4dD1nO2M9Yy5uZXh0fXdoaWxlKG51bGwhPT1jKTtudWxsPT09Zj9lPWY9YjpmPWYubmV4dD1ifWVsc2UgZT1mPWI7Yz17YmFzZVN0YXRlOmQuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTplLGxhc3RCYXNlVXBkYXRlOmYsc2hhcmVkOmQuc2hhcmVkLGVmZmVjdHM6ZC5lZmZlY3RzfTthLnVwZGF0ZVF1ZXVlPWM7cmV0dXJufWE9Yy5sYXN0QmFzZVVwZGF0ZTtudWxsPT09YT9jLmZpcnN0QmFzZVVwZGF0ZT1iOmEubmV4dD1cbmI7Yy5sYXN0QmFzZVVwZGF0ZT1ifVxuZnVuY3Rpb24gQ2coYSxiLGMsZCl7dmFyIGU9YS51cGRhdGVRdWV1ZTt3Zz0hMTt2YXIgZj1lLmZpcnN0QmFzZVVwZGF0ZSxnPWUubGFzdEJhc2VVcGRhdGUsaD1lLnNoYXJlZC5wZW5kaW5nO2lmKG51bGwhPT1oKXtlLnNoYXJlZC5wZW5kaW5nPW51bGw7dmFyIGs9aCxsPWsubmV4dDtrLm5leHQ9bnVsbDtudWxsPT09Zz9mPWw6Zy5uZXh0PWw7Zz1rO3ZhciBuPWEuYWx0ZXJuYXRlO2lmKG51bGwhPT1uKXtuPW4udXBkYXRlUXVldWU7dmFyIEE9bi5sYXN0QmFzZVVwZGF0ZTtBIT09ZyYmKG51bGw9PT1BP24uZmlyc3RCYXNlVXBkYXRlPWw6QS5uZXh0PWwsbi5sYXN0QmFzZVVwZGF0ZT1rKX19aWYobnVsbCE9PWYpe0E9ZS5iYXNlU3RhdGU7Zz0wO249bD1rPW51bGw7ZG97aD1mLmxhbmU7dmFyIHA9Zi5ldmVudFRpbWU7aWYoKGQmaCk9PT1oKXtudWxsIT09biYmKG49bi5uZXh0PXtldmVudFRpbWU6cCxsYW5lOjAsdGFnOmYudGFnLHBheWxvYWQ6Zi5wYXlsb2FkLGNhbGxiYWNrOmYuY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgQz1hLHg9ZjtoPWI7cD1jO3N3aXRjaCh4LnRhZyl7Y2FzZSAxOkM9eC5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBDKXtBPUMuY2FsbChwLEEsaCk7YnJlYWsgYX1BPUM7YnJlYWsgYTtjYXNlIDM6Qy5mbGFncz1DLmZsYWdzJi00MDk3fDY0O2Nhc2UgMDpDPXgucGF5bG9hZDtoPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDP0MuY2FsbChwLEEsaCk6QztpZihudWxsPT09aHx8dm9pZCAwPT09aClicmVhayBhO0E9bSh7fSxBLGgpO2JyZWFrIGE7Y2FzZSAyOndnPSEwfX1udWxsIT09Zi5jYWxsYmFjayYmKGEuZmxhZ3N8PTMyLGg9ZS5lZmZlY3RzLG51bGw9PT1oP2UuZWZmZWN0cz1bZl06aC5wdXNoKGYpKX1lbHNlIHA9e2V2ZW50VGltZTpwLGxhbmU6aCx0YWc6Zi50YWcscGF5bG9hZDpmLnBheWxvYWQsY2FsbGJhY2s6Zi5jYWxsYmFjayxuZXh0Om51bGx9LG51bGw9PT1uPyhsPW49cCxrPUEpOm49bi5uZXh0PXAsZ3w9aDtmPWYubmV4dDtpZihudWxsPT09XG5mKWlmKGg9ZS5zaGFyZWQucGVuZGluZyxudWxsPT09aClicmVhaztlbHNlIGY9aC5uZXh0LGgubmV4dD1udWxsLGUubGFzdEJhc2VVcGRhdGU9aCxlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSk7bnVsbD09PW4mJihrPUEpO2UuYmFzZVN0YXRlPWs7ZS5maXJzdEJhc2VVcGRhdGU9bDtlLmxhc3RCYXNlVXBkYXRlPW47RGd8PWc7YS5sYW5lcz1nO2EubWVtb2l6ZWRTdGF0ZT1BfX1mdW5jdGlvbiBFZyhhLGIsYyl7YT1iLmVmZmVjdHM7Yi5lZmZlY3RzPW51bGw7aWYobnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXSxlPWQuY2FsbGJhY2s7aWYobnVsbCE9PWUpe2QuY2FsbGJhY2s9bnVsbDtkPWM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGUpdGhyb3cgRXJyb3IoeSgxOTEsZSkpO2UuY2FsbChkKX19fXZhciBGZz0obmV3IGFhLkNvbXBvbmVudCkucmVmcztcbmZ1bmN0aW9uIEdnKGEsYixjLGQpe2I9YS5tZW1vaXplZFN0YXRlO2M9YyhkLGIpO2M9bnVsbD09PWN8fHZvaWQgMD09PWM/YjptKHt9LGIsYyk7YS5tZW1vaXplZFN0YXRlPWM7MD09PWEubGFuZXMmJihhLnVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZT1jKX1cbnZhciBLZz17aXNNb3VudGVkOmZ1bmN0aW9uKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxzKT9aYihhKT09PWE6ITF9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtBZyhhLGYpO0pnKGEsZSxkKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihhLGIsYyl7YT1hLl9yZWFjdEludGVybmFsczt2YXIgZD1IZygpLGU9SWcoYSksZj16ZyhkLGUpO2YudGFnPTE7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO0FnKGEsZik7SmcoYSxlLGQpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYSxiKXthPWEuX3JlYWN0SW50ZXJuYWxzO3ZhciBjPUhnKCksZD1JZyhhKSxlPXpnKGMsZCk7ZS50YWc9Mjt2b2lkIDAhPT1iJiZudWxsIT09YiYmKGUuY2FsbGJhY2s9XG5iKTtBZyhhLGUpO0pnKGEsZCxjKX19O2Z1bmN0aW9uIExnKGEsYixjLGQsZSxmLGcpe2E9YS5zdGF0ZU5vZGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGEuc2hvdWxkQ29tcG9uZW50VXBkYXRlP2Euc2hvdWxkQ29tcG9uZW50VXBkYXRlKGQsZixnKTpiLnByb3RvdHlwZSYmYi5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IUplKGMsZCl8fCFKZShlLGYpOiEwfVxuZnVuY3Rpb24gTWcoYSxiLGMpe3ZhciBkPSExLGU9Q2Y7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2Y9dmcoZik6KGU9RmYoYik/RGY6TS5jdXJyZW50LGQ9Yi5jb250ZXh0VHlwZXMsZj0oZD1udWxsIT09ZCYmdm9pZCAwIT09ZCk/RWYoYSxlKTpDZik7Yj1uZXcgYihjLGYpO2EubWVtb2l6ZWRTdGF0ZT1udWxsIT09Yi5zdGF0ZSYmdm9pZCAwIT09Yi5zdGF0ZT9iLnN0YXRlOm51bGw7Yi51cGRhdGVyPUtnO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbHM9YTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWYpO3JldHVybiBifVxuZnVuY3Rpb24gTmcoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gT2coYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGU7ZS5wcm9wcz1jO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2UucmVmcz1GZzt4ZyhhKTt2YXIgZj1iLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY/ZS5jb250ZXh0PXZnKGYpOihmPUZmKGIpP0RmOk0uY3VycmVudCxlLmNvbnRleHQ9RWYoYSxmKSk7Q2coYSxjLGUsZCk7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7Zj1iLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKEdnKGEsYixmLGMpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHN8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnR8fFxuKGI9ZS5zdGF0ZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnRXaWxsTW91bnQmJmUuY29tcG9uZW50V2lsbE1vdW50KCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCksYiE9PWUuc3RhdGUmJktnLmVucXVldWVSZXBsYWNlU3RhdGUoZSxlLnN0YXRlLG51bGwpLENnKGEsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5jb21wb25lbnREaWRNb3VudCYmKGEuZmxhZ3N8PTQpfXZhciBQZz1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gUWcoYSxiLGMpe2E9Yy5yZWY7aWYobnVsbCE9PWEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZcIm9iamVjdFwiIT09dHlwZW9mIGEpe2lmKGMuX293bmVyKXtjPWMuX293bmVyO2lmKGMpe2lmKDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDMwOSkpO3ZhciBkPWMuc3RhdGVOb2RlfWlmKCFkKXRocm93IEVycm9yKHkoMTQ3LGEpKTt2YXIgZT1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM7Yj09PUZnJiYoYj1kLnJlZnM9e30pO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07Yi5fc3RyaW5nUmVmPWU7cmV0dXJuIGJ9aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKXRocm93IEVycm9yKHkoMjg0KSk7aWYoIWMuX293bmVyKXRocm93IEVycm9yKHkoMjkwLGEpKTt9cmV0dXJuIGF9XG5mdW5jdGlvbiBSZyhhLGIpe2lmKFwidGV4dGFyZWFcIiE9PWEudHlwZSl0aHJvdyBFcnJvcih5KDMxLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YikpO31cbmZ1bmN0aW9uIFNnKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZmxhZ3M9OH19ZnVuY3Rpb24gYyhjLGQpe2lmKCFhKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWIoYyxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZShhLGIpe2E9VGcoYSxiKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZmxhZ3M9MixcbmMpOmQ7Yi5mbGFncz0yO3JldHVybiBjfWZ1bmN0aW9uIGcoYil7YSYmbnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5mbGFncz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9VWcoYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gayhhLGIsYyxkKXtpZihudWxsIT09YiYmYi5lbGVtZW50VHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyksZC5yZWY9UWcoYSxiLGMpLGQucmV0dXJuPWEsZDtkPVZnKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsYS5tb2RlLGQpO2QucmVmPVFnKGEsYixjKTtkLnJldHVybj1hO3JldHVybiBkfWZ1bmN0aW9uIGwoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPVxuV2coYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIG4oYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPVhnKGMsYS5tb2RlLGQsZiksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gQShhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9VWcoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGM9VmcoYi50eXBlLGIua2V5LGIucHJvcHMsbnVsbCxhLm1vZGUsYyksYy5yZWY9UWcoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIHRhOnJldHVybiBiPVdnKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihQZyhiKXx8TGEoYikpcmV0dXJuIGI9WGcoYixcbmEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtSZyhhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHAoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2Ugc2E6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT11YT9uKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgdGE6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoUGcoYyl8fExhKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm4oYSxiLGMsZCxudWxsKTtSZyhhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEMoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8XG5udWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBzYTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09dWE/bihiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgdGE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoUGcoZCl8fExhKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG4oYixhLGQsZSxudWxsKTtSZyhiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIHgoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsdD1udWxsLHU9Zyx6PWc9MCxxPW51bGw7bnVsbCE9PXUmJno8aC5sZW5ndGg7eisrKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciBuPXAoZSx1LGhbel0sayk7aWYobnVsbD09PW4pe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09XG5uLmFsdGVybmF0ZSYmYihlLHUpO2c9ZihuLGcseik7bnVsbD09PXQ/bD1uOnQuc2libGluZz1uO3Q9bjt1PXF9aWYoej09PWgubGVuZ3RoKXJldHVybiBjKGUsdSksbDtpZihudWxsPT09dSl7Zm9yKDt6PGgubGVuZ3RoO3orKyl1PUEoZSxoW3pdLGspLG51bGwhPT11JiYoZz1mKHUsZyx6KSxudWxsPT09dD9sPXU6dC5zaWJsaW5nPXUsdD11KTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7ejxoLmxlbmd0aDt6KyspcT1DKHUsZSx6LGhbel0sayksbnVsbCE9PXEmJihhJiZudWxsIT09cS5hbHRlcm5hdGUmJnUuZGVsZXRlKG51bGw9PT1xLmtleT96OnEua2V5KSxnPWYocSxnLHopLG51bGw9PT10P2w9cTp0LnNpYmxpbmc9cSx0PXEpO2EmJnUuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gdyhlLGcsaCxrKXt2YXIgbD1MYShoKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgbCl0aHJvdyBFcnJvcih5KDE1MCkpO2g9bC5jYWxsKGgpO2lmKG51bGw9PVxuaCl0aHJvdyBFcnJvcih5KDE1MSkpO2Zvcih2YXIgdD1sPW51bGwsdT1nLHo9Zz0wLHE9bnVsbCxuPWgubmV4dCgpO251bGwhPT11JiYhbi5kb25lO3orKyxuPWgubmV4dCgpKXt1LmluZGV4Pno/KHE9dSx1PW51bGwpOnE9dS5zaWJsaW5nO3ZhciB3PXAoZSx1LG4udmFsdWUsayk7aWYobnVsbD09PXcpe251bGw9PT11JiYodT1xKTticmVha31hJiZ1JiZudWxsPT09dy5hbHRlcm5hdGUmJmIoZSx1KTtnPWYodyxnLHopO251bGw9PT10P2w9dzp0LnNpYmxpbmc9dzt0PXc7dT1xfWlmKG4uZG9uZSlyZXR1cm4gYyhlLHUpLGw7aWYobnVsbD09PXUpe2Zvcig7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUEoZSxuLnZhbHVlLGspLG51bGwhPT1uJiYoZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7IW4uZG9uZTt6Kyssbj1oLm5leHQoKSluPUModSxlLHosbi52YWx1ZSxrKSxudWxsIT09biYmKGEmJm51bGwhPT1uLmFsdGVybmF0ZSYmXG51LmRlbGV0ZShudWxsPT09bi5rZXk/ejpuLmtleSksZz1mKG4sZyx6KSxudWxsPT09dD9sPW46dC5zaWJsaW5nPW4sdD1uKTthJiZ1LmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBsfXJldHVybiBmdW5jdGlvbihhLGQsZixoKXt2YXIgaz1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT11YSYmbnVsbD09PWYua2V5O2smJihmPWYucHJvcHMuY2hpbGRyZW4pO3ZhciBsPVwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWY7aWYobClzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSBzYTphOntsPWYua2V5O2ZvcihrPWQ7bnVsbCE9PWs7KXtpZihrLmtleT09PWwpe3N3aXRjaChrLnRhZyl7Y2FzZSA3OmlmKGYudHlwZT09PXVhKXtjKGEsay5zaWJsaW5nKTtkPWUoayxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWJyZWFrO2RlZmF1bHQ6aWYoay5lbGVtZW50VHlwZT09PWYudHlwZSl7YyhhLGsuc2libGluZyk7XG5kPWUoayxmLnByb3BzKTtkLnJlZj1RZyhhLGssZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX19YyhhLGspO2JyZWFrfWVsc2UgYihhLGspO2s9ay5zaWJsaW5nfWYudHlwZT09PXVhPyhkPVhnKGYucHJvcHMuY2hpbGRyZW4sYS5tb2RlLGgsZi5rZXkpLGQucmV0dXJuPWEsYT1kKTooaD1WZyhmLnR5cGUsZi5rZXksZi5wcm9wcyxudWxsLGEubW9kZSxoKSxoLnJlZj1RZyhhLGQsZiksaC5yZXR1cm49YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgdGE6YTp7Zm9yKGs9Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PWspaWYoND09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdKTtkLnJldHVybj1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9XG5XZyhmLGEubW9kZSxoKTtkLnJldHVybj1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZiksZC5yZXR1cm49YSxhPWQpOihjKGEsZCksZD1VZyhmLGEubW9kZSxoKSxkLnJldHVybj1hLGE9ZCksZyhhKTtpZihQZyhmKSlyZXR1cm4geChhLGQsZixoKTtpZihMYShmKSlyZXR1cm4gdyhhLGQsZixoKTtsJiZSZyhhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZiYmIWspc3dpdGNoKGEudGFnKXtjYXNlIDE6Y2FzZSAyMjpjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnRocm93IEVycm9yKHkoMTUyLFJhKGEudHlwZSl8fFwiQ29tcG9uZW50XCIpKTt9cmV0dXJuIGMoYSxkKX19dmFyIFlnPVNnKCEwKSxaZz1TZyghMSksJGc9e30sYWg9QmYoJGcpLGJoPUJmKCRnKSxjaD1CZigkZyk7XG5mdW5jdGlvbiBkaChhKXtpZihhPT09JGcpdGhyb3cgRXJyb3IoeSgxNzQpKTtyZXR1cm4gYX1mdW5jdGlvbiBlaChhLGIpe0koY2gsYik7SShiaCxhKTtJKGFoLCRnKTthPWIubm9kZVR5cGU7c3dpdGNoKGEpe2Nhc2UgOTpjYXNlIDExOmI9KGI9Yi5kb2N1bWVudEVsZW1lbnQpP2IubmFtZXNwYWNlVVJJOm1iKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDphPTg9PT1hP2IucGFyZW50Tm9kZTpiLGI9YS5uYW1lc3BhY2VVUkl8fG51bGwsYT1hLnRhZ05hbWUsYj1tYihiLGEpfUgoYWgpO0koYWgsYil9ZnVuY3Rpb24gZmgoKXtIKGFoKTtIKGJoKTtIKGNoKX1mdW5jdGlvbiBnaChhKXtkaChjaC5jdXJyZW50KTt2YXIgYj1kaChhaC5jdXJyZW50KTt2YXIgYz1tYihiLGEudHlwZSk7YiE9PWMmJihJKGJoLGEpLEkoYWgsYykpfWZ1bmN0aW9uIGhoKGEpe2JoLmN1cnJlbnQ9PT1hJiYoSChhaCksSChiaCkpfXZhciBQPUJmKDApO1xuZnVuY3Rpb24gaWgoYSl7Zm9yKHZhciBiPWE7bnVsbCE9PWI7KXtpZigxMz09PWIudGFnKXt2YXIgYz1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWMmJihjPWMuZGVoeWRyYXRlZCxudWxsPT09Y3x8XCIkP1wiPT09Yy5kYXRhfHxcIiQhXCI9PT1jLmRhdGEpKXJldHVybiBifWVsc2UgaWYoMTk9PT1iLnRhZyYmdm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyKXtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBifWVsc2UgaWYobnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ31yZXR1cm4gbnVsbH12YXIgamg9bnVsbCxraD1udWxsLGxoPSExO1xuZnVuY3Rpb24gbWgoYSxiKXt2YXIgYz1uaCg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7Yy5mbGFncz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gb2goYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7Y2FzZSAxMzpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIHBoKGEpe2lmKGxoKXt2YXIgYj1raDtpZihiKXt2YXIgYz1iO2lmKCFvaChhLGIpKXtiPXJmKGMubmV4dFNpYmxpbmcpO2lmKCFifHwhb2goYSxiKSl7YS5mbGFncz1hLmZsYWdzJi0xMDI1fDI7bGg9ITE7amg9YTtyZXR1cm59bWgoamgsYyl9amg9YTtraD1yZihiLmZpcnN0Q2hpbGQpfWVsc2UgYS5mbGFncz1hLmZsYWdzJi0xMDI1fDIsbGg9ITEsamg9YX19ZnVuY3Rpb24gcWgoYSl7Zm9yKGE9YS5yZXR1cm47bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnJiYxMyE9PWEudGFnOylhPWEucmV0dXJuO2poPWF9XG5mdW5jdGlvbiByaChhKXtpZihhIT09amgpcmV0dXJuITE7aWYoIWxoKXJldHVybiBxaChhKSxsaD0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIW5mKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1raDtiOyltaChhLGIpLGI9cmYoYi5uZXh0U2libGluZyk7cWgoYSk7aWYoMTM9PT1hLnRhZyl7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcih5KDMxNykpO2E6e2E9YS5uZXh0U2libGluZztmb3IoYj0wO2E7KXtpZig4PT09YS5ub2RlVHlwZSl7dmFyIGM9YS5kYXRhO2lmKFwiLyRcIj09PWMpe2lmKDA9PT1iKXtraD1yZihhLm5leHRTaWJsaW5nKTticmVhayBhfWItLX1lbHNlXCIkXCIhPT1jJiZcIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfWtoPW51bGx9fWVsc2Uga2g9amg/cmYoYS5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpOm51bGw7cmV0dXJuITB9XG5mdW5jdGlvbiBzaCgpe2toPWpoPW51bGw7bGg9ITF9dmFyIHRoPVtdO2Z1bmN0aW9uIHVoKCl7Zm9yKHZhciBhPTA7YTx0aC5sZW5ndGg7YSsrKXRoW2FdLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PW51bGw7dGgubGVuZ3RoPTB9dmFyIHZoPXJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsd2g9cmEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcseGg9MCxSPW51bGwsUz1udWxsLFQ9bnVsbCx5aD0hMSx6aD0hMTtmdW5jdGlvbiBBaCgpe3Rocm93IEVycm9yKHkoMzIxKSk7fWZ1bmN0aW9uIEJoKGEsYil7aWYobnVsbD09PWIpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aCYmYzxhLmxlbmd0aDtjKyspaWYoIUhlKGFbY10sYltjXSkpcmV0dXJuITE7cmV0dXJuITB9XG5mdW5jdGlvbiBDaChhLGIsYyxkLGUsZil7eGg9ZjtSPWI7Yi5tZW1vaXplZFN0YXRlPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO2IubGFuZXM9MDt2aC5jdXJyZW50PW51bGw9PT1hfHxudWxsPT09YS5tZW1vaXplZFN0YXRlP0RoOkVoO2E9YyhkLGUpO2lmKHpoKXtmPTA7ZG97emg9ITE7aWYoISgyNT5mKSl0aHJvdyBFcnJvcih5KDMwMSkpO2YrPTE7VD1TPW51bGw7Yi51cGRhdGVRdWV1ZT1udWxsO3ZoLmN1cnJlbnQ9Rmg7YT1jKGQsZSl9d2hpbGUoemgpfXZoLmN1cnJlbnQ9R2g7Yj1udWxsIT09UyYmbnVsbCE9PVMubmV4dDt4aD0wO1Q9Uz1SPW51bGw7eWg9ITE7aWYoYil0aHJvdyBFcnJvcih5KDMwMCkpO3JldHVybiBhfWZ1bmN0aW9uIEhoKCl7dmFyIGE9e21lbW9pemVkU3RhdGU6bnVsbCxiYXNlU3RhdGU6bnVsbCxiYXNlUXVldWU6bnVsbCxxdWV1ZTpudWxsLG5leHQ6bnVsbH07bnVsbD09PVQ/Ui5tZW1vaXplZFN0YXRlPVQ9YTpUPVQubmV4dD1hO3JldHVybiBUfVxuZnVuY3Rpb24gSWgoKXtpZihudWxsPT09Uyl7dmFyIGE9Ui5hbHRlcm5hdGU7YT1udWxsIT09YT9hLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGE9Uy5uZXh0O3ZhciBiPW51bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZTpULm5leHQ7aWYobnVsbCE9PWIpVD1iLFM9YTtlbHNle2lmKG51bGw9PT1hKXRocm93IEVycm9yKHkoMzEwKSk7Uz1hO2E9e21lbW9pemVkU3RhdGU6Uy5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpTLmJhc2VTdGF0ZSxiYXNlUXVldWU6Uy5iYXNlUXVldWUscXVldWU6Uy5xdWV1ZSxuZXh0Om51bGx9O251bGw9PT1UP1IubWVtb2l6ZWRTdGF0ZT1UPWE6VD1ULm5leHQ9YX1yZXR1cm4gVH1mdW5jdGlvbiBKaChhLGIpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYSk6Yn1cbmZ1bmN0aW9uIEtoKGEpe3ZhciBiPUloKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHkoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9UyxlPWQuYmFzZVF1ZXVlLGY9Yy5wZW5kaW5nO2lmKG51bGwhPT1mKXtpZihudWxsIT09ZSl7dmFyIGc9ZS5uZXh0O2UubmV4dD1mLm5leHQ7Zi5uZXh0PWd9ZC5iYXNlUXVldWU9ZT1mO2MucGVuZGluZz1udWxsfWlmKG51bGwhPT1lKXtlPWUubmV4dDtkPWQuYmFzZVN0YXRlO3ZhciBoPWc9Zj1udWxsLGs9ZTtkb3t2YXIgbD1rLmxhbmU7aWYoKHhoJmwpPT09bCludWxsIT09aCYmKGg9aC5uZXh0PXtsYW5lOjAsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixlYWdlclN0YXRlOmsuZWFnZXJTdGF0ZSxuZXh0Om51bGx9KSxkPWsuZWFnZXJSZWR1Y2VyPT09YT9rLmVhZ2VyU3RhdGU6YShkLGsuYWN0aW9uKTtlbHNle3ZhciBuPXtsYW5lOmwsYWN0aW9uOmsuYWN0aW9uLGVhZ2VyUmVkdWNlcjprLmVhZ2VyUmVkdWNlcixcbmVhZ2VyU3RhdGU6ay5lYWdlclN0YXRlLG5leHQ6bnVsbH07bnVsbD09PWg/KGc9aD1uLGY9ZCk6aD1oLm5leHQ9bjtSLmxhbmVzfD1sO0RnfD1sfWs9ay5uZXh0fXdoaWxlKG51bGwhPT1rJiZrIT09ZSk7bnVsbD09PWg/Zj1kOmgubmV4dD1nO0hlKGQsYi5tZW1vaXplZFN0YXRlKXx8KHVnPSEwKTtiLm1lbW9pemVkU3RhdGU9ZDtiLmJhc2VTdGF0ZT1mO2IuYmFzZVF1ZXVlPWg7Yy5sYXN0UmVuZGVyZWRTdGF0ZT1kfXJldHVybltiLm1lbW9pemVkU3RhdGUsYy5kaXNwYXRjaF19XG5mdW5jdGlvbiBMaChhKXt2YXIgYj1JaCgpLGM9Yi5xdWV1ZTtpZihudWxsPT09Yyl0aHJvdyBFcnJvcih5KDMxMSkpO2MubGFzdFJlbmRlcmVkUmVkdWNlcj1hO3ZhciBkPWMuZGlzcGF0Y2gsZT1jLnBlbmRpbmcsZj1iLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWUpe2MucGVuZGluZz1udWxsO3ZhciBnPWU9ZS5uZXh0O2RvIGY9YShmLGcuYWN0aW9uKSxnPWcubmV4dDt3aGlsZShnIT09ZSk7SGUoZixiLm1lbW9pemVkU3RhdGUpfHwodWc9ITApO2IubWVtb2l6ZWRTdGF0ZT1mO251bGw9PT1iLmJhc2VRdWV1ZSYmKGIuYmFzZVN0YXRlPWYpO2MubGFzdFJlbmRlcmVkU3RhdGU9Zn1yZXR1cm5bZixkXX1cbmZ1bmN0aW9uIE1oKGEsYixjKXt2YXIgZD1iLl9nZXRWZXJzaW9uO2Q9ZChiLl9zb3VyY2UpO3ZhciBlPWIuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7aWYobnVsbCE9PWUpYT1lPT09ZDtlbHNlIGlmKGE9YS5tdXRhYmxlUmVhZExhbmVzLGE9KHhoJmEpPT09YSliLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5PWQsdGgucHVzaChiKTtpZihhKXJldHVybiBjKGIuX3NvdXJjZSk7dGgucHVzaChiKTt0aHJvdyBFcnJvcih5KDM1MCkpO31cbmZ1bmN0aW9uIE5oKGEsYixjLGQpe3ZhciBlPVU7aWYobnVsbD09PWUpdGhyb3cgRXJyb3IoeSgzNDkpKTt2YXIgZj1iLl9nZXRWZXJzaW9uLGc9ZihiLl9zb3VyY2UpLGg9dmguY3VycmVudCxrPWgudXNlU3RhdGUoZnVuY3Rpb24oKXtyZXR1cm4gTWgoZSxiLGMpfSksbD1rWzFdLG49a1swXTtrPVQ7dmFyIEE9YS5tZW1vaXplZFN0YXRlLHA9QS5yZWZzLEM9cC5nZXRTbmFwc2hvdCx4PUEuc291cmNlO0E9QS5zdWJzY3JpYmU7dmFyIHc9UjthLm1lbW9pemVkU3RhdGU9e3JlZnM6cCxzb3VyY2U6YixzdWJzY3JpYmU6ZH07aC51c2VFZmZlY3QoZnVuY3Rpb24oKXtwLmdldFNuYXBzaG90PWM7cC5zZXRTbmFwc2hvdD1sO3ZhciBhPWYoYi5fc291cmNlKTtpZighSGUoZyxhKSl7YT1jKGIuX3NvdXJjZSk7SGUobixhKXx8KGwoYSksYT1JZyh3KSxlLm11dGFibGVSZWFkTGFuZXN8PWEmZS5wZW5kaW5nTGFuZXMpO2E9ZS5tdXRhYmxlUmVhZExhbmVzO2UuZW50YW5nbGVkTGFuZXN8PWE7Zm9yKHZhciBkPVxuZS5lbnRhbmdsZW1lbnRzLGg9YTswPGg7KXt2YXIgaz0zMS1WYyhoKSx2PTE8PGs7ZFtrXXw9YTtoJj1+dn19fSxbYyxiLGRdKTtoLnVzZUVmZmVjdChmdW5jdGlvbigpe3JldHVybiBkKGIuX3NvdXJjZSxmdW5jdGlvbigpe3ZhciBhPXAuZ2V0U25hcHNob3QsYz1wLnNldFNuYXBzaG90O3RyeXtjKGEoYi5fc291cmNlKSk7dmFyIGQ9SWcodyk7ZS5tdXRhYmxlUmVhZExhbmVzfD1kJmUucGVuZGluZ0xhbmVzfWNhdGNoKHEpe2MoZnVuY3Rpb24oKXt0aHJvdyBxO30pfX0pfSxbYixkXSk7SGUoQyxjKSYmSGUoeCxiKSYmSGUoQSxkKXx8KGE9e3BlbmRpbmc6bnVsbCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6SmgsbGFzdFJlbmRlcmVkU3RhdGU6bn0sYS5kaXNwYXRjaD1sPU9oLmJpbmQobnVsbCxSLGEpLGsucXVldWU9YSxrLmJhc2VRdWV1ZT1udWxsLG49TWgoZSxiLGMpLGsubWVtb2l6ZWRTdGF0ZT1rLmJhc2VTdGF0ZT1uKTtyZXR1cm4gbn1cbmZ1bmN0aW9uIFBoKGEsYixjKXt2YXIgZD1JaCgpO3JldHVybiBOaChkLGEsYixjKX1mdW5jdGlvbiBRaChhKXt2YXIgYj1IaCgpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiYoYT1hKCkpO2IubWVtb2l6ZWRTdGF0ZT1iLmJhc2VTdGF0ZT1hO2E9Yi5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpKaCxsYXN0UmVuZGVyZWRTdGF0ZTphfTthPWEuZGlzcGF0Y2g9T2guYmluZChudWxsLFIsYSk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxhXX1cbmZ1bmN0aW9uIFJoKGEsYixjLGQpe2E9e3RhZzphLGNyZWF0ZTpiLGRlc3Ryb3k6YyxkZXBzOmQsbmV4dDpudWxsfTtiPVIudXBkYXRlUXVldWU7bnVsbD09PWI/KGI9e2xhc3RFZmZlY3Q6bnVsbH0sUi51cGRhdGVRdWV1ZT1iLGIubGFzdEVmZmVjdD1hLm5leHQ9YSk6KGM9Yi5sYXN0RWZmZWN0LG51bGw9PT1jP2IubGFzdEVmZmVjdD1hLm5leHQ9YTooZD1jLm5leHQsYy5uZXh0PWEsYS5uZXh0PWQsYi5sYXN0RWZmZWN0PWEpKTtyZXR1cm4gYX1mdW5jdGlvbiBTaChhKXt2YXIgYj1IaCgpO2E9e2N1cnJlbnQ6YX07cmV0dXJuIGIubWVtb2l6ZWRTdGF0ZT1hfWZ1bmN0aW9uIFRoKCl7cmV0dXJuIEloKCkubWVtb2l6ZWRTdGF0ZX1mdW5jdGlvbiBVaChhLGIsYyxkKXt2YXIgZT1IaCgpO1IuZmxhZ3N8PWE7ZS5tZW1vaXplZFN0YXRlPVJoKDF8YixjLHZvaWQgMCx2b2lkIDA9PT1kP251bGw6ZCl9XG5mdW5jdGlvbiBWaChhLGIsYyxkKXt2YXIgZT1JaCgpO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGY9dm9pZCAwO2lmKG51bGwhPT1TKXt2YXIgZz1TLm1lbW9pemVkU3RhdGU7Zj1nLmRlc3Ryb3k7aWYobnVsbCE9PWQmJkJoKGQsZy5kZXBzKSl7UmgoYixjLGYsZCk7cmV0dXJufX1SLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1SaCgxfGIsYyxmLGQpfWZ1bmN0aW9uIFdoKGEsYil7cmV0dXJuIFVoKDUxNiw0LGEsYil9ZnVuY3Rpb24gWGgoYSxiKXtyZXR1cm4gVmgoNTE2LDQsYSxiKX1mdW5jdGlvbiBZaChhLGIpe3JldHVybiBWaCg0LDIsYSxiKX1mdW5jdGlvbiBaaChhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXJldHVybiBhPWEoKSxiKGEpLGZ1bmN0aW9uKCl7YihudWxsKX07aWYobnVsbCE9PWImJnZvaWQgMCE9PWIpcmV0dXJuIGE9YSgpLGIuY3VycmVudD1hLGZ1bmN0aW9uKCl7Yi5jdXJyZW50PW51bGx9fVxuZnVuY3Rpb24gJGgoYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBWaCg0LDIsWmguYmluZChudWxsLGIsYSksYyl9ZnVuY3Rpb24gYWkoKXt9ZnVuY3Rpb24gYmkoYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9ZnVuY3Rpb24gY2koYSxiKXt2YXIgYz1JaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7dmFyIGQ9Yy5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kJiZudWxsIT09YiYmQmgoYixkWzFdKSlyZXR1cm4gZFswXTthPWEoKTtjLm1lbW9pemVkU3RhdGU9W2EsYl07cmV0dXJuIGF9XG5mdW5jdGlvbiBkaShhLGIpe3ZhciBjPWVnKCk7Z2coOTg+Yz85ODpjLGZ1bmN0aW9uKCl7YSghMCl9KTtnZyg5NzxjPzk3OmMsZnVuY3Rpb24oKXt2YXIgYz13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7YSghMSksYigpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1jfX0pfVxuZnVuY3Rpb24gT2goYSxiLGMpe3ZhciBkPUhnKCksZT1JZyhhKSxmPXtsYW5lOmUsYWN0aW9uOmMsZWFnZXJSZWR1Y2VyOm51bGwsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH0sZz1iLnBlbmRpbmc7bnVsbD09PWc/Zi5uZXh0PWY6KGYubmV4dD1nLm5leHQsZy5uZXh0PWYpO2IucGVuZGluZz1mO2c9YS5hbHRlcm5hdGU7aWYoYT09PVJ8fG51bGwhPT1nJiZnPT09Uil6aD15aD0hMDtlbHNle2lmKDA9PT1hLmxhbmVzJiYobnVsbD09PWd8fDA9PT1nLmxhbmVzKSYmKGc9Yi5sYXN0UmVuZGVyZWRSZWR1Y2VyLG51bGwhPT1nKSl0cnl7dmFyIGg9Yi5sYXN0UmVuZGVyZWRTdGF0ZSxrPWcoaCxjKTtmLmVhZ2VyUmVkdWNlcj1nO2YuZWFnZXJTdGF0ZT1rO2lmKEhlKGssaCkpcmV0dXJufWNhdGNoKGwpe31maW5hbGx5e31KZyhhLGUsZCl9fVxudmFyIEdoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpBaCx1c2VDb250ZXh0OkFoLHVzZUVmZmVjdDpBaCx1c2VJbXBlcmF0aXZlSGFuZGxlOkFoLHVzZUxheW91dEVmZmVjdDpBaCx1c2VNZW1vOkFoLHVzZVJlZHVjZXI6QWgsdXNlUmVmOkFoLHVzZVN0YXRlOkFoLHVzZURlYnVnVmFsdWU6QWgsdXNlRGVmZXJyZWRWYWx1ZTpBaCx1c2VUcmFuc2l0aW9uOkFoLHVzZU11dGFibGVTb3VyY2U6QWgsdXNlT3BhcXVlSWRlbnRpZmllcjpBaCx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LERoPXtyZWFkQ29udGV4dDp2Zyx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpe0hoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OldoLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBVaCg0LDIsWmguYmluZChudWxsLFxuYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFVoKDQsMixhLGIpfSx1c2VNZW1vOmZ1bmN0aW9uKGEsYil7dmFyIGM9SGgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO2E9YSgpO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX0sdXNlUmVkdWNlcjpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9SGgoKTtiPXZvaWQgMCE9PWM/YyhiKTpiO2QubWVtb2l6ZWRTdGF0ZT1kLmJhc2VTdGF0ZT1iO2E9ZC5xdWV1ZT17cGVuZGluZzpudWxsLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjphLGxhc3RSZW5kZXJlZFN0YXRlOmJ9O2E9YS5kaXNwYXRjaD1PaC5iaW5kKG51bGwsUixhKTtyZXR1cm5bZC5tZW1vaXplZFN0YXRlLGFdfSx1c2VSZWY6U2gsdXNlU3RhdGU6UWgsdXNlRGVidWdWYWx1ZTphaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVFoKGEpLGM9YlswXSxkPWJbMV07V2goZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO1xud2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPVFoKCExKSxiPWFbMF07YT1kaS5iaW5kKG51bGwsYVsxXSk7U2goYSk7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPUhoKCk7ZC5tZW1vaXplZFN0YXRlPXtyZWZzOntnZXRTbmFwc2hvdDpiLHNldFNuYXBzaG90Om51bGx9LHNvdXJjZTphLHN1YnNjcmliZTpjfTtyZXR1cm4gTmgoZCxhLGIsYyl9LHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtpZihsaCl7dmFyIGE9ITEsYj11ZihmdW5jdGlvbigpe2F8fChhPSEwLGMoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpKTt0aHJvdyBFcnJvcih5KDM1NSkpO30pLGM9UWgoYilbMV07MD09PShSLm1vZGUmMikmJihSLmZsYWdzfD01MTYsUmgoNSxmdW5jdGlvbigpe2MoXCJyOlwiKyh0ZisrKS50b1N0cmluZygzNikpfSxcbnZvaWQgMCxudWxsKSk7cmV0dXJuIGJ9Yj1cInI6XCIrKHRmKyspLnRvU3RyaW5nKDM2KTtRaChiKTtyZXR1cm4gYn0sdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfSxFaD17cmVhZENvbnRleHQ6dmcsdXNlQ2FsbGJhY2s6YmksdXNlQ29udGV4dDp2Zyx1c2VFZmZlY3Q6WGgsdXNlSW1wZXJhdGl2ZUhhbmRsZTokaCx1c2VMYXlvdXRFZmZlY3Q6WWgsdXNlTWVtbzpjaSx1c2VSZWR1Y2VyOktoLHVzZVJlZjpUaCx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBLaChKaCl9LHVzZURlYnVnVmFsdWU6YWksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1LaChKaCksYz1iWzBdLGQ9YlsxXTtYaChmdW5jdGlvbigpe3ZhciBiPXdoLnRyYW5zaXRpb247d2gudHJhbnNpdGlvbj0xO3RyeXtkKGEpfWZpbmFsbHl7d2gudHJhbnNpdGlvbj1ifX0sW2FdKTtyZXR1cm4gY30sdXNlVHJhbnNpdGlvbjpmdW5jdGlvbigpe3ZhciBhPUtoKEpoKVswXTtyZXR1cm5bVGgoKS5jdXJyZW50LFxuYV19LHVzZU11dGFibGVTb3VyY2U6UGgsdXNlT3BhcXVlSWRlbnRpZmllcjpmdW5jdGlvbigpe3JldHVybiBLaChKaClbMF19LHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sRmg9e3JlYWRDb250ZXh0OnZnLHVzZUNhbGxiYWNrOmJpLHVzZUNvbnRleHQ6dmcsdXNlRWZmZWN0OlhoLHVzZUltcGVyYXRpdmVIYW5kbGU6JGgsdXNlTGF5b3V0RWZmZWN0OlloLHVzZU1lbW86Y2ksdXNlUmVkdWNlcjpMaCx1c2VSZWY6VGgsdXNlU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpfSx1c2VEZWJ1Z1ZhbHVlOmFpLHVzZURlZmVycmVkVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9TGgoSmgpLGM9YlswXSxkPWJbMV07WGgoZnVuY3Rpb24oKXt2YXIgYj13aC50cmFuc2l0aW9uO3doLnRyYW5zaXRpb249MTt0cnl7ZChhKX1maW5hbGx5e3doLnRyYW5zaXRpb249Yn19LFthXSk7cmV0dXJuIGN9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1MaChKaClbMF07cmV0dXJuW1RoKCkuY3VycmVudCxcbmFdfSx1c2VNdXRhYmxlU291cmNlOlBoLHVzZU9wYXF1ZUlkZW50aWZpZXI6ZnVuY3Rpb24oKXtyZXR1cm4gTGgoSmgpWzBdfSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LGVpPXJhLlJlYWN0Q3VycmVudE93bmVyLHVnPSExO2Z1bmN0aW9uIGZpKGEsYixjLGQpe2IuY2hpbGQ9bnVsbD09PWE/WmcoYixudWxsLGMsZCk6WWcoYixhLmNoaWxkLGMsZCl9ZnVuY3Rpb24gZ2koYSxiLGMsZCxlKXtjPWMucmVuZGVyO3ZhciBmPWIucmVmO3RnKGIsZSk7ZD1DaChhLGIsYyxkLGYsZSk7aWYobnVsbCE9PWEmJiF1ZylyZXR1cm4gYi51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlLGIuZmxhZ3MmPS01MTcsYS5sYW5lcyY9fmUsaGkoYSxiLGUpO2IuZmxhZ3N8PTE7ZmkoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBpaShhLGIsYyxkLGUsZil7aWYobnVsbD09PWEpe3ZhciBnPWMudHlwZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyYmIWppKGcpJiZ2b2lkIDA9PT1nLmRlZmF1bHRQcm9wcyYmbnVsbD09PWMuY29tcGFyZSYmdm9pZCAwPT09Yy5kZWZhdWx0UHJvcHMpcmV0dXJuIGIudGFnPTE1LGIudHlwZT1nLGtpKGEsYixnLGQsZSxmKTthPVZnKGMudHlwZSxudWxsLGQsYixiLm1vZGUsZik7YS5yZWY9Yi5yZWY7YS5yZXR1cm49YjtyZXR1cm4gYi5jaGlsZD1hfWc9YS5jaGlsZDtpZigwPT09KGUmZikmJihlPWcubWVtb2l6ZWRQcm9wcyxjPWMuY29tcGFyZSxjPW51bGwhPT1jP2M6SmUsYyhlLGQpJiZhLnJlZj09PWIucmVmKSlyZXR1cm4gaGkoYSxiLGYpO2IuZmxhZ3N8PTE7YT1UZyhnLGQpO2EucmVmPWIucmVmO2EucmV0dXJuPWI7cmV0dXJuIGIuY2hpbGQ9YX1cbmZ1bmN0aW9uIGtpKGEsYixjLGQsZSxmKXtpZihudWxsIT09YSYmSmUoYS5tZW1vaXplZFByb3BzLGQpJiZhLnJlZj09PWIucmVmKWlmKHVnPSExLDAhPT0oZiZlKSkwIT09KGEuZmxhZ3MmMTYzODQpJiYodWc9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxoaShhLGIsZik7cmV0dXJuIGxpKGEsYixjLGQsZil9XG5mdW5jdGlvbiBtaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZXx8XCJ1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZ1wiPT09ZC5tb2RlKWlmKDA9PT0oYi5tb2RlJjQpKWIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOjB9LG5pKGIsYyk7ZWxzZSBpZigwIT09KGMmMTA3Mzc0MTgyNCkpYi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MH0sbmkoYixudWxsIT09Zj9mLmJhc2VMYW5lczpjKTtlbHNlIHJldHVybiBhPW51bGwhPT1mP2YuYmFzZUxhbmVzfGM6YyxiLmxhbmVzPWIuY2hpbGRMYW5lcz0xMDczNzQxODI0LGIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOmF9LG5pKGIsYSksbnVsbDtlbHNlIG51bGwhPT1mPyhkPWYuYmFzZUxhbmVzfGMsYi5tZW1vaXplZFN0YXRlPW51bGwpOmQ9YyxuaShiLGQpO2ZpKGEsYixlLGMpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gb2koYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsPT09YSYmbnVsbCE9PWN8fG51bGwhPT1hJiZhLnJlZiE9PWMpYi5mbGFnc3w9MTI4fWZ1bmN0aW9uIGxpKGEsYixjLGQsZSl7dmFyIGY9RmYoYyk/RGY6TS5jdXJyZW50O2Y9RWYoYixmKTt0ZyhiLGUpO2M9Q2goYSxiLGMsZCxmLGUpO2lmKG51bGwhPT1hJiYhdWcpcmV0dXJuIGIudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZSxiLmZsYWdzJj0tNTE3LGEubGFuZXMmPX5lLGhpKGEsYixlKTtiLmZsYWdzfD0xO2ZpKGEsYixjLGUpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gcGkoYSxiLGMsZCxlKXtpZihGZihjKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO3RnKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKW51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpLE1nKGIsYyxkKSxPZyhiLGMsZCxlKSxkPSEwO2Vsc2UgaWYobnVsbD09PWEpe3ZhciBnPWIuc3RhdGVOb2RlLGg9Yi5tZW1vaXplZFByb3BzO2cucHJvcHM9aDt2YXIgaz1nLmNvbnRleHQsbD1jLmNvbnRleHRUeXBlO1wib2JqZWN0XCI9PT10eXBlb2YgbCYmbnVsbCE9PWw/bD12ZyhsKToobD1GZihjKT9EZjpNLmN1cnJlbnQsbD1FZihiLGwpKTt2YXIgbj1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyxBPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtBfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmXG5cImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fGshPT1sKSYmTmcoYixnLGQsbCk7d2c9ITE7dmFyIHA9Yi5tZW1vaXplZFN0YXRlO2cuc3RhdGU9cDtDZyhiLGQsZyxlKTtrPWIubWVtb2l6ZWRTdGF0ZTtoIT09ZHx8cCE9PWt8fE4uY3VycmVudHx8d2c/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuJiYoR2coYixjLG4sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPXdnfHxMZyhiLGMsaCxkLHAsayxsKSk/KEF8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09XG50eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpKTooXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTt5ZyhhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOmxnKGIudHlwZSxoKTtnLnByb3BzPWw7QT1iLnBlbmRpbmdQcm9wcztwPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPXZnKGspOihrPUZmKGMpP0RmOk0uY3VycmVudCxrPUVmKGIsaykpO3ZhciBDPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBDfHxcblwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09QXx8cCE9PWspJiZOZyhiLGcsZCxrKTt3Zz0hMTtwPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXA7Q2coYixkLGcsZSk7dmFyIHg9Yi5tZW1vaXplZFN0YXRlO2ghPT1BfHxwIT09eHx8Ti5jdXJyZW50fHx3Zz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIEMmJihHZyhiLGMsQyxkKSx4PWIubWVtb2l6ZWRTdGF0ZSksKGw9d2d8fExnKGIsYyxsLGQscCx4LGspKT8obnx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGV8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoZCxcbngsayksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoZCx4LGspKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKGIuZmxhZ3N8PTI1NikpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksYi5tZW1vaXplZFByb3BzPWQsYi5tZW1vaXplZFN0YXRlPXgpLGcucHJvcHM9ZCxnLnN0YXRlPXgsZy5jb250ZXh0PWssZD1sKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbmg9PT1hLm1lbW9pemVkUHJvcHMmJnA9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcD09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTI1NiksZD0hMSl9cmV0dXJuIHFpKGEsYixjLGQsZixlKX1cbmZ1bmN0aW9uIHFpKGEsYixjLGQsZSxmKXtvaShhLGIpO3ZhciBnPTAhPT0oYi5mbGFncyY2NCk7aWYoIWQmJiFnKXJldHVybiBlJiZLZihiLGMsITEpLGhpKGEsYixmKTtkPWIuc3RhdGVOb2RlO2VpLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9WWcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1ZZyhiLG51bGwsaCxmKSk6ZmkoYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmS2YoYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiByaShhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P0hmKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJkhmKGEsYi5jb250ZXh0LCExKTtlaChhLGIuY29udGFpbmVySW5mbyl9XG52YXIgc2k9e2RlaHlkcmF0ZWQ6bnVsbCxyZXRyeUxhbmU6MH07XG5mdW5jdGlvbiB0aShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1QLmN1cnJlbnQsZj0hMSxnOyhnPTAhPT0oYi5mbGFncyY2NCkpfHwoZz1udWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZT8hMTowIT09KGUmMikpO2c/KGY9ITAsYi5mbGFncyY9LTY1KTpudWxsIT09YSYmbnVsbD09PWEubWVtb2l6ZWRTdGF0ZXx8dm9pZCAwPT09ZC5mYWxsYmFja3x8ITA9PT1kLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrfHwoZXw9MSk7SShQLGUmMSk7aWYobnVsbD09PWEpe3ZvaWQgMCE9PWQuZmFsbGJhY2smJnBoKGIpO2E9ZC5jaGlsZHJlbjtlPWQuZmFsbGJhY2s7aWYoZilyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxiLm1lbW9pemVkU3RhdGU9c2ksYTtpZihcIm51bWJlclwiPT09dHlwZW9mIGQudW5zdGFibGVfZXhwZWN0ZWRMb2FkVGltZSlyZXR1cm4gYT11aShiLGEsZSxjKSxiLmNoaWxkLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczpjfSxcbmIubWVtb2l6ZWRTdGF0ZT1zaSxiLmxhbmVzPTMzNTU0NDMyLGE7Yz12aSh7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjphfSxiLm1vZGUsYyxudWxsKTtjLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWN9aWYobnVsbCE9PWEubWVtb2l6ZWRTdGF0ZSl7aWYoZilyZXR1cm4gZD13aShhLGIsZC5jaGlsZHJlbixkLmZhbGxiYWNrLGMpLGY9Yi5jaGlsZCxlPWEuY2hpbGQubWVtb2l6ZWRTdGF0ZSxmLm1lbW9pemVkU3RhdGU9bnVsbD09PWU/e2Jhc2VMYW5lczpjfTp7YmFzZUxhbmVzOmUuYmFzZUxhbmVzfGN9LGYuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXMmfmMsYi5tZW1vaXplZFN0YXRlPXNpLGQ7Yz14aShhLGIsZC5jaGlsZHJlbixjKTtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gY31pZihmKXJldHVybiBkPXdpKGEsYixkLmNoaWxkcmVuLGQuZmFsbGJhY2ssYyksZj1iLmNoaWxkLGU9YS5jaGlsZC5tZW1vaXplZFN0YXRlLGYubWVtb2l6ZWRTdGF0ZT1udWxsPT09ZT97YmFzZUxhbmVzOmN9Olxue2Jhc2VMYW5lczplLmJhc2VMYW5lc3xjfSxmLmNoaWxkTGFuZXM9YS5jaGlsZExhbmVzJn5jLGIubWVtb2l6ZWRTdGF0ZT1zaSxkO2M9eGkoYSxiLGQuY2hpbGRyZW4sYyk7Yi5tZW1vaXplZFN0YXRlPW51bGw7cmV0dXJuIGN9ZnVuY3Rpb24gdWkoYSxiLGMsZCl7dmFyIGU9YS5tb2RlLGY9YS5jaGlsZDtiPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46Yn07MD09PShlJjIpJiZudWxsIT09Zj8oZi5jaGlsZExhbmVzPTAsZi5wZW5kaW5nUHJvcHM9Yik6Zj12aShiLGUsMCxudWxsKTtjPVhnKGMsZSxkLG51bGwpO2YucmV0dXJuPWE7Yy5yZXR1cm49YTtmLnNpYmxpbmc9YzthLmNoaWxkPWY7cmV0dXJuIGN9XG5mdW5jdGlvbiB4aShhLGIsYyxkKXt2YXIgZT1hLmNoaWxkO2E9ZS5zaWJsaW5nO2M9VGcoZSx7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpjfSk7MD09PShiLm1vZGUmMikmJihjLmxhbmVzPWQpO2MucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGw7bnVsbCE9PWEmJihhLm5leHRFZmZlY3Q9bnVsbCxhLmZsYWdzPTgsYi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YSk7cmV0dXJuIGIuY2hpbGQ9Y31cbmZ1bmN0aW9uIHdpKGEsYixjLGQsZSl7dmFyIGY9Yi5tb2RlLGc9YS5jaGlsZDthPWcuc2libGluZzt2YXIgaD17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmN9OzA9PT0oZiYyKSYmYi5jaGlsZCE9PWc/KGM9Yi5jaGlsZCxjLmNoaWxkTGFuZXM9MCxjLnBlbmRpbmdQcm9wcz1oLGc9Yy5sYXN0RWZmZWN0LG51bGwhPT1nPyhiLmZpcnN0RWZmZWN0PWMuZmlyc3RFZmZlY3QsYi5sYXN0RWZmZWN0PWcsZy5uZXh0RWZmZWN0PW51bGwpOmIuZmlyc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0PW51bGwpOmM9VGcoZyxoKTtudWxsIT09YT9kPVRnKGEsZCk6KGQ9WGcoZCxmLGUsbnVsbCksZC5mbGFnc3w9Mik7ZC5yZXR1cm49YjtjLnJldHVybj1iO2Muc2libGluZz1kO2IuY2hpbGQ9YztyZXR1cm4gZH1mdW5jdGlvbiB5aShhLGIpe2EubGFuZXN8PWI7dmFyIGM9YS5hbHRlcm5hdGU7bnVsbCE9PWMmJihjLmxhbmVzfD1iKTtzZyhhLnJldHVybixiKX1cbmZ1bmN0aW9uIHppKGEsYixjLGQsZSxmKXt2YXIgZz1hLm1lbW9pemVkU3RhdGU7bnVsbD09PWc/YS5tZW1vaXplZFN0YXRlPXtpc0JhY2t3YXJkczpiLHJlbmRlcmluZzpudWxsLHJlbmRlcmluZ1N0YXJ0VGltZTowLGxhc3Q6ZCx0YWlsOmMsdGFpbE1vZGU6ZSxsYXN0RWZmZWN0OmZ9OihnLmlzQmFja3dhcmRzPWIsZy5yZW5kZXJpbmc9bnVsbCxnLnJlbmRlcmluZ1N0YXJ0VGltZT0wLGcubGFzdD1kLGcudGFpbD1jLGcudGFpbE1vZGU9ZSxnLmxhc3RFZmZlY3Q9Zil9XG5mdW5jdGlvbiBBaShhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLnJldmVhbE9yZGVyLGY9ZC50YWlsO2ZpKGEsYixkLmNoaWxkcmVuLGMpO2Q9UC5jdXJyZW50O2lmKDAhPT0oZCYyKSlkPWQmMXwyLGIuZmxhZ3N8PTY0O2Vsc2V7aWYobnVsbCE9PWEmJjAhPT0oYS5mbGFncyY2NCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZ5aShhLGMpO2Vsc2UgaWYoMTk9PT1hLnRhZyl5aShhLGMpO2Vsc2UgaWYobnVsbCE9PWEuY2hpbGQpe2EuY2hpbGQucmV0dXJuPWE7YT1hLmNoaWxkO2NvbnRpbnVlfWlmKGE9PT1iKWJyZWFrIGE7Zm9yKDtudWxsPT09YS5zaWJsaW5nOyl7aWYobnVsbD09PWEucmV0dXJufHxhLnJldHVybj09PWIpYnJlYWsgYTthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47YT1hLnNpYmxpbmd9ZCY9MX1JKFAsZCk7aWYoMD09PShiLm1vZGUmMikpYi5tZW1vaXplZFN0YXRlPVxubnVsbDtlbHNlIHN3aXRjaChlKXtjYXNlIFwiZm9yd2FyZHNcIjpjPWIuY2hpbGQ7Zm9yKGU9bnVsbDtudWxsIT09YzspYT1jLmFsdGVybmF0ZSxudWxsIT09YSYmbnVsbD09PWloKGEpJiYoZT1jKSxjPWMuc2libGluZztjPWU7bnVsbD09PWM/KGU9Yi5jaGlsZCxiLmNoaWxkPW51bGwpOihlPWMuc2libGluZyxjLnNpYmxpbmc9bnVsbCk7emkoYiwhMSxlLGMsZixiLmxhc3RFZmZlY3QpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09aWgoYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfXppKGIsITAsYyxudWxsLGYsYi5sYXN0RWZmZWN0KTticmVhaztjYXNlIFwidG9nZXRoZXJcIjp6aShiLCExLG51bGwsbnVsbCx2b2lkIDAsYi5sYXN0RWZmZWN0KTticmVhaztkZWZhdWx0OmIubWVtb2l6ZWRTdGF0ZT1udWxsfXJldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gaGkoYSxiLGMpe251bGwhPT1hJiYoYi5kZXBlbmRlbmNpZXM9YS5kZXBlbmRlbmNpZXMpO0RnfD1iLmxhbmVzO2lmKDAhPT0oYyZiLmNoaWxkTGFuZXMpKXtpZihudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQpdGhyb3cgRXJyb3IoeSgxNTMpKTtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9VGcoYSxhLnBlbmRpbmdQcm9wcyk7Yi5jaGlsZD1jO2ZvcihjLnJldHVybj1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPVRnKGEsYS5wZW5kaW5nUHJvcHMpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9cmV0dXJuIG51bGx9dmFyIEJpLENpLERpLEVpO1xuQmk9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yi5jaGlsZDtudWxsIT09Yzspe2lmKDU9PT1jLnRhZ3x8Nj09PWMudGFnKWEuYXBwZW5kQ2hpbGQoYy5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWMudGFnJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PWIpYnJlYWs7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHxjLnJldHVybj09PWIpcmV0dXJuO2M9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtjPWMuc2libGluZ319O0NpPWZ1bmN0aW9uKCl7fTtcbkRpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEubWVtb2l6ZWRQcm9wcztpZihlIT09ZCl7YT1iLnN0YXRlTm9kZTtkaChhaC5jdXJyZW50KTt2YXIgZj1udWxsO3N3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjplPVlhKGEsZSk7ZD1ZYShhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmU9ZWIoYSxlKTtkPWViKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6ZT1tKHt9LGUse3ZhbHVlOnZvaWQgMH0pO2Q9bSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmU9Z2IoYSxlKTtkPWdiKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfXZiKGMsZCk7dmFyIGc7Yz1udWxsO2ZvcihsIGluIGUpaWYoIWQuaGFzT3duUHJvcGVydHkobCkmJmUuaGFzT3duUHJvcGVydHkobCkmJm51bGwhPWVbbF0paWYoXCJzdHlsZVwiPT09XG5sKXt2YXIgaD1lW2xdO2ZvcihnIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShnKSYmKGN8fChjPXt9KSxjW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiZcImNoaWxkcmVuXCIhPT1sJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJlwiYXV0b0ZvY3VzXCIhPT1sJiYoY2EuaGFzT3duUHJvcGVydHkobCk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGwsbnVsbCkpO2ZvcihsIGluIGQpe3ZhciBrPWRbbF07aD1udWxsIT1lP2VbbF06dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkobCkmJmshPT1oJiYobnVsbCE9a3x8bnVsbCE9aCkpaWYoXCJzdHlsZVwiPT09bClpZihoKXtmb3IoZyBpbiBoKSFoLmhhc093blByb3BlcnR5KGcpfHxrJiZrLmhhc093blByb3BlcnR5KGcpfHwoY3x8KGM9e30pLGNbZ109XCJcIik7Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiZoW2ddIT09a1tnXSYmKGN8fFxuKGM9e30pLGNbZ109a1tnXSl9ZWxzZSBjfHwoZnx8KGY9W10pLGYucHVzaChsLGMpKSxjPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWw/KGs9az9rLl9faHRtbDp2b2lkIDAsaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1rJiZoIT09ayYmKGY9Znx8W10pLnB1c2gobCxrKSk6XCJjaGlsZHJlblwiPT09bD9cInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2gobCxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1sJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09bCYmKGNhLmhhc093blByb3BlcnR5KGwpPyhudWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1sJiZHKFwic2Nyb2xsXCIsYSksZnx8aD09PWt8fChmPVtdKSk6XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09ayYmay4kJHR5cGVvZj09PUdhP2sudG9TdHJpbmcoKTooZj1mfHxbXSkucHVzaChsLGspKX1jJiYoZj1mfHxbXSkucHVzaChcInN0eWxlXCIsXG5jKTt2YXIgbD1mO2lmKGIudXBkYXRlUXVldWU9bCliLmZsYWdzfD00fX07RWk9ZnVuY3Rpb24oYSxiLGMsZCl7YyE9PWQmJihiLmZsYWdzfD00KX07ZnVuY3Rpb24gRmkoYSxiKXtpZighbGgpc3dpdGNoKGEudGFpbE1vZGUpe2Nhc2UgXCJoaWRkZW5cIjpiPWEudGFpbDtmb3IodmFyIGM9bnVsbDtudWxsIT09YjspbnVsbCE9PWIuYWx0ZXJuYXRlJiYoYz1iKSxiPWIuc2libGluZztudWxsPT09Yz9hLnRhaWw9bnVsbDpjLnNpYmxpbmc9bnVsbDticmVhaztjYXNlIFwiY29sbGFwc2VkXCI6Yz1hLnRhaWw7Zm9yKHZhciBkPW51bGw7bnVsbCE9PWM7KW51bGwhPT1jLmFsdGVybmF0ZSYmKGQ9YyksYz1jLnNpYmxpbmc7bnVsbD09PWQ/Ynx8bnVsbD09PWEudGFpbD9hLnRhaWw9bnVsbDphLnRhaWwuc2libGluZz1udWxsOmQuc2libGluZz1udWxsfX1cbmZ1bmN0aW9uIEdpKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcztzd2l0Y2goYi50YWcpe2Nhc2UgMjpjYXNlIDE2OmNhc2UgMTU6Y2FzZSAwOmNhc2UgMTE6Y2FzZSA3OmNhc2UgODpjYXNlIDEyOmNhc2UgOTpjYXNlIDE0OnJldHVybiBudWxsO2Nhc2UgMTpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2Q9Yi5zdGF0ZU5vZGU7ZC5wZW5kaW5nQ29udGV4dCYmKGQuY29udGV4dD1kLnBlbmRpbmdDb250ZXh0LGQucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKXJoKGIpP2IuZmxhZ3N8PTQ6ZC5oeWRyYXRlfHwoYi5mbGFnc3w9MjU2KTtDaShiKTtyZXR1cm4gbnVsbDtjYXNlIDU6aGgoYik7dmFyIGU9ZGgoY2guY3VycmVudCk7Yz1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKURpKGEsYixjLGQsZSksYS5yZWYhPT1iLnJlZiYmKGIuZmxhZ3N8PTEyOCk7ZWxzZXtpZighZCl7aWYobnVsbD09PVxuYi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtyZXR1cm4gbnVsbH1hPWRoKGFoLmN1cnJlbnQpO2lmKHJoKGIpKXtkPWIuc3RhdGVOb2RlO2M9Yi50eXBlO3ZhciBmPWIubWVtb2l6ZWRQcm9wcztkW3dmXT1iO2RbeGZdPWY7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsZCk7RyhcImNsb3NlXCIsZCk7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihhPTA7YTxYZS5sZW5ndGg7YSsrKUcoWGVbYV0sZCk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkcoXCJlcnJvclwiLGQpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGQpO0coXCJsb2FkXCIsZCk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpHKFwidG9nZ2xlXCIsZCk7YnJlYWs7Y2FzZSBcImlucHV0XCI6WmEoZCxmKTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpkLl93cmFwcGVyU3RhdGU9XG57d2FzTXVsdGlwbGU6ISFmLm11bHRpcGxlfTtHKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGQsZiksRyhcImludmFsaWRcIixkKX12YihjLGYpO2E9bnVsbDtmb3IodmFyIGcgaW4gZilmLmhhc093blByb3BlcnR5KGcpJiYoZT1mW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBlP2QudGV4dENvbnRlbnQhPT1lJiYoYT1bXCJjaGlsZHJlblwiLGVdKTpcIm51bWJlclwiPT09dHlwZW9mIGUmJmQudGV4dENvbnRlbnQhPT1cIlwiK2UmJihhPVtcImNoaWxkcmVuXCIsXCJcIitlXSk6Y2EuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWUmJlwib25TY3JvbGxcIj09PWcmJkcoXCJzY3JvbGxcIixkKSk7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlZhKGQpO2NiKGQsZiwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoZCk7amIoZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihkLm9uY2xpY2s9XG5qZil9ZD1hO2IudXBkYXRlUXVldWU9ZDtudWxsIT09ZCYmKGIuZmxhZ3N8PTQpfWVsc2V7Zz05PT09ZS5ub2RlVHlwZT9lOmUub3duZXJEb2N1bWVudDthPT09a2IuaHRtbCYmKGE9bGIoYykpO2E9PT1rYi5odG1sP1wic2NyaXB0XCI9PT1jPyhhPWcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTpcInN0cmluZ1wiPT09dHlwZW9mIGQuaXM/YT1nLmNyZWF0ZUVsZW1lbnQoYyx7aXM6ZC5pc30pOihhPWcuY3JlYXRlRWxlbWVudChjKSxcInNlbGVjdFwiPT09YyYmKGc9YSxkLm11bHRpcGxlP2cubXVsdGlwbGU9ITA6ZC5zaXplJiYoZy5zaXplPWQuc2l6ZSkpKTphPWcuY3JlYXRlRWxlbWVudE5TKGEsYyk7YVt3Zl09YjthW3hmXT1kO0JpKGEsYiwhMSwhMSk7Yi5zdGF0ZU5vZGU9YTtnPXdiKGMsZCk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpHKFwiY2FuY2VsXCIsYSk7RyhcImNsb3NlXCIsYSk7XG5lPWQ7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpHKFwibG9hZFwiLGEpO2U9ZDticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8WGUubGVuZ3RoO2UrKylHKFhlW2VdLGEpO2U9ZDticmVhaztjYXNlIFwic291cmNlXCI6RyhcImVycm9yXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkcoXCJlcnJvclwiLGEpO0coXCJsb2FkXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJkZXRhaWxzXCI6RyhcInRvZ2dsZVwiLGEpO2U9ZDticmVhaztjYXNlIFwiaW5wdXRcIjpaYShhLGQpO2U9WWEoYSxkKTtHKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjplPWViKGEsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFkLm11bHRpcGxlfTtlPW0oe30sZCx7dmFsdWU6dm9pZCAwfSk7RyhcImludmFsaWRcIixhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpoYihhLGQpO2U9XG5nYihhLGQpO0coXCJpbnZhbGlkXCIsYSk7YnJlYWs7ZGVmYXVsdDplPWR9dmIoYyxlKTt2YXIgaD1lO2ZvcihmIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGs9aFtmXTtcInN0eWxlXCI9PT1mP3RiKGEsayk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Zj8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZvYihhLGspKTpcImNoaWxkcmVuXCI9PT1mP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Y3x8XCJcIiE9PWspJiZwYihhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmcGIoYSxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1mJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZiYmXCJhdXRvRm9jdXNcIiE9PWYmJihjYS5oYXNPd25Qcm9wZXJ0eShmKT9udWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1mJiZHKFwic2Nyb2xsXCIsYSk6bnVsbCE9ayYmcWEoYSxmLGssZykpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpWYShhKTtjYihhLGQsITEpO1xuYnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoYSk7amIoYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOm51bGwhPWQudmFsdWUmJmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK1NhKGQudmFsdWUpKTticmVhaztjYXNlIFwic2VsZWN0XCI6YS5tdWx0aXBsZT0hIWQubXVsdGlwbGU7Zj1kLnZhbHVlO251bGwhPWY/ZmIoYSwhIWQubXVsdGlwbGUsZiwhMSk6bnVsbCE9ZC5kZWZhdWx0VmFsdWUmJmZiKGEsISFkLm11bHRpcGxlLGQuZGVmYXVsdFZhbHVlLCEwKTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLm9uQ2xpY2smJihhLm9uY2xpY2s9amYpfW1mKGMsZCkmJihiLmZsYWdzfD00KX1udWxsIT09Yi5yZWYmJihiLmZsYWdzfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlFaShhLGIsYS5tZW1vaXplZFByb3BzLGQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkJiZudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjYpKTtcbmM9ZGgoY2guY3VycmVudCk7ZGgoYWguY3VycmVudCk7cmgoYik/KGQ9Yi5zdGF0ZU5vZGUsYz1iLm1lbW9pemVkUHJvcHMsZFt3Zl09YixkLm5vZGVWYWx1ZSE9PWMmJihiLmZsYWdzfD00KSk6KGQ9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxkW3dmXT1iLGIuc3RhdGVOb2RlPWQpfXJldHVybiBudWxsO2Nhc2UgMTM6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZigwIT09KGIuZmxhZ3MmNjQpKXJldHVybiBiLmxhbmVzPWMsYjtkPW51bGwhPT1kO2M9ITE7bnVsbD09PWE/dm9pZCAwIT09Yi5tZW1vaXplZFByb3BzLmZhbGxiYWNrJiZyaChiKTpjPW51bGwhPT1hLm1lbW9pemVkU3RhdGU7aWYoZCYmIWMmJjAhPT0oYi5tb2RlJjIpKWlmKG51bGw9PT1hJiYhMCE9PWIubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFja3x8MCE9PShQLmN1cnJlbnQmMSkpMD09PVYmJihWPTMpO2Vsc2V7aWYoMD09PVZ8fDM9PT1WKVY9XG40O251bGw9PT1VfHwwPT09KERnJjEzNDIxNzcyNykmJjA9PT0oSGkmMTM0MjE3NzI3KXx8SWkoVSxXKX1pZihkfHxjKWIuZmxhZ3N8PTQ7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiBmaCgpLENpKGIpLG51bGw9PT1hJiZjZihiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxudWxsO2Nhc2UgMTA6cmV0dXJuIHJnKGIpLG51bGw7Y2FzZSAxNzpyZXR1cm4gRmYoYi50eXBlKSYmR2YoKSxudWxsO2Nhc2UgMTk6SChQKTtkPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZClyZXR1cm4gbnVsbDtmPTAhPT0oYi5mbGFncyY2NCk7Zz1kLnJlbmRlcmluZztpZihudWxsPT09ZylpZihmKUZpKGQsITEpO2Vsc2V7aWYoMCE9PVZ8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmNjQpKWZvcihhPWIuY2hpbGQ7bnVsbCE9PWE7KXtnPWloKGEpO2lmKG51bGwhPT1nKXtiLmZsYWdzfD02NDtGaShkLCExKTtmPWcudXBkYXRlUXVldWU7bnVsbCE9PWYmJihiLnVwZGF0ZVF1ZXVlPWYsYi5mbGFnc3w9NCk7XG5udWxsPT09ZC5sYXN0RWZmZWN0JiYoYi5maXJzdEVmZmVjdD1udWxsKTtiLmxhc3RFZmZlY3Q9ZC5sYXN0RWZmZWN0O2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTIsZi5uZXh0RWZmZWN0PW51bGwsZi5maXJzdEVmZmVjdD1udWxsLGYubGFzdEVmZmVjdD1udWxsLGc9Zi5hbHRlcm5hdGUsbnVsbD09PWc/KGYuY2hpbGRMYW5lcz0wLGYubGFuZXM9YSxmLmNoaWxkPW51bGwsZi5tZW1vaXplZFByb3BzPW51bGwsZi5tZW1vaXplZFN0YXRlPW51bGwsZi51cGRhdGVRdWV1ZT1udWxsLGYuZGVwZW5kZW5jaWVzPW51bGwsZi5zdGF0ZU5vZGU9bnVsbCk6KGYuY2hpbGRMYW5lcz1nLmNoaWxkTGFuZXMsZi5sYW5lcz1nLmxhbmVzLGYuY2hpbGQ9Zy5jaGlsZCxmLm1lbW9pemVkUHJvcHM9Zy5tZW1vaXplZFByb3BzLGYubWVtb2l6ZWRTdGF0ZT1nLm1lbW9pemVkU3RhdGUsZi51cGRhdGVRdWV1ZT1nLnVwZGF0ZVF1ZXVlLGYudHlwZT1nLnR5cGUsYT1nLmRlcGVuZGVuY2llcyxcbmYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7SShQLFAuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9YS5zaWJsaW5nfW51bGwhPT1kLnRhaWwmJk8oKT5KaSYmKGIuZmxhZ3N8PTY0LGY9ITAsRmkoZCwhMSksYi5sYW5lcz0zMzU1NDQzMil9ZWxzZXtpZighZilpZihhPWloKGcpLG51bGwhPT1hKXtpZihiLmZsYWdzfD02NCxmPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxGaShkLCEwKSxudWxsPT09ZC50YWlsJiZcImhpZGRlblwiPT09ZC50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhbGgpcmV0dXJuIGI9Yi5sYXN0RWZmZWN0PWQubGFzdEVmZmVjdCxudWxsIT09YiYmKGIubmV4dEVmZmVjdD1udWxsKSxudWxsfWVsc2UgMipPKCktZC5yZW5kZXJpbmdTdGFydFRpbWU+SmkmJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9XG42NCxmPSEwLEZpKGQsITEpLGIubGFuZXM9MzM1NTQ0MzIpO2QuaXNCYWNrd2FyZHM/KGcuc2libGluZz1iLmNoaWxkLGIuY2hpbGQ9Zyk6KGM9ZC5sYXN0LG51bGwhPT1jP2Muc2libGluZz1nOmIuY2hpbGQ9ZyxkLmxhc3Q9Zyl9cmV0dXJuIG51bGwhPT1kLnRhaWw/KGM9ZC50YWlsLGQucmVuZGVyaW5nPWMsZC50YWlsPWMuc2libGluZyxkLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0LGQucmVuZGVyaW5nU3RhcnRUaW1lPU8oKSxjLnNpYmxpbmc9bnVsbCxiPVAuY3VycmVudCxJKFAsZj9iJjF8MjpiJjEpLGMpOm51bGw7Y2FzZSAyMzpjYXNlIDI0OnJldHVybiBLaSgpLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09KG51bGwhPT1iLm1lbW9pemVkU3RhdGUpJiZcInVuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nXCIhPT1kLm1vZGUmJihiLmZsYWdzfD00KSxudWxsfXRocm93IEVycm9yKHkoMTU2LGIudGFnKSk7fVxuZnVuY3Rpb24gTGkoYSl7c3dpdGNoKGEudGFnKXtjYXNlIDE6RmYoYS50eXBlKSYmR2YoKTt2YXIgYj1hLmZsYWdzO3JldHVybiBiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMzpmaCgpO0goTik7SChNKTt1aCgpO2I9YS5mbGFncztpZigwIT09KGImNjQpKXRocm93IEVycm9yKHkoMjg1KSk7YS5mbGFncz1iJi00MDk3fDY0O3JldHVybiBhO2Nhc2UgNTpyZXR1cm4gaGgoYSksbnVsbDtjYXNlIDEzOnJldHVybiBIKFApLGI9YS5mbGFncyxiJjQwOTY/KGEuZmxhZ3M9YiYtNDA5N3w2NCxhKTpudWxsO2Nhc2UgMTk6cmV0dXJuIEgoUCksbnVsbDtjYXNlIDQ6cmV0dXJuIGZoKCksbnVsbDtjYXNlIDEwOnJldHVybiByZyhhKSxudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gS2koKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gTWkoYSxiKXt0cnl7dmFyIGM9XCJcIixkPWI7ZG8gYys9UWEoZCksZD1kLnJldHVybjt3aGlsZShkKTt2YXIgZT1jfWNhdGNoKGYpe2U9XCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIitmLm1lc3NhZ2UrXCJcXG5cIitmLnN0YWNrfXJldHVybnt2YWx1ZTphLHNvdXJjZTpiLHN0YWNrOmV9fWZ1bmN0aW9uIE5pKGEsYil7dHJ5e2NvbnNvbGUuZXJyb3IoYi52YWx1ZSl9Y2F0Y2goYyl7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGM7fSl9fXZhciBPaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha01hcD9XZWFrTWFwOk1hcDtmdW5jdGlvbiBQaShhLGIsYyl7Yz16ZygtMSxjKTtjLnRhZz0zO2MucGF5bG9hZD17ZWxlbWVudDpudWxsfTt2YXIgZD1iLnZhbHVlO2MuY2FsbGJhY2s9ZnVuY3Rpb24oKXtRaXx8KFFpPSEwLFJpPWQpO05pKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gU2koYSxiLGMpe2M9emcoLTEsYyk7Yy50YWc9Mzt2YXIgZD1hLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2YXIgZT1iLnZhbHVlO2MucGF5bG9hZD1mdW5jdGlvbigpe05pKGEsYik7cmV0dXJuIGQoZSl9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZCYmKG51bGw9PT1UaT9UaT1uZXcgU2V0KFt0aGlzXSk6VGkuYWRkKHRoaXMpLE5pKGEsYikpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfXZhciBVaT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgV2Vha1NldD9XZWFrU2V0OlNldDtcbmZ1bmN0aW9uIFZpKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXRyeXtiKG51bGwpfWNhdGNoKGMpe1dpKGEsYyl9ZWxzZSBiLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBYaShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOnJldHVybjtjYXNlIDE6aWYoYi5mbGFncyYyNTYmJm51bGwhPT1hKXt2YXIgYz1hLm1lbW9pemVkUHJvcHMsZD1hLm1lbW9pemVkU3RhdGU7YT1iLnN0YXRlTm9kZTtiPWEuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoYi5lbGVtZW50VHlwZT09PWIudHlwZT9jOmxnKGIudHlwZSxjKSxkKTthLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlPWJ9cmV0dXJuO2Nhc2UgMzpiLmZsYWdzJjI1NiYmcWYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7cmV0dXJuO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fVxuZnVuY3Rpb24gWWkoYSxiLGMpe3N3aXRjaChjLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpjYXNlIDIyOmI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve2lmKDM9PT0oYS50YWcmMykpe3ZhciBkPWEuY3JlYXRlO2EuZGVzdHJveT1kKCl9YT1hLm5leHR9d2hpbGUoYSE9PWIpfWI9Yy51cGRhdGVRdWV1ZTtiPW51bGwhPT1iP2IubGFzdEVmZmVjdDpudWxsO2lmKG51bGwhPT1iKXthPWI9Yi5uZXh0O2Rve3ZhciBlPWE7ZD1lLm5leHQ7ZT1lLnRhZzswIT09KGUmNCkmJjAhPT0oZSYxKSYmKFppKGMsYSksJGkoYyxhKSk7YT1kfXdoaWxlKGEhPT1iKX1yZXR1cm47Y2FzZSAxOmE9Yy5zdGF0ZU5vZGU7Yy5mbGFncyY0JiYobnVsbD09PWI/YS5jb21wb25lbnREaWRNb3VudCgpOihkPWMuZWxlbWVudFR5cGU9PT1jLnR5cGU/Yi5tZW1vaXplZFByb3BzOmxnKGMudHlwZSxiLm1lbW9pemVkUHJvcHMpLGEuY29tcG9uZW50RGlkVXBkYXRlKGQsXG5iLm1lbW9pemVkU3RhdGUsYS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSkpKTtiPWMudXBkYXRlUXVldWU7bnVsbCE9PWImJkVnKGMsYixhKTtyZXR1cm47Y2FzZSAzOmI9Yy51cGRhdGVRdWV1ZTtpZihudWxsIT09Yil7YT1udWxsO2lmKG51bGwhPT1jLmNoaWxkKXN3aXRjaChjLmNoaWxkLnRhZyl7Y2FzZSA1OmE9Yy5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmE9Yy5jaGlsZC5zdGF0ZU5vZGV9RWcoYyxiLGEpfXJldHVybjtjYXNlIDU6YT1jLnN0YXRlTm9kZTtudWxsPT09YiYmYy5mbGFncyY0JiZtZihjLnR5cGUsYy5tZW1vaXplZFByb3BzKSYmYS5mb2N1cygpO3JldHVybjtjYXNlIDY6cmV0dXJuO2Nhc2UgNDpyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsPT09Yy5tZW1vaXplZFN0YXRlJiYoYz1jLmFsdGVybmF0ZSxudWxsIT09YyYmKGM9Yy5tZW1vaXplZFN0YXRlLG51bGwhPT1jJiYoYz1jLmRlaHlkcmF0ZWQsbnVsbCE9PWMmJkNjKGMpKSkpO1xucmV0dXJuO2Nhc2UgMTk6Y2FzZSAxNzpjYXNlIDIwOmNhc2UgMjE6Y2FzZSAyMzpjYXNlIDI0OnJldHVybn10aHJvdyBFcnJvcih5KDE2MykpO31cbmZ1bmN0aW9uIGFqKGEsYil7Zm9yKHZhciBjPWE7Oyl7aWYoNT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihiKWQ9ZC5zdHlsZSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5zZXRQcm9wZXJ0eT9kLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwibm9uZVwiLFwiaW1wb3J0YW50XCIpOmQuZGlzcGxheT1cIm5vbmVcIjtlbHNle2Q9Yy5zdGF0ZU5vZGU7dmFyIGU9Yy5tZW1vaXplZFByb3BzLnN0eWxlO2U9dm9pZCAwIT09ZSYmbnVsbCE9PWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaXNwbGF5XCIpP2UuZGlzcGxheTpudWxsO2Quc3R5bGUuZGlzcGxheT1zYihcImRpc3BsYXlcIixlKX19ZWxzZSBpZig2PT09Yy50YWcpYy5zdGF0ZU5vZGUubm9kZVZhbHVlPWI/XCJcIjpjLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigoMjMhPT1jLnRhZyYmMjQhPT1jLnRhZ3x8bnVsbD09PWMubWVtb2l6ZWRTdGF0ZXx8Yz09PWEpJiZudWxsIT09Yy5jaGlsZCl7Yy5jaGlsZC5yZXR1cm49YztjPWMuY2hpbGQ7Y29udGludWV9aWYoYz09PVxuYSlicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YSlyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGJqKGEsYil7aWYoTWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBNZi5vbkNvbW1pdEZpYmVyVW5tb3VudCl0cnl7TWYub25Db21taXRGaWJlclVubW91bnQoTGYsYil9Y2F0Y2goZil7fXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNhc2UgMjI6YT1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1hJiYoYT1hLmxhc3RFZmZlY3QsbnVsbCE9PWEpKXt2YXIgYz1hPWEubmV4dDtkb3t2YXIgZD1jLGU9ZC5kZXN0cm95O2Q9ZC50YWc7aWYodm9pZCAwIT09ZSlpZigwIT09KGQmNCkpWmkoYixjKTtlbHNle2Q9Yjt0cnl7ZSgpfWNhdGNoKGYpe1dpKGQsZil9fWM9Yy5uZXh0fXdoaWxlKGMhPT1hKX1icmVhaztjYXNlIDE6VmkoYik7YT1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7YS5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYS5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYS5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGYpe1dpKGIsXG5mKX1icmVhaztjYXNlIDU6VmkoYik7YnJlYWs7Y2FzZSA0OmNqKGEsYil9fWZ1bmN0aW9uIGRqKGEpe2EuYWx0ZXJuYXRlPW51bGw7YS5jaGlsZD1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5maXJzdEVmZmVjdD1udWxsO2EubGFzdEVmZmVjdD1udWxsO2EubWVtb2l6ZWRQcm9wcz1udWxsO2EubWVtb2l6ZWRTdGF0ZT1udWxsO2EucGVuZGluZ1Byb3BzPW51bGw7YS5yZXR1cm49bnVsbDthLnVwZGF0ZVF1ZXVlPW51bGx9ZnVuY3Rpb24gZWooYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9XG5mdW5jdGlvbiBmaihhKXthOntmb3IodmFyIGI9YS5yZXR1cm47bnVsbCE9PWI7KXtpZihlaihiKSlicmVhayBhO2I9Yi5yZXR1cm59dGhyb3cgRXJyb3IoeSgxNjApKTt9dmFyIGM9YjtiPWMuc3RhdGVOb2RlO3N3aXRjaChjLnRhZyl7Y2FzZSA1OnZhciBkPSExO2JyZWFrO2Nhc2UgMzpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWIuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoeSgxNjEpKTt9Yy5mbGFncyYxNiYmKHBiKGIsXCJcIiksYy5mbGFncyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGVqKGMucmV0dXJuKSl7Yz1udWxsO2JyZWFrIGF9Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZyYmMTghPT1jLnRhZzspe2lmKGMuZmxhZ3MmMiljb250aW51ZSBiO2lmKG51bGw9PT1cbmMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZC5yZXR1cm49YyxjPWMuY2hpbGR9aWYoIShjLmZsYWdzJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWQ/Z2ooYSxjLGIpOmhqKGEsYyxiKX1cbmZ1bmN0aW9uIGdqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiPzg9PT1jLm5vZGVUeXBlP2MucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxiKTpjLmluc2VydEJlZm9yZShhLGIpOig4PT09Yy5ub2RlVHlwZT8oYj1jLnBhcmVudE5vZGUsYi5pbnNlcnRCZWZvcmUoYSxjKSk6KGI9YyxiLmFwcGVuZENoaWxkKGEpKSxjPWMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsIT09YyYmdm9pZCAwIT09Y3x8bnVsbCE9PWIub25jbGlja3x8KGIub25jbGljaz1qZikpO2Vsc2UgaWYoNCE9PWQmJihhPWEuY2hpbGQsbnVsbCE9PWEpKWZvcihnaihhLGIsYyksYT1hLnNpYmxpbmc7bnVsbCE9PWE7KWdqKGEsYixjKSxhPWEuc2libGluZ31cbmZ1bmN0aW9uIGhqKGEsYixjKXt2YXIgZD1hLnRhZyxlPTU9PT1kfHw2PT09ZDtpZihlKWE9ZT9hLnN0YXRlTm9kZTphLnN0YXRlTm9kZS5pbnN0YW5jZSxiP2MuaW5zZXJ0QmVmb3JlKGEsYik6Yy5hcHBlbmRDaGlsZChhKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoaGooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOyloaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBjaihhLGIpe2Zvcih2YXIgYz1iLGQ9ITEsZSxmOzspe2lmKCFkKXtkPWMucmV0dXJuO2E6Zm9yKDs7KXtpZihudWxsPT09ZCl0aHJvdyBFcnJvcih5KDE2MCkpO2U9ZC5zdGF0ZU5vZGU7c3dpdGNoKGQudGFnKXtjYXNlIDU6Zj0hMTticmVhayBhO2Nhc2UgMzplPWUuY29udGFpbmVySW5mbztmPSEwO2JyZWFrIGE7Y2FzZSA0OmU9ZS5jb250YWluZXJJbmZvO2Y9ITA7YnJlYWsgYX1kPWQucmV0dXJufWQ9ITB9aWYoNT09PWMudGFnfHw2PT09Yy50YWcpe2E6Zm9yKHZhciBnPWEsaD1jLGs9aDs7KWlmKGJqKGcsayksbnVsbCE9PWsuY2hpbGQmJjQhPT1rLnRhZylrLmNoaWxkLnJldHVybj1rLGs9ay5jaGlsZDtlbHNle2lmKGs9PT1oKWJyZWFrIGE7Zm9yKDtudWxsPT09ay5zaWJsaW5nOyl7aWYobnVsbD09PWsucmV0dXJufHxrLnJldHVybj09PWgpYnJlYWsgYTtrPWsucmV0dXJufWsuc2libGluZy5yZXR1cm49ay5yZXR1cm47az1rLnNpYmxpbmd9Zj8oZz1lLGg9Yy5zdGF0ZU5vZGUsXG44PT09Zy5ub2RlVHlwZT9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaCk6Zy5yZW1vdmVDaGlsZChoKSk6ZS5yZW1vdmVDaGlsZChjLnN0YXRlTm9kZSl9ZWxzZSBpZig0PT09Yy50YWcpe2lmKG51bGwhPT1jLmNoaWxkKXtlPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zj0hMDtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX19ZWxzZSBpZihiaihhLGMpLG51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybjs0PT09Yy50YWcmJihkPSExKX1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX1cbmZ1bmN0aW9uIGlqKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAyMjp2YXIgYz1iLnVwZGF0ZVF1ZXVlO2M9bnVsbCE9PWM/Yy5sYXN0RWZmZWN0Om51bGw7aWYobnVsbCE9PWMpe3ZhciBkPWM9Yy5uZXh0O2RvIDM9PT0oZC50YWcmMykmJihhPWQuZGVzdHJveSxkLmRlc3Ryb3k9dm9pZCAwLHZvaWQgMCE9PWEmJmEoKSksZD1kLm5leHQ7d2hpbGUoZCE9PWMpfXJldHVybjtjYXNlIDE6cmV0dXJuO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe2Q9Yi5tZW1vaXplZFByb3BzO3ZhciBlPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO2E9Yi50eXBlO3ZhciBmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO2lmKG51bGwhPT1mKXtjW3hmXT1kO1wiaW5wdXRcIj09PWEmJlwicmFkaW9cIj09PWQudHlwZSYmbnVsbCE9ZC5uYW1lJiYkYShjLGQpO3diKGEsZSk7Yj13YihhLGQpO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKz1cbjIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz90YihjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/b2IoYyxoKTpcImNoaWxkcmVuXCI9PT1nP3BiKGMsaCk6cWEoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOmFiKGMsZCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYyxkKTticmVhaztjYXNlIFwic2VsZWN0XCI6YT1jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsYy5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlPSEhZC5tdWx0aXBsZSxmPWQudmFsdWUsbnVsbCE9Zj9mYihjLCEhZC5tdWx0aXBsZSxmLCExKTphIT09ISFkLm11bHRpcGxlJiYobnVsbCE9ZC5kZWZhdWx0VmFsdWU/ZmIoYywhIWQubXVsdGlwbGUsZC5kZWZhdWx0VmFsdWUsITApOmZiKGMsISFkLm11bHRpcGxlLGQubXVsdGlwbGU/W106XCJcIiwhMSkpfX19cmV0dXJuO2Nhc2UgNjppZihudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IoeSgxNjIpKTtiLnN0YXRlTm9kZS5ub2RlVmFsdWU9XG5iLm1lbW9pemVkUHJvcHM7cmV0dXJuO2Nhc2UgMzpjPWIuc3RhdGVOb2RlO2MuaHlkcmF0ZSYmKGMuaHlkcmF0ZT0hMSxDYyhjLmNvbnRhaW5lckluZm8pKTtyZXR1cm47Y2FzZSAxMjpyZXR1cm47Y2FzZSAxMzpudWxsIT09Yi5tZW1vaXplZFN0YXRlJiYoamo9TygpLGFqKGIuY2hpbGQsITApKTtraihiKTtyZXR1cm47Y2FzZSAxOTpraihiKTtyZXR1cm47Y2FzZSAxNzpyZXR1cm47Y2FzZSAyMzpjYXNlIDI0OmFqKGIsbnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSk7cmV0dXJufXRocm93IEVycm9yKHkoMTYzKSk7fWZ1bmN0aW9uIGtqKGEpe3ZhciBiPWEudXBkYXRlUXVldWU7aWYobnVsbCE9PWIpe2EudXBkYXRlUXVldWU9bnVsbDt2YXIgYz1hLnN0YXRlTm9kZTtudWxsPT09YyYmKGM9YS5zdGF0ZU5vZGU9bmV3IFVpKTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9bGouYmluZChudWxsLGEsYik7Yy5oYXMoYil8fChjLmFkZChiKSxiLnRoZW4oZCxkKSl9KX19XG5mdW5jdGlvbiBtaihhLGIpe3JldHVybiBudWxsIT09YSYmKGE9YS5tZW1vaXplZFN0YXRlLG51bGw9PT1hfHxudWxsIT09YS5kZWh5ZHJhdGVkKT8oYj1iLm1lbW9pemVkU3RhdGUsbnVsbCE9PWImJm51bGw9PT1iLmRlaHlkcmF0ZWQpOiExfXZhciBuaj1NYXRoLmNlaWwsb2o9cmEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixwaj1yYS5SZWFjdEN1cnJlbnRPd25lcixYPTAsVT1udWxsLFk9bnVsbCxXPTAscWo9MCxyaj1CZigwKSxWPTAsc2o9bnVsbCx0aj0wLERnPTAsSGk9MCx1aj0wLHZqPW51bGwsamo9MCxKaT1JbmZpbml0eTtmdW5jdGlvbiB3aigpe0ppPU8oKSs1MDB9dmFyIFo9bnVsbCxRaT0hMSxSaT1udWxsLFRpPW51bGwseGo9ITEseWo9bnVsbCx6aj05MCxBaj1bXSxCaj1bXSxDaj1udWxsLERqPTAsRWo9bnVsbCxGaj0tMSxHaj0wLEhqPTAsSWo9bnVsbCxKaj0hMTtmdW5jdGlvbiBIZygpe3JldHVybiAwIT09KFgmNDgpP08oKTotMSE9PUZqP0ZqOkZqPU8oKX1cbmZ1bmN0aW9uIElnKGEpe2E9YS5tb2RlO2lmKDA9PT0oYSYyKSlyZXR1cm4gMTtpZigwPT09KGEmNCkpcmV0dXJuIDk5PT09ZWcoKT8xOjI7MD09PUdqJiYoR2o9dGopO2lmKDAhPT1rZy50cmFuc2l0aW9uKXswIT09SGomJihIaj1udWxsIT09dmo/dmoucGVuZGluZ0xhbmVzOjApO2E9R2o7dmFyIGI9NDE4NjExMiZ+SGo7YiY9LWI7MD09PWImJihhPTQxODYxMTImfmEsYj1hJi1hLDA9PT1iJiYoYj04MTkyKSk7cmV0dXJuIGJ9YT1lZygpOzAhPT0oWCY0KSYmOTg9PT1hP2E9WGMoMTIsR2opOihhPVNjKGEpLGE9WGMoYSxHaikpO3JldHVybiBhfVxuZnVuY3Rpb24gSmcoYSxiLGMpe2lmKDUwPERqKXRocm93IERqPTAsRWo9bnVsbCxFcnJvcih5KDE4NSkpO2E9S2ooYSxiKTtpZihudWxsPT09YSlyZXR1cm4gbnVsbDskYyhhLGIsYyk7YT09PVUmJihIaXw9Yiw0PT09ViYmSWkoYSxXKSk7dmFyIGQ9ZWcoKTsxPT09Yj8wIT09KFgmOCkmJjA9PT0oWCY0OCk/TGooYSk6KE1qKGEsYyksMD09PVgmJih3aigpLGlnKCkpKTooMD09PShYJjQpfHw5OCE9PWQmJjk5IT09ZHx8KG51bGw9PT1Daj9Daj1uZXcgU2V0KFthXSk6Q2ouYWRkKGEpKSxNaihhLGMpKTt2aj1hfWZ1bmN0aW9uIEtqKGEsYil7YS5sYW5lc3w9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKGMubGFuZXN8PWIpO2M9YTtmb3IoYT1hLnJldHVybjtudWxsIT09YTspYS5jaGlsZExhbmVzfD1iLGM9YS5hbHRlcm5hdGUsbnVsbCE9PWMmJihjLmNoaWxkTGFuZXN8PWIpLGM9YSxhPWEucmV0dXJuO3JldHVybiAzPT09Yy50YWc/Yy5zdGF0ZU5vZGU6bnVsbH1cbmZ1bmN0aW9uIE1qKGEsYil7Zm9yKHZhciBjPWEuY2FsbGJhY2tOb2RlLGQ9YS5zdXNwZW5kZWRMYW5lcyxlPWEucGluZ2VkTGFuZXMsZj1hLmV4cGlyYXRpb25UaW1lcyxnPWEucGVuZGluZ0xhbmVzOzA8Zzspe3ZhciBoPTMxLVZjKGcpLGs9MTw8aCxsPWZbaF07aWYoLTE9PT1sKXtpZigwPT09KGsmZCl8fDAhPT0oayZlKSl7bD1iO1JjKGspO3ZhciBuPUY7ZltoXT0xMDw9bj9sKzI1MDo2PD1uP2wrNUUzOi0xfX1lbHNlIGw8PWImJihhLmV4cGlyZWRMYW5lc3w9ayk7ZyY9fmt9ZD1VYyhhLGE9PT1VP1c6MCk7Yj1GO2lmKDA9PT1kKW51bGwhPT1jJiYoYyE9PVpmJiZQZihjKSxhLmNhbGxiYWNrTm9kZT1udWxsLGEuY2FsbGJhY2tQcmlvcml0eT0wKTtlbHNle2lmKG51bGwhPT1jKXtpZihhLmNhbGxiYWNrUHJpb3JpdHk9PT1iKXJldHVybjtjIT09WmYmJlBmKGMpfTE1PT09Yj8oYz1Mai5iaW5kKG51bGwsYSksbnVsbD09PWFnPyhhZz1bY10sYmc9T2YoVWYsamcpKTphZy5wdXNoKGMpLFxuYz1aZik6MTQ9PT1iP2M9aGcoOTksTGouYmluZChudWxsLGEpKTooYz1UYyhiKSxjPWhnKGMsTmouYmluZChudWxsLGEpKSk7YS5jYWxsYmFja1ByaW9yaXR5PWI7YS5jYWxsYmFja05vZGU9Y319XG5mdW5jdGlvbiBOaihhKXtGaj0tMTtIaj1Haj0wO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYj1hLmNhbGxiYWNrTm9kZTtpZihPaigpJiZhLmNhbGxiYWNrTm9kZSE9PWIpcmV0dXJuIG51bGw7dmFyIGM9VWMoYSxhPT09VT9XOjApO2lmKDA9PT1jKXJldHVybiBudWxsO3ZhciBkPWM7dmFyIGU9WDtYfD0xNjt2YXIgZj1QaigpO2lmKFUhPT1hfHxXIT09ZCl3aigpLFFqKGEsZCk7ZG8gdHJ5e1JqKCk7YnJlYWt9Y2F0Y2goaCl7U2ooYSxoKX13aGlsZSgxKTtxZygpO29qLmN1cnJlbnQ9ZjtYPWU7bnVsbCE9PVk/ZD0wOihVPW51bGwsVz0wLGQ9Vik7aWYoMCE9PSh0aiZIaSkpUWooYSwwKTtlbHNlIGlmKDAhPT1kKXsyPT09ZCYmKFh8PTY0LGEuaHlkcmF0ZSYmKGEuaHlkcmF0ZT0hMSxxZihhLmNvbnRhaW5lckluZm8pKSxjPVdjKGEpLDAhPT1jJiYoZD1UaihhLGMpKSk7aWYoMT09PWQpdGhyb3cgYj1zaixRaihhLDApLElpKGEsYyksTWooYSxPKCkpLGI7YS5maW5pc2hlZFdvcms9XG5hLmN1cnJlbnQuYWx0ZXJuYXRlO2EuZmluaXNoZWRMYW5lcz1jO3N3aXRjaChkKXtjYXNlIDA6Y2FzZSAxOnRocm93IEVycm9yKHkoMzQ1KSk7Y2FzZSAyOlVqKGEpO2JyZWFrO2Nhc2UgMzpJaShhLGMpO2lmKChjJjYyOTE0NTYwKT09PWMmJihkPWpqKzUwMC1PKCksMTA8ZCkpe2lmKDAhPT1VYyhhLDApKWJyZWFrO2U9YS5zdXNwZW5kZWRMYW5lcztpZigoZSZjKSE9PWMpe0hnKCk7YS5waW5nZWRMYW5lc3w9YS5zdXNwZW5kZWRMYW5lcyZlO2JyZWFrfWEudGltZW91dEhhbmRsZT1vZihVai5iaW5kKG51bGwsYSksZCk7YnJlYWt9VWooYSk7YnJlYWs7Y2FzZSA0OklpKGEsYyk7aWYoKGMmNDE4NjExMik9PT1jKWJyZWFrO2Q9YS5ldmVudFRpbWVzO2ZvcihlPS0xOzA8Yzspe3ZhciBnPTMxLVZjKGMpO2Y9MTw8ZztnPWRbZ107Zz5lJiYoZT1nKTtjJj1+Zn1jPWU7Yz1PKCktYztjPSgxMjA+Yz8xMjA6NDgwPmM/NDgwOjEwODA+Yz8xMDgwOjE5MjA+Yz8xOTIwOjNFMz5jPzNFMzo0MzIwPlxuYz80MzIwOjE5NjAqbmooYy8xOTYwKSktYztpZigxMDxjKXthLnRpbWVvdXRIYW5kbGU9b2YoVWouYmluZChudWxsLGEpLGMpO2JyZWFrfVVqKGEpO2JyZWFrO2Nhc2UgNTpVaihhKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHkoMzI5KSk7fX1NaihhLE8oKSk7cmV0dXJuIGEuY2FsbGJhY2tOb2RlPT09Yj9Oai5iaW5kKG51bGwsYSk6bnVsbH1mdW5jdGlvbiBJaShhLGIpe2ImPX51ajtiJj1+SGk7YS5zdXNwZW5kZWRMYW5lc3w9YjthLnBpbmdlZExhbmVzJj1+Yjtmb3IoYT1hLmV4cGlyYXRpb25UaW1lczswPGI7KXt2YXIgYz0zMS1WYyhiKSxkPTE8PGM7YVtjXT0tMTtiJj1+ZH19XG5mdW5jdGlvbiBMaihhKXtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzI3KSk7T2ooKTtpZihhPT09VSYmMCE9PShhLmV4cGlyZWRMYW5lcyZXKSl7dmFyIGI9Vzt2YXIgYz1UaihhLGIpOzAhPT0odGomSGkpJiYoYj1VYyhhLGIpLGM9VGooYSxiKSl9ZWxzZSBiPVVjKGEsMCksYz1UaihhLGIpOzAhPT1hLnRhZyYmMj09PWMmJihYfD02NCxhLmh5ZHJhdGUmJihhLmh5ZHJhdGU9ITEscWYoYS5jb250YWluZXJJbmZvKSksYj1XYyhhKSwwIT09YiYmKGM9VGooYSxiKSkpO2lmKDE9PT1jKXRocm93IGM9c2osUWooYSwwKSxJaShhLGIpLE1qKGEsTygpKSxjO2EuZmluaXNoZWRXb3JrPWEuY3VycmVudC5hbHRlcm5hdGU7YS5maW5pc2hlZExhbmVzPWI7VWooYSk7TWooYSxPKCkpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gVmooKXtpZihudWxsIT09Q2ope3ZhciBhPUNqO0NqPW51bGw7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZXhwaXJlZExhbmVzfD0yNCZhLnBlbmRpbmdMYW5lcztNaihhLE8oKSl9KX1pZygpfWZ1bmN0aW9uIFdqKGEsYil7dmFyIGM9WDtYfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIFhqKGEsYil7dmFyIGM9WDtYJj0tMjtYfD04O3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e1g9YywwPT09WCYmKHdqKCksaWcoKSl9fWZ1bmN0aW9uIG5pKGEsYil7SShyaixxaik7cWp8PWI7dGp8PWJ9ZnVuY3Rpb24gS2koKXtxaj1yai5jdXJyZW50O0gocmopfVxuZnVuY3Rpb24gUWooYSxiKXthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO3ZhciBjPWEudGltZW91dEhhbmRsZTstMSE9PWMmJihhLnRpbWVvdXRIYW5kbGU9LTEscGYoYykpO2lmKG51bGwhPT1ZKWZvcihjPVkucmV0dXJuO251bGwhPT1jOyl7dmFyIGQ9Yztzd2l0Y2goZC50YWcpe2Nhc2UgMTpkPWQudHlwZS5jaGlsZENvbnRleHRUeXBlcztudWxsIT09ZCYmdm9pZCAwIT09ZCYmR2YoKTticmVhaztjYXNlIDM6ZmgoKTtIKE4pO0goTSk7dWgoKTticmVhaztjYXNlIDU6aGgoZCk7YnJlYWs7Y2FzZSA0OmZoKCk7YnJlYWs7Y2FzZSAxMzpIKFApO2JyZWFrO2Nhc2UgMTk6SChQKTticmVhaztjYXNlIDEwOnJnKGQpO2JyZWFrO2Nhc2UgMjM6Y2FzZSAyNDpLaSgpfWM9Yy5yZXR1cm59VT1hO1k9VGcoYS5jdXJyZW50LG51bGwpO1c9cWo9dGo9YjtWPTA7c2o9bnVsbDt1aj1IaT1EZz0wfVxuZnVuY3Rpb24gU2ooYSxiKXtkb3t2YXIgYz1ZO3RyeXtxZygpO3ZoLmN1cnJlbnQ9R2g7aWYoeWgpe2Zvcih2YXIgZD1SLm1lbW9pemVkU3RhdGU7bnVsbCE9PWQ7KXt2YXIgZT1kLnF1ZXVlO251bGwhPT1lJiYoZS5wZW5kaW5nPW51bGwpO2Q9ZC5uZXh0fXloPSExfXhoPTA7VD1TPVI9bnVsbDt6aD0hMTtwai5jdXJyZW50PW51bGw7aWYobnVsbD09PWN8fG51bGw9PT1jLnJldHVybil7Vj0xO3NqPWI7WT1udWxsO2JyZWFrfWE6e3ZhciBmPWEsZz1jLnJldHVybixoPWMsaz1iO2I9VztoLmZsYWdzfD0yMDQ4O2guZmlyc3RFZmZlY3Q9aC5sYXN0RWZmZWN0PW51bGw7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9aztpZigwPT09KGgubW9kZSYyKSl7dmFyIG49aC5hbHRlcm5hdGU7bj8oaC51cGRhdGVRdWV1ZT1uLnVwZGF0ZVF1ZXVlLGgubWVtb2l6ZWRTdGF0ZT1uLm1lbW9pemVkU3RhdGUsaC5sYW5lcz1uLmxhbmVzKTpcbihoLnVwZGF0ZVF1ZXVlPW51bGwsaC5tZW1vaXplZFN0YXRlPW51bGwpfXZhciBBPTAhPT0oUC5jdXJyZW50JjEpLHA9Zztkb3t2YXIgQztpZihDPTEzPT09cC50YWcpe3ZhciB4PXAubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09eClDPW51bGwhPT14LmRlaHlkcmF0ZWQ/ITA6ITE7ZWxzZXt2YXIgdz1wLm1lbW9pemVkUHJvcHM7Qz12b2lkIDA9PT13LmZhbGxiYWNrPyExOiEwIT09dy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjaz8hMDpBPyExOiEwfX1pZihDKXt2YXIgej1wLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT16KXt2YXIgdT1uZXcgU2V0O3UuYWRkKGwpO3AudXBkYXRlUXVldWU9dX1lbHNlIHouYWRkKGwpO2lmKDA9PT0ocC5tb2RlJjIpKXtwLmZsYWdzfD02NDtoLmZsYWdzfD0xNjM4NDtoLmZsYWdzJj0tMjk4MTtpZigxPT09aC50YWcpaWYobnVsbD09PWguYWx0ZXJuYXRlKWgudGFnPTE3O2Vsc2V7dmFyIHQ9emcoLTEsMSk7dC50YWc9MjtBZyhoLHQpfWgubGFuZXN8PTE7YnJlYWsgYX1rPVxudm9pZCAwO2g9Yjt2YXIgcT1mLnBpbmdDYWNoZTtudWxsPT09cT8ocT1mLnBpbmdDYWNoZT1uZXcgT2ksaz1uZXcgU2V0LHEuc2V0KGwsaykpOihrPXEuZ2V0KGwpLHZvaWQgMD09PWsmJihrPW5ldyBTZXQscS5zZXQobCxrKSkpO2lmKCFrLmhhcyhoKSl7ay5hZGQoaCk7dmFyIHY9WWouYmluZChudWxsLGYsbCxoKTtsLnRoZW4odix2KX1wLmZsYWdzfD00MDk2O3AubGFuZXM9YjticmVhayBhfXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApO2s9RXJyb3IoKFJhKGgudHlwZSl8fFwiQSBSZWFjdCBjb21wb25lbnRcIikrXCIgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIil9NSE9PVYmJihWPTIpO2s9TWkoayxoKTtwPVxuZztkb3tzd2l0Y2gocC50YWcpe2Nhc2UgMzpmPWs7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBKPVBpKHAsZixiKTtCZyhwLEopO2JyZWFrIGE7Y2FzZSAxOmY9azt2YXIgSz1wLnR5cGUsUT1wLnN0YXRlTm9kZTtpZigwPT09KHAuZmxhZ3MmNjQpJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIEsuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09USYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFEuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoUSkpKSl7cC5mbGFnc3w9NDA5NjtiJj0tYjtwLmxhbmVzfD1iO3ZhciBMPVNpKHAsZixiKTtCZyhwLEwpO2JyZWFrIGF9fXA9cC5yZXR1cm59d2hpbGUobnVsbCE9PXApfVpqKGMpfWNhdGNoKHZhKXtiPXZhO1k9PT1jJiZudWxsIT09YyYmKFk9Yz1jLnJldHVybik7Y29udGludWV9YnJlYWt9d2hpbGUoMSl9XG5mdW5jdGlvbiBQaigpe3ZhciBhPW9qLmN1cnJlbnQ7b2ouY3VycmVudD1HaDtyZXR1cm4gbnVsbD09PWE/R2g6YX1mdW5jdGlvbiBUaihhLGIpe3ZhciBjPVg7WHw9MTY7dmFyIGQ9UGooKTtVPT09YSYmVz09PWJ8fFFqKGEsYik7ZG8gdHJ5e2FrKCk7YnJlYWt9Y2F0Y2goZSl7U2ooYSxlKX13aGlsZSgxKTtxZygpO1g9Yztvai5jdXJyZW50PWQ7aWYobnVsbCE9PVkpdGhyb3cgRXJyb3IoeSgyNjEpKTtVPW51bGw7Vz0wO3JldHVybiBWfWZ1bmN0aW9uIGFrKCl7Zm9yKDtudWxsIT09WTspYmsoWSl9ZnVuY3Rpb24gUmooKXtmb3IoO251bGwhPT1ZJiYhUWYoKTspYmsoWSl9ZnVuY3Rpb24gYmsoYSl7dmFyIGI9Y2soYS5hbHRlcm5hdGUsYSxxaik7YS5tZW1vaXplZFByb3BzPWEucGVuZGluZ1Byb3BzO251bGw9PT1iP1pqKGEpOlk9Yjtwai5jdXJyZW50PW51bGx9XG5mdW5jdGlvbiBaaihhKXt2YXIgYj1hO2Rve3ZhciBjPWIuYWx0ZXJuYXRlO2E9Yi5yZXR1cm47aWYoMD09PShiLmZsYWdzJjIwNDgpKXtjPUdpKGMsYixxaik7aWYobnVsbCE9PWMpe1k9YztyZXR1cm59Yz1iO2lmKDI0IT09Yy50YWcmJjIzIT09Yy50YWd8fG51bGw9PT1jLm1lbW9pemVkU3RhdGV8fDAhPT0ocWomMTA3Mzc0MTgyNCl8fDA9PT0oYy5tb2RlJjQpKXtmb3IodmFyIGQ9MCxlPWMuY2hpbGQ7bnVsbCE9PWU7KWR8PWUubGFuZXN8ZS5jaGlsZExhbmVzLGU9ZS5zaWJsaW5nO2MuY2hpbGRMYW5lcz1kfW51bGwhPT1hJiYwPT09KGEuZmxhZ3MmMjA0OCkmJihudWxsPT09YS5maXJzdEVmZmVjdCYmKGEuZmlyc3RFZmZlY3Q9Yi5maXJzdEVmZmVjdCksbnVsbCE9PWIubGFzdEVmZmVjdCYmKG51bGwhPT1hLmxhc3RFZmZlY3QmJihhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1iLmZpcnN0RWZmZWN0KSxhLmxhc3RFZmZlY3Q9Yi5sYXN0RWZmZWN0KSwxPGIuZmxhZ3MmJihudWxsIT09XG5hLmxhc3RFZmZlY3Q/YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YjphLmZpcnN0RWZmZWN0PWIsYS5sYXN0RWZmZWN0PWIpKX1lbHNle2M9TGkoYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTIwNDc7WT1jO3JldHVybn1udWxsIT09YSYmKGEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PW51bGwsYS5mbGFnc3w9MjA0OCl9Yj1iLnNpYmxpbmc7aWYobnVsbCE9PWIpe1k9YjtyZXR1cm59WT1iPWF9d2hpbGUobnVsbCE9PWIpOzA9PT1WJiYoVj01KX1mdW5jdGlvbiBVaihhKXt2YXIgYj1lZygpO2dnKDk5LGRrLmJpbmQobnVsbCxhLGIpKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGRrKGEsYil7ZG8gT2ooKTt3aGlsZShudWxsIT09eWopO2lmKDAhPT0oWCY0OCkpdGhyb3cgRXJyb3IoeSgzMjcpKTt2YXIgYz1hLmZpbmlzaGVkV29yaztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IoeSgxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO3ZhciBkPWMubGFuZXN8Yy5jaGlsZExhbmVzLGU9ZCxmPWEucGVuZGluZ0xhbmVzJn5lO2EucGVuZGluZ0xhbmVzPWU7YS5zdXNwZW5kZWRMYW5lcz0wO2EucGluZ2VkTGFuZXM9MDthLmV4cGlyZWRMYW5lcyY9ZTthLm11dGFibGVSZWFkTGFuZXMmPWU7YS5lbnRhbmdsZWRMYW5lcyY9ZTtlPWEuZW50YW5nbGVtZW50cztmb3IodmFyIGc9YS5ldmVudFRpbWVzLGg9YS5leHBpcmF0aW9uVGltZXM7MDxmOyl7dmFyIGs9MzEtVmMoZiksbD0xPDxrO2Vba109MDtnW2tdPS0xO2hba109LTE7ZiY9fmx9bnVsbCE9PVxuQ2omJjA9PT0oZCYyNCkmJkNqLmhhcyhhKSYmQ2ouZGVsZXRlKGEpO2E9PT1VJiYoWT1VPW51bGwsVz0wKTsxPGMuZmxhZ3M/bnVsbCE9PWMubGFzdEVmZmVjdD8oYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxkPWMuZmlyc3RFZmZlY3QpOmQ9YzpkPWMuZmlyc3RFZmZlY3Q7aWYobnVsbCE9PWQpe2U9WDtYfD0zMjtwai5jdXJyZW50PW51bGw7a2Y9ZmQ7Zz1OZSgpO2lmKE9lKGcpKXtpZihcInNlbGVjdGlvblN0YXJ0XCJpbiBnKWg9e3N0YXJ0Omcuc2VsZWN0aW9uU3RhcnQsZW5kOmcuc2VsZWN0aW9uRW5kfTtlbHNlIGE6aWYoaD0oaD1nLm93bmVyRG9jdW1lbnQpJiZoLmRlZmF1bHRWaWV3fHx3aW5kb3csKGw9aC5nZXRTZWxlY3Rpb24mJmguZ2V0U2VsZWN0aW9uKCkpJiYwIT09bC5yYW5nZUNvdW50KXtoPWwuYW5jaG9yTm9kZTtmPWwuYW5jaG9yT2Zmc2V0O2s9bC5mb2N1c05vZGU7bD1sLmZvY3VzT2Zmc2V0O3RyeXtoLm5vZGVUeXBlLGsubm9kZVR5cGV9Y2F0Y2godmEpe2g9bnVsbDtcbmJyZWFrIGF9dmFyIG49MCxBPS0xLHA9LTEsQz0wLHg9MCx3PWcsej1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7dyE9PWh8fDAhPT1mJiYzIT09dy5ub2RlVHlwZXx8KEE9bitmKTt3IT09a3x8MCE9PWwmJjMhPT13Lm5vZGVUeXBlfHwocD1uK2wpOzM9PT13Lm5vZGVUeXBlJiYobis9dy5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9dy5maXJzdENoaWxkKSlicmVhazt6PXc7dz11fWZvcig7Oyl7aWYodz09PWcpYnJlYWsgYjt6PT09aCYmKytDPT09ZiYmKEE9bik7ej09PWsmJisreD09PWwmJihwPW4pO2lmKG51bGwhPT0odT13Lm5leHRTaWJsaW5nKSlicmVhazt3PXo7ej13LnBhcmVudE5vZGV9dz11fWg9LTE9PT1BfHwtMT09PXA/bnVsbDp7c3RhcnQ6QSxlbmQ6cH19ZWxzZSBoPW51bGw7aD1ofHx7c3RhcnQ6MCxlbmQ6MH19ZWxzZSBoPW51bGw7bGY9e2ZvY3VzZWRFbGVtOmcsc2VsZWN0aW9uUmFuZ2U6aH07ZmQ9ITE7SWo9bnVsbDtKaj0hMTtaPWQ7ZG8gdHJ5e2VrKCl9Y2F0Y2godmEpe2lmKG51bGw9PT1cblopdGhyb3cgRXJyb3IoeSgzMzApKTtXaShaLHZhKTtaPVoubmV4dEVmZmVjdH13aGlsZShudWxsIT09Wik7SWo9bnVsbDtaPWQ7ZG8gdHJ5e2ZvcihnPWE7bnVsbCE9PVo7KXt2YXIgdD1aLmZsYWdzO3QmMTYmJnBiKFouc3RhdGVOb2RlLFwiXCIpO2lmKHQmMTI4KXt2YXIgcT1aLmFsdGVybmF0ZTtpZihudWxsIT09cSl7dmFyIHY9cS5yZWY7bnVsbCE9PXYmJihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygdj92KG51bGwpOnYuY3VycmVudD1udWxsKX19c3dpdGNoKHQmMTAzOCl7Y2FzZSAyOmZqKFopO1ouZmxhZ3MmPS0zO2JyZWFrO2Nhc2UgNjpmaihaKTtaLmZsYWdzJj0tMztpaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDEwMjQ6Wi5mbGFncyY9LTEwMjU7YnJlYWs7Y2FzZSAxMDI4OlouZmxhZ3MmPS0xMDI1O2lqKFouYWx0ZXJuYXRlLFopO2JyZWFrO2Nhc2UgNDppaihaLmFsdGVybmF0ZSxaKTticmVhaztjYXNlIDg6aD1aO2NqKGcsaCk7dmFyIEo9aC5hbHRlcm5hdGU7ZGooaCk7bnVsbCE9PVxuSiYmZGooSil9Wj1aLm5leHRFZmZlY3R9fWNhdGNoKHZhKXtpZihudWxsPT09Wil0aHJvdyBFcnJvcih5KDMzMCkpO1dpKFosdmEpO1o9Wi5uZXh0RWZmZWN0fXdoaWxlKG51bGwhPT1aKTt2PWxmO3E9TmUoKTt0PXYuZm9jdXNlZEVsZW07Zz12LnNlbGVjdGlvblJhbmdlO2lmKHEhPT10JiZ0JiZ0Lm93bmVyRG9jdW1lbnQmJk1lKHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdCkpe251bGwhPT1nJiZPZSh0KSYmKHE9Zy5zdGFydCx2PWcuZW5kLHZvaWQgMD09PXYmJih2PXEpLFwic2VsZWN0aW9uU3RhcnRcImluIHQ/KHQuc2VsZWN0aW9uU3RhcnQ9cSx0LnNlbGVjdGlvbkVuZD1NYXRoLm1pbih2LHQudmFsdWUubGVuZ3RoKSk6KHY9KHE9dC5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJnEuZGVmYXVsdFZpZXd8fHdpbmRvdyx2LmdldFNlbGVjdGlvbiYmKHY9di5nZXRTZWxlY3Rpb24oKSxoPXQudGV4dENvbnRlbnQubGVuZ3RoLEo9TWF0aC5taW4oZy5zdGFydCxoKSxnPXZvaWQgMD09PVxuZy5lbmQ/SjpNYXRoLm1pbihnLmVuZCxoKSwhdi5leHRlbmQmJko+ZyYmKGg9ZyxnPUosSj1oKSxoPUxlKHQsSiksZj1MZSh0LGcpLGgmJmYmJigxIT09di5yYW5nZUNvdW50fHx2LmFuY2hvck5vZGUhPT1oLm5vZGV8fHYuYW5jaG9yT2Zmc2V0IT09aC5vZmZzZXR8fHYuZm9jdXNOb2RlIT09Zi5ub2RlfHx2LmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpJiYocT1xLmNyZWF0ZVJhbmdlKCkscS5zZXRTdGFydChoLm5vZGUsaC5vZmZzZXQpLHYucmVtb3ZlQWxsUmFuZ2VzKCksSj5nPyh2LmFkZFJhbmdlKHEpLHYuZXh0ZW5kKGYubm9kZSxmLm9mZnNldCkpOihxLnNldEVuZChmLm5vZGUsZi5vZmZzZXQpLHYuYWRkUmFuZ2UocSkpKSkpKTtxPVtdO2Zvcih2PXQ7dj12LnBhcmVudE5vZGU7KTE9PT12Lm5vZGVUeXBlJiZxLnB1c2goe2VsZW1lbnQ6dixsZWZ0OnYuc2Nyb2xsTGVmdCx0b3A6di5zY3JvbGxUb3B9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdC5mb2N1cyYmdC5mb2N1cygpO2Zvcih0PVxuMDt0PHEubGVuZ3RoO3QrKyl2PXFbdF0sdi5lbGVtZW50LnNjcm9sbExlZnQ9di5sZWZ0LHYuZWxlbWVudC5zY3JvbGxUb3A9di50b3B9ZmQ9ISFrZjtsZj1rZj1udWxsO2EuY3VycmVudD1jO1o9ZDtkbyB0cnl7Zm9yKHQ9YTtudWxsIT09Wjspe3ZhciBLPVouZmxhZ3M7SyYzNiYmWWkodCxaLmFsdGVybmF0ZSxaKTtpZihLJjEyOCl7cT12b2lkIDA7dmFyIFE9Wi5yZWY7aWYobnVsbCE9PVEpe3ZhciBMPVouc3RhdGVOb2RlO3N3aXRjaChaLnRhZyl7Y2FzZSA1OnE9TDticmVhaztkZWZhdWx0OnE9TH1cImZ1bmN0aW9uXCI9PT10eXBlb2YgUT9RKHEpOlEuY3VycmVudD1xfX1aPVoubmV4dEVmZmVjdH19Y2F0Y2godmEpe2lmKG51bGw9PT1aKXRocm93IEVycm9yKHkoMzMwKSk7V2koWix2YSk7Wj1aLm5leHRFZmZlY3R9d2hpbGUobnVsbCE9PVopO1o9bnVsbDskZigpO1g9ZX1lbHNlIGEuY3VycmVudD1jO2lmKHhqKXhqPSExLHlqPWEsemo9YjtlbHNlIGZvcihaPWQ7bnVsbCE9PVo7KWI9XG5aLm5leHRFZmZlY3QsWi5uZXh0RWZmZWN0PW51bGwsWi5mbGFncyY4JiYoSz1aLEsuc2libGluZz1udWxsLEsuc3RhdGVOb2RlPW51bGwpLFo9YjtkPWEucGVuZGluZ0xhbmVzOzA9PT1kJiYoVGk9bnVsbCk7MT09PWQ/YT09PUVqP0RqKys6KERqPTAsRWo9YSk6RGo9MDtjPWMuc3RhdGVOb2RlO2lmKE1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgTWYub25Db21taXRGaWJlclJvb3QpdHJ5e01mLm9uQ29tbWl0RmliZXJSb290KExmLGMsdm9pZCAwLDY0PT09KGMuY3VycmVudC5mbGFncyY2NCkpfWNhdGNoKHZhKXt9TWooYSxPKCkpO2lmKFFpKXRocm93IFFpPSExLGE9UmksUmk9bnVsbCxhO2lmKDAhPT0oWCY4KSlyZXR1cm4gbnVsbDtpZygpO3JldHVybiBudWxsfVxuZnVuY3Rpb24gZWsoKXtmb3IoO251bGwhPT1aOyl7dmFyIGE9Wi5hbHRlcm5hdGU7Smp8fG51bGw9PT1Janx8KDAhPT0oWi5mbGFncyY4KT9kYyhaLElqKSYmKEpqPSEwKToxMz09PVoudGFnJiZtaihhLFopJiZkYyhaLElqKSYmKEpqPSEwKSk7dmFyIGI9Wi5mbGFnczswIT09KGImMjU2KSYmWGkoYSxaKTswPT09KGImNTEyKXx8eGp8fCh4aj0hMCxoZyg5NyxmdW5jdGlvbigpe09qKCk7cmV0dXJuIG51bGx9KSk7Wj1aLm5leHRFZmZlY3R9fWZ1bmN0aW9uIE9qKCl7aWYoOTAhPT16ail7dmFyIGE9OTc8emo/OTc6emo7emo9OTA7cmV0dXJuIGdnKGEsZmspfXJldHVybiExfWZ1bmN0aW9uICRpKGEsYil7QWoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfWZ1bmN0aW9uIFppKGEsYil7QmoucHVzaChiLGEpO3hqfHwoeGo9ITAsaGcoOTcsZnVuY3Rpb24oKXtPaigpO3JldHVybiBudWxsfSkpfVxuZnVuY3Rpb24gZmsoKXtpZihudWxsPT09eWopcmV0dXJuITE7dmFyIGE9eWo7eWo9bnVsbDtpZigwIT09KFgmNDgpKXRocm93IEVycm9yKHkoMzMxKSk7dmFyIGI9WDtYfD0zMjt2YXIgYz1CajtCaj1bXTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrPTIpe3ZhciBlPWNbZF0sZj1jW2QrMV0sZz1lLmRlc3Ryb3k7ZS5kZXN0cm95PXZvaWQgMDtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZyl0cnl7ZygpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Yz1BajtBaj1bXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCs9Mil7ZT1jW2RdO2Y9Y1tkKzFdO3RyeXt2YXIgaD1lLmNyZWF0ZTtlLmRlc3Ryb3k9aCgpfWNhdGNoKGspe2lmKG51bGw9PT1mKXRocm93IEVycm9yKHkoMzMwKSk7V2koZixrKX19Zm9yKGg9YS5jdXJyZW50LmZpcnN0RWZmZWN0O251bGwhPT1oOylhPWgubmV4dEVmZmVjdCxoLm5leHRFZmZlY3Q9bnVsbCxoLmZsYWdzJjgmJihoLnNpYmxpbmc9XG5udWxsLGguc3RhdGVOb2RlPW51bGwpLGg9YTtYPWI7aWcoKTtyZXR1cm4hMH1mdW5jdGlvbiBnayhhLGIsYyl7Yj1NaShjLGIpO2I9UGkoYSxiLDEpO0FnKGEsYik7Yj1IZygpO2E9S2ooYSwxKTtudWxsIT09YSYmKCRjKGEsMSxiKSxNaihhLGIpKX1cbmZ1bmN0aW9uIFdpKGEsYil7aWYoMz09PWEudGFnKWdrKGEsYSxiKTtlbHNlIGZvcih2YXIgYz1hLnJldHVybjtudWxsIT09Yzspe2lmKDM9PT1jLnRhZyl7Z2soYyxhLGIpO2JyZWFrfWVsc2UgaWYoMT09PWMudGFnKXt2YXIgZD1jLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09VGl8fCFUaS5oYXMoZCkpKXthPU1pKGIsYSk7dmFyIGU9U2koYyxhLDEpO0FnKGMsZSk7ZT1IZygpO2M9S2ooYywxKTtpZihudWxsIT09YykkYyhjLDEsZSksTWooYyxlKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PVRpfHwhVGkuaGFzKGQpKSl0cnl7ZC5jb21wb25lbnREaWRDYXRjaChiLGEpfWNhdGNoKGYpe31icmVha319Yz1jLnJldHVybn19XG5mdW5jdGlvbiBZaihhLGIsYyl7dmFyIGQ9YS5waW5nQ2FjaGU7bnVsbCE9PWQmJmQuZGVsZXRlKGIpO2I9SGcoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7VT09PWEmJihXJmMpPT09YyYmKDQ9PT1WfHwzPT09ViYmKFcmNjI5MTQ1NjApPT09VyYmNTAwPk8oKS1qaj9RaihhLDApOnVqfD1jKTtNaihhLGIpfWZ1bmN0aW9uIGxqKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbCE9PWMmJmMuZGVsZXRlKGIpO2I9MDswPT09YiYmKGI9YS5tb2RlLDA9PT0oYiYyKT9iPTE6MD09PShiJjQpP2I9OTk9PT1lZygpPzE6MjooMD09PUdqJiYoR2o9dGopLGI9WWMoNjI5MTQ1NjAmfkdqKSwwPT09YiYmKGI9NDE5NDMwNCkpKTtjPUhnKCk7YT1LaihhLGIpO251bGwhPT1hJiYoJGMoYSxiLGMpLE1qKGEsYykpfXZhciBjaztcbmNrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iLmxhbmVzO2lmKG51bGwhPT1hKWlmKGEubWVtb2l6ZWRQcm9wcyE9PWIucGVuZGluZ1Byb3BzfHxOLmN1cnJlbnQpdWc9ITA7ZWxzZSBpZigwIT09KGMmZCkpdWc9MCE9PShhLmZsYWdzJjE2Mzg0KT8hMDohMTtlbHNle3VnPSExO3N3aXRjaChiLnRhZyl7Y2FzZSAzOnJpKGIpO3NoKCk7YnJlYWs7Y2FzZSA1OmdoKGIpO2JyZWFrO2Nhc2UgMTpGZihiLnR5cGUpJiZKZihiKTticmVhaztjYXNlIDQ6ZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEwOmQ9Yi5tZW1vaXplZFByb3BzLnZhbHVlO3ZhciBlPWIudHlwZS5fY29udGV4dDtJKG1nLGUuX2N1cnJlbnRWYWx1ZSk7ZS5fY3VycmVudFZhbHVlPWQ7YnJlYWs7Y2FzZSAxMzppZihudWxsIT09Yi5tZW1vaXplZFN0YXRlKXtpZigwIT09KGMmYi5jaGlsZC5jaGlsZExhbmVzKSlyZXR1cm4gdGkoYSxiLGMpO0koUCxQLmN1cnJlbnQmMSk7Yj1oaShhLGIsYyk7cmV0dXJuIG51bGwhPT1cbmI/Yi5zaWJsaW5nOm51bGx9SShQLFAuY3VycmVudCYxKTticmVhaztjYXNlIDE5OmQ9MCE9PShjJmIuY2hpbGRMYW5lcyk7aWYoMCE9PShhLmZsYWdzJjY0KSl7aWYoZClyZXR1cm4gQWkoYSxiLGMpO2IuZmxhZ3N8PTY0fWU9Yi5tZW1vaXplZFN0YXRlO251bGwhPT1lJiYoZS5yZW5kZXJpbmc9bnVsbCxlLnRhaWw9bnVsbCxlLmxhc3RFZmZlY3Q9bnVsbCk7SShQLFAuY3VycmVudCk7aWYoZClicmVhaztlbHNlIHJldHVybiBudWxsO2Nhc2UgMjM6Y2FzZSAyNDpyZXR1cm4gYi5sYW5lcz0wLG1pKGEsYixjKX1yZXR1cm4gaGkoYSxiLGMpfWVsc2UgdWc9ITE7Yi5sYW5lcz0wO3N3aXRjaChiLnRhZyl7Y2FzZSAyOmQ9Yi50eXBlO251bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpO2E9Yi5wZW5kaW5nUHJvcHM7ZT1FZihiLE0uY3VycmVudCk7dGcoYixjKTtlPUNoKG51bGwsYixkLGEsZSxjKTtiLmZsYWdzfD0xO2lmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mKXtiLnRhZz0xO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtpZihGZihkKSl7dmFyIGY9ITA7SmYoYil9ZWxzZSBmPSExO2IubWVtb2l6ZWRTdGF0ZT1udWxsIT09ZS5zdGF0ZSYmdm9pZCAwIT09ZS5zdGF0ZT9lLnN0YXRlOm51bGw7eGcoYik7dmFyIGc9ZC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGcmJkdnKGIsZCxnLGEpO2UudXBkYXRlcj1LZztiLnN0YXRlTm9kZT1lO2UuX3JlYWN0SW50ZXJuYWxzPWI7T2coYixkLGEsYyk7Yj1xaShudWxsLGIsZCwhMCxmLGMpfWVsc2UgYi50YWc9MCxmaShudWxsLGIsZSxjKSxiPWIuY2hpbGQ7cmV0dXJuIGI7Y2FzZSAxNjplPWIuZWxlbWVudFR5cGU7YTp7bnVsbCE9PWEmJihhLmFsdGVybmF0ZT1udWxsLGIuYWx0ZXJuYXRlPW51bGwsYi5mbGFnc3w9Mik7XG5hPWIucGVuZGluZ1Byb3BzO2Y9ZS5faW5pdDtlPWYoZS5fcGF5bG9hZCk7Yi50eXBlPWU7Zj1iLnRhZz1oayhlKTthPWxnKGUsYSk7c3dpdGNoKGYpe2Nhc2UgMDpiPWxpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE6Yj1waShudWxsLGIsZSxhLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPWdpKG51bGwsYixlLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9aWkobnVsbCxiLGUsbGcoZS50eXBlLGEpLGQsYyk7YnJlYWsgYX10aHJvdyBFcnJvcih5KDMwNixlLFwiXCIpKTt9cmV0dXJuIGI7Y2FzZSAwOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGxpKGEsYixkLGUsYyk7Y2FzZSAxOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLHBpKGEsYixkLGUsYyk7Y2FzZSAzOnJpKGIpO2Q9Yi51cGRhdGVRdWV1ZTtpZihudWxsPT09YXx8bnVsbD09PWQpdGhyb3cgRXJyb3IoeSgyODIpKTtcbmQ9Yi5wZW5kaW5nUHJvcHM7ZT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09ZT9lLmVsZW1lbnQ6bnVsbDt5ZyhhLGIpO0NnKGIsZCxudWxsLGMpO2Q9Yi5tZW1vaXplZFN0YXRlLmVsZW1lbnQ7aWYoZD09PWUpc2goKSxiPWhpKGEsYixjKTtlbHNle2U9Yi5zdGF0ZU5vZGU7aWYoZj1lLmh5ZHJhdGUpa2g9cmYoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mby5maXJzdENoaWxkKSxqaD1iLGY9bGg9ITA7aWYoZil7YT1lLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7aWYobnVsbCE9YSlmb3IoZT0wO2U8YS5sZW5ndGg7ZSs9MilmPWFbZV0sZi5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1hW2UrMV0sdGgucHVzaChmKTtjPVpnKGIsbnVsbCxkLGMpO2ZvcihiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDEwMjQsYz1jLnNpYmxpbmd9ZWxzZSBmaShhLGIsZCxjKSxzaCgpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDU6cmV0dXJuIGdoKGIpLG51bGw9PT1hJiZcbnBoKGIpLGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxnPWUuY2hpbGRyZW4sbmYoZCxlKT9nPW51bGw6bnVsbCE9PWYmJm5mKGQsZikmJihiLmZsYWdzfD0xNiksb2koYSxiKSxmaShhLGIsZyxjKSxiLmNoaWxkO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJnBoKGIpLG51bGw7Y2FzZSAxMzpyZXR1cm4gdGkoYSxiLGMpO2Nhc2UgNDpyZXR1cm4gZWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9WWcoYixudWxsLGQsYyk6ZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpsZyhkLGUpLGdpKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBmaShhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGZpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbmMpLGIuY2hpbGQ7Y2FzZSAxMjpyZXR1cm4gZmkoYSxiLGIucGVuZGluZ1Byb3BzLmNoaWxkcmVuLGMpLGIuY2hpbGQ7Y2FzZSAxMDphOntkPWIudHlwZS5fY29udGV4dDtlPWIucGVuZGluZ1Byb3BzO2c9Yi5tZW1vaXplZFByb3BzO2Y9ZS52YWx1ZTt2YXIgaD1iLnR5cGUuX2NvbnRleHQ7SShtZyxoLl9jdXJyZW50VmFsdWUpO2guX2N1cnJlbnRWYWx1ZT1mO2lmKG51bGwhPT1nKWlmKGg9Zy52YWx1ZSxmPUhlKGgsZik/MDooXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzP2QuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzKGgsZik6MTA3Mzc0MTgyMyl8MCwwPT09Zil7aWYoZy5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiFOLmN1cnJlbnQpe2I9aGkoYSxiLGMpO2JyZWFrIGF9fWVsc2UgZm9yKGg9Yi5jaGlsZCxudWxsIT09aCYmKGgucmV0dXJuPWIpO251bGwhPT1oOyl7dmFyIGs9aC5kZXBlbmRlbmNpZXM7aWYobnVsbCE9PWspe2c9aC5jaGlsZDtmb3IodmFyIGw9XG5rLmZpcnN0Q29udGV4dDtudWxsIT09bDspe2lmKGwuY29udGV4dD09PWQmJjAhPT0obC5vYnNlcnZlZEJpdHMmZikpezE9PT1oLnRhZyYmKGw9emcoLTEsYyYtYyksbC50YWc9MixBZyhoLGwpKTtoLmxhbmVzfD1jO2w9aC5hbHRlcm5hdGU7bnVsbCE9PWwmJihsLmxhbmVzfD1jKTtzZyhoLnJldHVybixjKTtrLmxhbmVzfD1jO2JyZWFrfWw9bC5uZXh0fX1lbHNlIGc9MTA9PT1oLnRhZz9oLnR5cGU9PT1iLnR5cGU/bnVsbDpoLmNoaWxkOmguY2hpbGQ7aWYobnVsbCE9PWcpZy5yZXR1cm49aDtlbHNlIGZvcihnPWg7bnVsbCE9PWc7KXtpZihnPT09Yil7Zz1udWxsO2JyZWFrfWg9Zy5zaWJsaW5nO2lmKG51bGwhPT1oKXtoLnJldHVybj1nLnJldHVybjtnPWg7YnJlYWt9Zz1nLnJldHVybn1oPWd9ZmkoYSxiLGUuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZT1iLnR5cGUsZj1iLnBlbmRpbmdQcm9wcyxkPWYuY2hpbGRyZW4sdGcoYixjKSxlPXZnKGUsXG5mLnVuc3RhYmxlX29ic2VydmVkQml0cyksZD1kKGUpLGIuZmxhZ3N8PTEsZmkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDE0OnJldHVybiBlPWIudHlwZSxmPWxnKGUsYi5wZW5kaW5nUHJvcHMpLGY9bGcoZS50eXBlLGYpLGlpKGEsYixlLGYsZCxjKTtjYXNlIDE1OnJldHVybiBraShhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGQsYyk7Y2FzZSAxNzpyZXR1cm4gZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxlPWIuZWxlbWVudFR5cGU9PT1kP2U6bGcoZCxlKSxudWxsIT09YSYmKGEuYWx0ZXJuYXRlPW51bGwsYi5hbHRlcm5hdGU9bnVsbCxiLmZsYWdzfD0yKSxiLnRhZz0xLEZmKGQpPyhhPSEwLEpmKGIpKTphPSExLHRnKGIsYyksTWcoYixkLGUpLE9nKGIsZCxlLGMpLHFpKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4gQWkoYSxiLGMpO2Nhc2UgMjM6cmV0dXJuIG1pKGEsYixjKTtjYXNlIDI0OnJldHVybiBtaShhLGIsYyl9dGhyb3cgRXJyb3IoeSgxNTYsYi50YWcpKTtcbn07ZnVuY3Rpb24gaWsoYSxiLGMsZCl7dGhpcy50YWc9YTt0aGlzLmtleT1jO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXMucmV0dXJuPXRoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT10aGlzLmVsZW1lbnRUeXBlPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9Yjt0aGlzLmRlcGVuZGVuY2llcz10aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9bnVsbDt0aGlzLm1vZGU9ZDt0aGlzLmZsYWdzPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIG5oKGEsYixjLGQpe3JldHVybiBuZXcgaWsoYSxiLGMsZCl9ZnVuY3Rpb24gamkoYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIGhrKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBqaShhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09QWEpcmV0dXJuIDExO2lmKGE9PT1EYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBUZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPW5oKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMubmV4dEVmZmVjdD1udWxsLGMuZmlyc3RFZmZlY3Q9bnVsbCxjLmxhc3RFZmZlY3Q9bnVsbCk7Yy5jaGlsZExhbmVzPWEuY2hpbGRMYW5lcztjLmxhbmVzPWEubGFuZXM7Yy5jaGlsZD1hLmNoaWxkO2MubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7Yy5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtjLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7Yj1hLmRlcGVuZGVuY2llcztjLmRlcGVuZGVuY2llcz1udWxsPT09Yj9udWxsOntsYW5lczpiLmxhbmVzLGZpcnN0Q29udGV4dDpiLmZpcnN0Q29udGV4dH07XG5jLnNpYmxpbmc9YS5zaWJsaW5nO2MuaW5kZXg9YS5pbmRleDtjLnJlZj1hLnJlZjtyZXR1cm4gY31cbmZ1bmN0aW9uIFZnKGEsYixjLGQsZSxmKXt2YXIgZz0yO2Q9YTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSlqaShhKSYmKGc9MSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpZz01O2Vsc2UgYTpzd2l0Y2goYSl7Y2FzZSB1YTpyZXR1cm4gWGcoYy5jaGlsZHJlbixlLGYsYik7Y2FzZSBIYTpnPTg7ZXw9MTY7YnJlYWs7Y2FzZSB3YTpnPTg7ZXw9MTticmVhaztjYXNlIHhhOnJldHVybiBhPW5oKDEyLGMsYixlfDgpLGEuZWxlbWVudFR5cGU9eGEsYS50eXBlPXhhLGEubGFuZXM9ZixhO2Nhc2UgQmE6cmV0dXJuIGE9bmgoMTMsYyxiLGUpLGEudHlwZT1CYSxhLmVsZW1lbnRUeXBlPUJhLGEubGFuZXM9ZixhO2Nhc2UgQ2E6cmV0dXJuIGE9bmgoMTksYyxiLGUpLGEuZWxlbWVudFR5cGU9Q2EsYS5sYW5lcz1mLGE7Y2FzZSBJYTpyZXR1cm4gdmkoYyxlLGYsYik7Y2FzZSBKYTpyZXR1cm4gYT1uaCgyNCxjLGIsZSksYS5lbGVtZW50VHlwZT1KYSxhLmxhbmVzPWYsYTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT1cbnR5cGVvZiBhJiZudWxsIT09YSlzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSB5YTpnPTEwO2JyZWFrIGE7Y2FzZSB6YTpnPTk7YnJlYWsgYTtjYXNlIEFhOmc9MTE7YnJlYWsgYTtjYXNlIERhOmc9MTQ7YnJlYWsgYTtjYXNlIEVhOmc9MTY7ZD1udWxsO2JyZWFrIGE7Y2FzZSBGYTpnPTIyO2JyZWFrIGF9dGhyb3cgRXJyb3IoeSgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1uaChnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIFhnKGEsYixjLGQpe2E9bmgoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHZpKGEsYixjLGQpe2E9bmgoMjMsYSxkLGIpO2EuZWxlbWVudFR5cGU9SWE7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIFVnKGEsYixjKXthPW5oKDYsYSxudWxsLGIpO2EubGFuZXM9YztyZXR1cm4gYX1cbmZ1bmN0aW9uIFdnKGEsYixjKXtiPW5oKDQsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmxhbmVzPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gamsoYSxiLGMpe3RoaXMudGFnPWI7dGhpcy5jb250YWluZXJJbmZvPWE7dGhpcy5maW5pc2hlZFdvcms9dGhpcy5waW5nQ2FjaGU9dGhpcy5jdXJyZW50PXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5oeWRyYXRlPWM7dGhpcy5jYWxsYmFja05vZGU9bnVsbDt0aGlzLmNhbGxiYWNrUHJpb3JpdHk9MDt0aGlzLmV2ZW50VGltZXM9WmMoMCk7dGhpcy5leHBpcmF0aW9uVGltZXM9WmMoLTEpO3RoaXMuZW50YW5nbGVkTGFuZXM9dGhpcy5maW5pc2hlZExhbmVzPXRoaXMubXV0YWJsZVJlYWRMYW5lcz10aGlzLmV4cGlyZWRMYW5lcz10aGlzLnBpbmdlZExhbmVzPXRoaXMuc3VzcGVuZGVkTGFuZXM9dGhpcy5wZW5kaW5nTGFuZXM9MDt0aGlzLmVudGFuZ2xlbWVudHM9WmMoMCk7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPW51bGx9XG5mdW5jdGlvbiBrayhhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOnRhLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuZnVuY3Rpb24gbGsoYSxiLGMsZCl7dmFyIGU9Yi5jdXJyZW50LGY9SGcoKSxnPUlnKGUpO2E6aWYoYyl7Yz1jLl9yZWFjdEludGVybmFscztiOntpZihaYihjKSE9PWN8fDEhPT1jLnRhZyl0aHJvdyBFcnJvcih5KDE3MCkpO3ZhciBoPWM7ZG97c3dpdGNoKGgudGFnKXtjYXNlIDM6aD1oLnN0YXRlTm9kZS5jb250ZXh0O2JyZWFrIGI7Y2FzZSAxOmlmKEZmKGgudHlwZSkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn19aD1oLnJldHVybn13aGlsZShudWxsIT09aCk7dGhyb3cgRXJyb3IoeSgxNzEpKTt9aWYoMT09PWMudGFnKXt2YXIgaz1jLnR5cGU7aWYoRmYoaykpe2M9SWYoYyxrLGgpO2JyZWFrIGF9fWM9aH1lbHNlIGM9Q2Y7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj16ZyhmLGcpO2IucGF5bG9hZD17ZWxlbWVudDphfTtkPXZvaWQgMD09PWQ/bnVsbDpkO251bGwhPT1cbmQmJihiLmNhbGxiYWNrPWQpO0FnKGUsYik7SmcoZSxnLGYpO3JldHVybiBnfWZ1bmN0aW9uIG1rKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA1OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19ZnVuY3Rpb24gbmsoYSxiKXthPWEubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7dmFyIGM9YS5yZXRyeUxhbmU7YS5yZXRyeUxhbmU9MCE9PWMmJmM8Yj9jOmJ9fWZ1bmN0aW9uIG9rKGEsYil7bmsoYSxiKTsoYT1hLmFsdGVybmF0ZSkmJm5rKGEsYil9ZnVuY3Rpb24gcGsoKXtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHFrKGEsYixjKXt2YXIgZD1udWxsIT1jJiZudWxsIT1jLmh5ZHJhdGlvbk9wdGlvbnMmJmMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlc3x8bnVsbDtjPW5ldyBqayhhLGIsbnVsbCE9YyYmITA9PT1jLmh5ZHJhdGUpO2I9bmgoMyxudWxsLG51bGwsMj09PWI/NzoxPT09Yj8zOjApO2MuY3VycmVudD1iO2Iuc3RhdGVOb2RlPWM7eGcoYik7YVtmZl09Yy5jdXJyZW50O2NmKDg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspe2I9ZFthXTt2YXIgZT1iLl9nZXRWZXJzaW9uO2U9ZShiLl9zb3VyY2UpO251bGw9PWMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YT9jLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE9W2IsZV06Yy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2goYixlKX10aGlzLl9pbnRlcm5hbFJvb3Q9Y31cbnFrLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7bGsoYSx0aGlzLl9pbnRlcm5hbFJvb3QsbnVsbCxudWxsKX07cWsucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9pbnRlcm5hbFJvb3QsYj1hLmNvbnRhaW5lckluZm87bGsobnVsbCxhLG51bGwsZnVuY3Rpb24oKXtiW2ZmXT1udWxsfSl9O2Z1bmN0aW9uIHJrKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIHNrKGEsYil7Ynx8KGI9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbCxiPSEoIWJ8fDEhPT1iLm5vZGVUeXBlfHwhYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSkpO2lmKCFiKWZvcih2YXIgYztjPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGMpO3JldHVybiBuZXcgcWsoYSwwLGI/e2h5ZHJhdGU6ITB9OnZvaWQgMCl9XG5mdW5jdGlvbiB0ayhhLGIsYyxkLGUpe3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKXt2YXIgZz1mLl9pbnRlcm5hbFJvb3Q7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPW1rKGcpO2guY2FsbChhKX19bGsoYixnLGEsZSl9ZWxzZXtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1zayhjLGQpO2c9Zi5faW50ZXJuYWxSb290O2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgaz1lO2U9ZnVuY3Rpb24oKXt2YXIgYT1tayhnKTtrLmNhbGwoYSl9fVhqKGZ1bmN0aW9uKCl7bGsoYixnLGEsZSl9KX1yZXR1cm4gbWsoZyl9ZWM9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKTtKZyhhLDQsYik7b2soYSw0KX19O2ZjPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPUhnKCk7SmcoYSw2NzEwODg2NCxiKTtvayhhLDY3MTA4ODY0KX19O1xuZ2M9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9SGcoKSxjPUlnKGEpO0pnKGEsYyxiKTtvayhhLGMpfX07aGM9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYigpfTtcbnliPWZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6YWIoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPWMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9XCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPURiKGQpO2lmKCFlKXRocm93IEVycm9yKHkoOTApKTtXYShkKTthYihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJmZiKGEsISFjLm11bHRpcGxlLGIsITEpfX07R2I9V2o7XG5IYj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVg7WHw9NDt0cnl7cmV0dXJuIGdnKDk4LGEuYmluZChudWxsLGIsYyxkLGUpKX1maW5hbGx5e1g9ZiwwPT09WCYmKHdqKCksaWcoKSl9fTtJYj1mdW5jdGlvbigpezA9PT0oWCY0OSkmJihWaigpLE9qKCkpfTtKYj1mdW5jdGlvbihhLGIpe3ZhciBjPVg7WHw9Mjt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXtYPWMsMD09PVgmJih3aigpLGlnKCkpfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4ga2soYSxiLG51bGwsYyl9dmFyIHZrPXtFdmVudHM6W0NiLHVlLERiLEViLEZiLE9qLHtjdXJyZW50OiExfV19LHdrPXtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTp3YyxidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE3LjAuMVwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn07XG52YXIgeGs9e2J1bmRsZVR5cGU6d2suYnVuZGxlVHlwZSx2ZXJzaW9uOndrLnZlcnNpb24scmVuZGVyZXJQYWNrYWdlTmFtZTp3ay5yZW5kZXJlclBhY2thZ2VOYW1lLHJlbmRlcmVyQ29uZmlnOndrLnJlbmRlcmVyQ29uZmlnLG92ZXJyaWRlSG9va1N0YXRlOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wczpudWxsLG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOm51bGwsb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6bnVsbCxzZXRTdXNwZW5zZUhhbmRsZXI6bnVsbCxzY2hlZHVsZVVwZGF0ZTpudWxsLGN1cnJlbnREaXNwYXRjaGVyUmVmOnJhLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7YT1jYyhhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6d2suZmluZEZpYmVyQnlIb3N0SW5zdGFuY2V8fFxucGssZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOm51bGwsc2NoZWR1bGVSZWZyZXNoOm51bGwsc2NoZWR1bGVSb290Om51bGwsc2V0UmVmcmVzaEhhbmRsZXI6bnVsbCxnZXRDdXJyZW50RmliZXI6bnVsbH07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pe3ZhciB5az1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoIXlrLmlzRGlzYWJsZWQmJnlrLnN1cHBvcnRzRmliZXIpdHJ5e0xmPXlrLmluamVjdCh4ayksTWY9eWt9Y2F0Y2goYSl7fX1leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPXZrO2V4cG9ydHMuY3JlYXRlUG9ydGFsPXVrO1xuZXhwb3J0cy5maW5kRE9NTm9kZT1mdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxzO2lmKHZvaWQgMD09PWIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcil0aHJvdyBFcnJvcih5KDE4OCkpO3Rocm93IEVycm9yKHkoMjY4LE9iamVjdC5rZXlzKGEpKSk7fWE9Y2MoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtleHBvcnRzLmZsdXNoU3luYz1mdW5jdGlvbihhLGIpe3ZhciBjPVg7aWYoMCE9PShjJjQ4KSlyZXR1cm4gYShiKTtYfD0xO3RyeXtpZihhKXJldHVybiBnZyg5OSxhLmJpbmQobnVsbCxiKSl9ZmluYWxseXtYPWMsaWcoKX19O2V4cG9ydHMuaHlkcmF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIXJrKGIpKXRocm93IEVycm9yKHkoMjAwKSk7cmV0dXJuIHRrKG51bGwsYSxiLCEwLGMpfTtcbmV4cG9ydHMucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXtpZighcmsoYikpdGhyb3cgRXJyb3IoeSgyMDApKTtyZXR1cm4gdGsobnVsbCxhLGIsITEsYyl9O2V4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZT1mdW5jdGlvbihhKXtpZighcmsoYSkpdGhyb3cgRXJyb3IoeSg0MCkpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFhqKGZ1bmN0aW9uKCl7dGsobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbDthW2ZmXT1udWxsfSl9KSwhMCk6ITF9O2V4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM9V2o7ZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdWsoYSxiLDI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsKX07XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyPWZ1bmN0aW9uKGEsYixjLGQpe2lmKCFyayhjKSl0aHJvdyBFcnJvcih5KDIwMCkpO2lmKG51bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxzKXRocm93IEVycm9yKHkoMzgpKTtyZXR1cm4gdGsoYSxiLGMsITEsZCl9O2V4cG9ydHMudmVyc2lvbj1cIjE3LjAuMVwiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbD1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPTYwMTAzLHA9NjAxMDY7ZXhwb3J0cy5GcmFnbWVudD02MDEwNztleHBvcnRzLlN0cmljdE1vZGU9NjAxMDg7ZXhwb3J0cy5Qcm9maWxlcj02MDExNDt2YXIgcT02MDEwOSxyPTYwMTEwLHQ9NjAxMTI7ZXhwb3J0cy5TdXNwZW5zZT02MDExMzt2YXIgdT02MDExNSx2PTYwMTE2O1xuaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcil7dmFyIHc9U3ltYm9sLmZvcjtuPXcoXCJyZWFjdC5lbGVtZW50XCIpO3A9dyhcInJlYWN0LnBvcnRhbFwiKTtleHBvcnRzLkZyYWdtZW50PXcoXCJyZWFjdC5mcmFnbWVudFwiKTtleHBvcnRzLlN0cmljdE1vZGU9dyhcInJlYWN0LnN0cmljdF9tb2RlXCIpO2V4cG9ydHMuUHJvZmlsZXI9dyhcInJlYWN0LnByb2ZpbGVyXCIpO3E9dyhcInJlYWN0LnByb3ZpZGVyXCIpO3I9dyhcInJlYWN0LmNvbnRleHRcIik7dD13KFwicmVhY3QuZm9yd2FyZF9yZWZcIik7ZXhwb3J0cy5TdXNwZW5zZT13KFwicmVhY3Quc3VzcGVuc2VcIik7dT13KFwicmVhY3QubWVtb1wiKTt2PXcoXCJyZWFjdC5sYXp5XCIpfXZhciB4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH1mdW5jdGlvbiB6KGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifVxudmFyIEE9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEI9e307ZnVuY3Rpb24gQyhhLGIsYyl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1CO3RoaXMudXBkYXRlcj1jfHxBfUMucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307Qy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKHooODUpKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0MucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gRCgpe31ELnByb3RvdHlwZT1DLnByb3RvdHlwZTtmdW5jdGlvbiBFKGEsYixjKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUI7dGhpcy51cGRhdGVyPWN8fEF9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEQ7Ri5jb25zdHJ1Y3Rvcj1FO2woRixDLnByb3RvdHlwZSk7Ri5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsYyl7dmFyIGUsZD17fSxrPW51bGwsaD1udWxsO2lmKG51bGwhPWIpZm9yKGUgaW4gdm9pZCAwIT09Yi5yZWYmJihoPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGs9XCJcIitiLmtleSksYilILmNhbGwoYixlKSYmIUkuaGFzT3duUHJvcGVydHkoZSkmJihkW2VdPWJbZV0pO3ZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZylkLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGcpe2Zvcih2YXIgZj1BcnJheShnKSxtPTA7bTxnO20rKylmW21dPWFyZ3VtZW50c1ttKzJdO2QuY2hpbGRyZW49Zn1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZSBpbiBnPWEuZGVmYXVsdFByb3BzLGcpdm9pZCAwPT09ZFtlXSYmKGRbZV09Z1tlXSk7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19XG5mdW5jdGlvbiBLKGEsYil7cmV0dXJueyQkdHlwZW9mOm4sdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBMKGEpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJmEuJCR0eXBlb2Y9PT1ufWZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCI9XCI6XCI9MFwiLFwiOlwiOlwiPTJcIn07cmV0dXJuXCIkXCIrYS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTT0vXFwvKy9nO2Z1bmN0aW9uIE4oYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5mdW5jdGlvbiBPKGEsYixjLGUsZCl7dmFyIGs9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWt8fFwiYm9vbGVhblwiPT09aylhPW51bGw7dmFyIGg9ITE7aWYobnVsbD09PWEpaD0hMDtlbHNlIHN3aXRjaChrKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmg9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIG46Y2FzZSBwOmg9ITB9fWlmKGgpcmV0dXJuIGg9YSxkPWQoaCksYT1cIlwiPT09ZT9cIi5cIitOKGgsMCk6ZSxBcnJheS5pc0FycmF5KGQpPyhjPVwiXCIsbnVsbCE9YSYmKGM9YS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpLE8oZCxiLGMsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1kJiYoTChkKSYmKGQ9SyhkLGMrKCFkLmtleXx8aCYmaC5rZXk9PT1kLmtleT9cIlwiOihcIlwiK2Qua2V5KS5yZXBsYWNlKE0sXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goZCkpLDE7aD0wO2U9XCJcIj09PWU/XCIuXCI6ZStcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgZz1cbjA7ZzxhLmxlbmd0aDtnKyspe2s9YVtnXTt2YXIgZj1lK04oayxnKTtoKz1PKGssYixjLGYsZCl9ZWxzZSBpZihmPXkoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWUrTihrLGcrKyksaCs9TyhrLGIsYyxmLGQpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1cIlwiK2EsRXJyb3IoeigzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKSk7cmV0dXJuIGh9ZnVuY3Rpb24gUChhLGIsYyl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZT1bXSxkPTA7TyhhLGUsXCJcIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNhbGwoYyxhLGQrKyl9KTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFEoYSl7aWYoLTE9PT1hLl9zdGF0dXMpe3ZhciBiPWEuX3Jlc3VsdDtiPWIoKTthLl9zdGF0dXM9MDthLl9yZXN1bHQ9YjtiLnRoZW4oZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGI9Yi5kZWZhdWx0LGEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1iKX0sZnVuY3Rpb24oYil7MD09PWEuX3N0YXR1cyYmKGEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iKX0pfWlmKDE9PT1hLl9zdGF0dXMpcmV0dXJuIGEuX3Jlc3VsdDt0aHJvdyBhLl9yZXN1bHQ7fXZhciBSPXtjdXJyZW50Om51bGx9O2Z1bmN0aW9uIFMoKXt2YXIgYT1SLmN1cnJlbnQ7aWYobnVsbD09PWEpdGhyb3cgRXJyb3IoeigzMjEpKTtyZXR1cm4gYX12YXIgVD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjpSLFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOnt0cmFuc2l0aW9uOjB9LFJlYWN0Q3VycmVudE93bmVyOkcsSXNTb21lUmVuZGVyZXJBY3Rpbmc6e2N1cnJlbnQ6ITF9LGFzc2lnbjpsfTtcbmV4cG9ydHMuQ2hpbGRyZW49e21hcDpQLGZvckVhY2g6ZnVuY3Rpb24oYSxiLGMpe1AoYSxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjKX0sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtQKGEsZnVuY3Rpb24oKXtiKyt9KTtyZXR1cm4gYn0sdG9BcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gUChhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFMKGEpKXRocm93IEVycm9yKHooMTQzKSk7cmV0dXJuIGF9fTtleHBvcnRzLkNvbXBvbmVudD1DO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1FO2V4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VDtcbmV4cG9ydHMuY2xvbmVFbGVtZW50PWZ1bmN0aW9uKGEsYixjKXtpZihudWxsPT09YXx8dm9pZCAwPT09YSl0aHJvdyBFcnJvcih6KDI2NyxhKSk7dmFyIGU9bCh7fSxhLnByb3BzKSxkPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUguY2FsbChiLGYpJiYhSS5oYXNPd25Qcm9wZXJ0eShmKSYmKGVbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZillLmNoaWxkcmVuPWM7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7Zm9yKHZhciBtPTA7bTxmO20rKylnW21dPWFyZ3VtZW50c1ttKzJdO2UuY2hpbGRyZW49Z31yZXR1cm57JCR0eXBlb2Y6bix0eXBlOmEudHlwZSxcbmtleTpkLHJlZjprLHByb3BzOmUsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjpyLF9jYWxjdWxhdGVDaGFuZ2VkQml0czpiLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6cSxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtleHBvcnRzLmNyZWF0ZUVsZW1lbnQ9SjtleHBvcnRzLmNyZWF0ZUZhY3Rvcnk9ZnVuY3Rpb24oYSl7dmFyIGI9Si5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9O2V4cG9ydHMuY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19O2V4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dCxyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TDtcbmV4cG9ydHMubGF6eT1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixfcGF5bG9hZDp7X3N0YXR1czotMSxfcmVzdWx0OmF9LF9pbml0OlF9fTtleHBvcnRzLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm57JCR0eXBlb2Y6dSx0eXBlOmEsY29tcGFyZTp2b2lkIDA9PT1iP251bGw6Yn19O2V4cG9ydHMudXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUygpLnVzZUNhbGxiYWNrKGEsYil9O2V4cG9ydHMudXNlQ29udGV4dD1mdW5jdGlvbihhLGIpe3JldHVybiBTKCkudXNlQ29udGV4dChhLGIpfTtleHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUygpLnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGMpfTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VMYXlvdXRFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFMoKS51c2VNZW1vKGEsYil9O2V4cG9ydHMudXNlUmVkdWNlcj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFMoKS51c2VSZWR1Y2VyKGEsYixjKX07ZXhwb3J0cy51c2VSZWY9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VSZWYoYSl9O2V4cG9ydHMudXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFMoKS51c2VTdGF0ZShhKX07ZXhwb3J0cy52ZXJzaW9uPVwiMTcuMC4xXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MC4yMC4xXG4gKiBzY2hlZHVsZXItdHJhY2luZy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX1RIUkVBRF9JRCA9IDA7IC8vIENvdW50ZXJzIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy5cblxudmFyIGludGVyYWN0aW9uSURDb3VudGVyID0gMDtcbnZhciB0aHJlYWRJRENvdW50ZXIgPSAwOyAvLyBTZXQgb2YgY3VycmVudGx5IHRyYWNlZCBpbnRlcmFjdGlvbnMuXG4vLyBJbnRlcmFjdGlvbnMgXCJzdGFja1wi4oCTXG4vLyBNZWFuaW5nIHRoYXQgbmV3bHkgdHJhY2VkIGludGVyYWN0aW9ucyBhcmUgYXBwZW5kZWQgdG8gdGhlIHByZXZpb3VzbHkgYWN0aXZlIHNldC5cbi8vIFdoZW4gYW4gaW50ZXJhY3Rpb24gZ29lcyBvdXQgb2Ygc2NvcGUsIHRoZSBwcmV2aW91cyBzZXQgKGlmIGFueSkgaXMgcmVzdG9yZWQuXG5cbmV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSBudWxsOyAvLyBMaXN0ZW5lcihzKSB0byBub3RpZnkgd2hlbiBpbnRlcmFjdGlvbnMgYmVnaW4gYW5kIGVuZC5cblxuZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYgPSBudWxsO1xuXG57XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSB7XG4gICAgY3VycmVudDogbmV3IFNldCgpXG4gIH07XG4gIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2NsZWFyKGNhbGxiYWNrKSB7XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IG5ldyBTZXQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnQoKSB7XG4gIHtcbiAgICByZXR1cm4gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRUaHJlYWRJRCgpIHtcbiAgcmV0dXJuICsrdGhyZWFkSURDb3VudGVyO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfdHJhY2UobmFtZSwgdGltZXN0YW1wLCBjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICBfX2NvdW50OiAxLFxuICAgIGlkOiBpbnRlcmFjdGlvbklEQ291bnRlcisrLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgfTtcbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7IC8vIFRyYWNlZCBpbnRlcmFjdGlvbnMgc2hvdWxkIHN0YWNrL2FjY3VtdWxhdGUuXG4gIC8vIFRvIGRvIHRoYXQsIGNsb25lIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVGhlIHByZXZpb3VzIHNldCB3aWxsIGJlIHJlc3RvcmVkIHVwb24gY29tcGxldGlvbi5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldChwcmV2SW50ZXJhY3Rpb25zKTtcbiAgaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IGludGVyYWN0aW9ucztcbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTsgLy8gSWYgbm8gYXN5bmMgd29yayB3YXMgc2NoZWR1bGVkIGZvciB0aGlzIGludGVyYWN0aW9uLFxuICAgICAgICAgIC8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IGl0J3MgY29tcGxldGVkLlxuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcChjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIHZhciB3cmFwcGVkSW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB2YXIgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gIH0gLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVXBkYXRlIGFmdGVyIGNhbGxpbmcgc3Vic2NyaWJlcnMgaW4gY2FzZSBvZiBlcnJvci5cblxuXG4gIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gIH0pO1xuICB2YXIgaGFzUnVuID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd3JhcHBlZCgpIHtcbiAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSB3cmFwcGVkSW50ZXJhY3Rpb25zO1xuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWhhc1J1bikge1xuICAgICAgICAvLyBXZSBvbmx5IGV4cGVjdCBhIHdyYXBwZWQgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSxcbiAgICAgICAgLy8gQnV0IGluIHRoZSBldmVudCB0aGF0IGl0J3MgZXhlY3V0ZWQgbW9yZSB0aGFuIG9uY2XigJNcbiAgICAgICAgLy8gT25seSBkZWNyZW1lbnQgdGhlIG91dHN0YW5kaW5nIGludGVyYWN0aW9uIGNvdW50cyBvbmNlLlxuICAgICAgICBoYXNSdW4gPSB0cnVlOyAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuXG4gICAgICAgIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWQuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgIC8vIE1hcmsgdGhlbSBhcyBjb21wbGV0ZWQuXG4gICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICBpZiAoc3Vic2NyaWJlciAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gd3JhcHBlZDtcbn1cblxudmFyIHN1YnNjcmliZXJzID0gbnVsbDtcblxue1xuICBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAge1xuICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblxuICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG4gICAgICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0ge1xuICAgICAgICBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZDogb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQsXG4gICAgICAgIG9uSW50ZXJhY3Rpb25UcmFjZWQ6IG9uSW50ZXJhY3Rpb25UcmFjZWQsXG4gICAgICAgIG9uV29ya0NhbmNlbGVkOiBvbldvcmtDYW5jZWxlZCxcbiAgICAgICAgb25Xb3JrU2NoZWR1bGVkOiBvbldvcmtTY2hlZHVsZWQsXG4gICAgICAgIG9uV29ya1N0YXJ0ZWQ6IG9uV29ya1N0YXJ0ZWQsXG4gICAgICAgIG9uV29ya1N0b3BwZWQ6IG9uV29ya1N0b3BwZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV91bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIHtcbiAgICBzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmV4cG9ydHMudW5zdGFibGVfY2xlYXIgPSB1bnN0YWJsZV9jbGVhcjtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudCA9IHVuc3RhYmxlX2dldEN1cnJlbnQ7XG5leHBvcnRzLnVuc3RhYmxlX2dldFRocmVhZElEID0gdW5zdGFibGVfZ2V0VGhyZWFkSUQ7XG5leHBvcnRzLnVuc3RhYmxlX3N1YnNjcmliZSA9IHVuc3RhYmxlX3N1YnNjcmliZTtcbmV4cG9ydHMudW5zdGFibGVfdHJhY2UgPSB1bnN0YWJsZV90cmFjZTtcbmV4cG9ydHMudW5zdGFibGVfdW5zdWJzY3JpYmUgPSB1bnN0YWJsZV91bnN1YnNjcmliZTtcbmV4cG9ydHMudW5zdGFibGVfd3JhcCA9IHVuc3RhYmxlX3dyYXA7XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMVxuICogc2NoZWR1bGVyLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO3ZhciBiPTA7ZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZj1udWxsO2V4cG9ydHMuX19zdWJzY3JpYmVyUmVmPW51bGw7ZXhwb3J0cy51bnN0YWJsZV9jbGVhcj1mdW5jdGlvbihhKXtyZXR1cm4gYSgpfTtleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07ZXhwb3J0cy51bnN0YWJsZV9nZXRUaHJlYWRJRD1mdW5jdGlvbigpe3JldHVybisrYn07ZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudW5zdGFibGVfdHJhY2U9ZnVuY3Rpb24oYSxkLGMpe3JldHVybiBjKCl9O2V4cG9ydHMudW5zdGFibGVfdW5zdWJzY3JpYmU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudW5zdGFibGVfd3JhcD1mdW5jdGlvbihhKXtyZXR1cm4gYX07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMVxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IHRydWU7XG5cbnZhciByZXF1ZXN0SG9zdENhbGxiYWNrO1xudmFyIHJlcXVlc3RIb3N0VGltZW91dDtcbnZhciBjYW5jZWxIb3N0VGltZW91dDtcbnZhciByZXF1ZXN0UGFpbnQ7XG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59XG5cbmlmICggLy8gSWYgU2NoZWR1bGVyIHJ1bnMgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBpdCBmYWxscyBiYWNrIHRvIGEgbmFpdmVcbi8vIGltcGxlbWVudGF0aW9uIHVzaW5nIHNldFRpbWVvdXQuXG50eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAvLyBDaGVjayBpZiBNZXNzYWdlQ2hhbm5lbCBpcyBzdXBwb3J0ZWQsIHRvby5cbnR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBJZiB0aGlzIGFjY2lkZW50YWxseSBnZXRzIGltcG9ydGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGUuZy4gSmF2YVNjcmlwdENvcmUsXG4gIC8vIGZhbGxiYWNrIHRvIGEgbmFpdmUgaW1wbGVtZW50YXRpb24uXG4gIHZhciBfY2FsbGJhY2sgPSBudWxsO1xuICB2YXIgX3RpbWVvdXRJRCA9IG51bGw7XG5cbiAgdmFyIF9mbHVzaENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHZhciBoYXNSZW1haW5pbmdUaW1lID0gdHJ1ZTtcblxuICAgICAgICBfY2FsbGJhY2soaGFzUmVtYWluaW5nVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIF9jYWxsYmFjayA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDApO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHJlLWVudHJhbmN5LlxuICAgICAgc2V0VGltZW91dChyZXF1ZXN0SG9zdENhbGxiYWNrLCAwLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9jYWxsYmFjayA9IGNiO1xuICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCk7XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0VGltZW91dCA9IGZ1bmN0aW9uIChjYiwgbXMpIHtcbiAgICBfdGltZW91dElEID0gc2V0VGltZW91dChjYiwgbXMpO1xuICB9O1xuXG4gIGNhbmNlbEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dChfdGltZW91dElEKTtcbiAgfTtcblxuICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXF1ZXN0UGFpbnQgPSBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKCkge307XG59IGVsc2Uge1xuICAvLyBDYXB0dXJlIGxvY2FsIHJlZmVyZW5jZXMgdG8gbmF0aXZlIEFQSXMsIGluIGNhc2UgYSBwb2x5ZmlsbCBvdmVycmlkZXMgdGhlbS5cbiAgdmFyIF9zZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBfY2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dDtcblxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETzogU2NoZWR1bGVyIG5vIGxvbmdlciByZXF1aXJlcyB0aGVzZSBtZXRob2RzIHRvIGJlIHBvbHlmaWxsZWQuIEJ1dFxuICAgIC8vIG1heWJlIHdlIHdhbnQgdG8gY29udGludWUgd2FybmluZyBpZiB0aGV5IGRvbid0IGV4aXN0LCB0byBwcmVzZXJ2ZSB0aGVcbiAgICAvLyBvcHRpb24gdG8gcmVseSBvbiBpdCBpbiB0aGUgZnV0dXJlP1xuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIHZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWydlcnJvciddKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICB2YXIgdGFza1RpbWVvdXRJRCA9IC0xOyAvLyBTY2hlZHVsZXIgcGVyaW9kaWNhbGx5IHlpZWxkcyBpbiBjYXNlIHRoZXJlIGlzIG90aGVyIHdvcmsgb24gdGhlIG1haW5cbiAgLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuICAvLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuICAvLyBuZWVkIHRvIGJlIGZyYW1lIGFsaWduZWQ7IGZvciB0aG9zZSB0aGF0IGRvLCB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXG4gIHZhciB5aWVsZEludGVydmFsID0gNTtcbiAgdmFyIGRlYWRsaW5lID0gMDsgLy8gVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuXG4gIHtcbiAgICAvLyBgaXNJbnB1dFBlbmRpbmdgIGlzIG5vdCBhdmFpbGFibGUuIFNpbmNlIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWZcbiAgICAvLyB0aGVyZSdzIHBlbmRpbmcgaW5wdXQsIGFsd2F5cyB5aWVsZCBhdCB0aGUgZW5kIG9mIHRoZSBmcmFtZS5cbiAgICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCkgPj0gZGVhZGxpbmU7XG4gICAgfTsgLy8gU2luY2Ugd2UgeWllbGQgZXZlcnkgZnJhbWUgcmVnYXJkbGVzcywgYHJlcXVlc3RQYWludGAgaGFzIG5vIGVmZmVjdC5cblxuXG4gICAgcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge307XG4gIH1cblxuICBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAgIGlmIChmcHMgPCAwIHx8IGZwcyA+IDEyNSkge1xuICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmcHMgPiAwKSB7XG4gICAgICB5aWVsZEludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgICAgeWllbGRJbnRlcnZhbCA9IDU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gWWllbGQgYWZ0ZXIgYHlpZWxkSW50ZXJ2YWxgIG1zLCByZWdhcmRsZXNzIG9mIHdoZXJlIHdlIGFyZSBpbiB0aGUgdnN5bmNcbiAgICAgIC8vIGN5Y2xlLiBUaGlzIG1lYW5zIHRoZXJlJ3MgYWx3YXlzIHRpbWUgcmVtYWluaW5nIGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGV2ZW50LlxuXG4gICAgICBkZWFkbGluZSA9IGN1cnJlbnRUaW1lICsgeWllbGRJbnRlcnZhbDtcbiAgICAgIHZhciBoYXNUaW1lUmVtYWluaW5nID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGhhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKGhhc1RpbWVSZW1haW5pbmcsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoIWhhc01vcmVXb3JrKSB7XG4gICAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxuICB9O1xuXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBtcykge1xuICAgIHRhc2tUaW1lb3V0SUQgPSBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgICB9LCBtcyk7XG4gIH07XG5cbiAgY2FuY2VsSG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2NsZWFyVGltZW91dCh0YXNrVGltZW91dElEKTtcblxuICAgIHRhc2tUaW1lb3V0SUQgPSAtMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgdmFyIGZpcnN0ID0gaGVhcFswXTtcbiAgcmV0dXJuIGZpcnN0ID09PSB1bmRlZmluZWQgPyBudWxsIDogZmlyc3Q7XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuXG4gIGlmIChmaXJzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGxhc3QgPSBoZWFwLnBvcCgpO1xuXG4gICAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJzdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGxlZnRJbmRleCA9IChpbmRleCArIDEpICogMiAtIDE7XG4gICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgIHZhciByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07IC8vIElmIHRoZSBsZWZ0IG9yIHJpZ2h0IG5vZGUgaXMgc21hbGxlciwgc3dhcCB3aXRoIHRoZSBzbWFsbGVyIG9mIHRob3NlLlxuXG4gICAgaWYgKGxlZnQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKGxlZnQsIG5vZGUpIDwgMCkge1xuICAgICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFwW2luZGV4XSA9IGxlZnQ7XG4gICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBjaGlsZCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG59XG5cbi8vIFRPRE86IFVzZSBzeW1ib2xzP1xudmFyIE5vUHJpb3JpdHkgPSAwO1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xudmFyIExvd1ByaW9yaXR5ID0gNDtcbnZhciBJZGxlUHJpb3JpdHkgPSA1O1xuXG52YXIgcnVuSWRDb3VudGVyID0gMDtcbnZhciBtYWluVGhyZWFkSWRDb3VudGVyID0gMDtcbnZhciBwcm9maWxpbmdTdGF0ZVNpemUgPSA0O1xudmFyIHNoYXJlZFByb2ZpbGluZ0J1ZmZlciA9ICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IFNoYXJlZEFycmF5QnVmZmVyXG50eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgU2hhcmVkQXJyYXlCdWZmZXIocHJvZmlsaW5nU3RhdGVTaXplICogSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkgOiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IEFycmF5QnVmZmVyXG50eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgQXJyYXlCdWZmZXIocHJvZmlsaW5nU3RhdGVTaXplICogSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkgOiBudWxsIC8vIERvbid0IGNyYXNoIHRoZSBpbml0IHBhdGggb24gSUU5XG47XG52YXIgcHJvZmlsaW5nU3RhdGUgPSAgc2hhcmVkUHJvZmlsaW5nQnVmZmVyICE9PSBudWxsID8gbmV3IEludDMyQXJyYXkoc2hhcmVkUHJvZmlsaW5nQnVmZmVyKSA6IFtdOyAvLyBXZSBjYW4ndCByZWFkIHRoaXMgYnV0IGl0IGhlbHBzIHNhdmUgYnl0ZXMgZm9yIG51bGwgY2hlY2tzXG5cbnZhciBQUklPUklUWSA9IDA7XG52YXIgQ1VSUkVOVF9UQVNLX0lEID0gMTtcbnZhciBDVVJSRU5UX1JVTl9JRCA9IDI7XG52YXIgUVVFVUVfU0laRSA9IDM7XG5cbntcbiAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTsgLy8gVGhpcyBpcyBtYWludGFpbmVkIHdpdGggYSBjb3VudGVyLCBiZWNhdXNlIHRoZSBzaXplIG9mIHRoZSBwcmlvcml0eSBxdWV1ZVxuICAvLyBhcnJheSBtaWdodCBpbmNsdWRlIGNhbmNlbGVkIHRhc2tzLlxuXG4gIHByb2ZpbGluZ1N0YXRlW1FVRVVFX1NJWkVdID0gMDtcbiAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IDA7XG59IC8vIEJ5dGVzIHBlciBlbGVtZW50IGlzIDRcblxuXG52YXIgSU5JVElBTF9FVkVOVF9MT0dfU0laRSA9IDEzMTA3MjtcbnZhciBNQVhfRVZFTlRfTE9HX1NJWkUgPSA1MjQyODg7IC8vIEVxdWl2YWxlbnQgdG8gMiBtZWdhYnl0ZXNcblxudmFyIGV2ZW50TG9nU2l6ZSA9IDA7XG52YXIgZXZlbnRMb2dCdWZmZXIgPSBudWxsO1xudmFyIGV2ZW50TG9nID0gbnVsbDtcbnZhciBldmVudExvZ0luZGV4ID0gMDtcbnZhciBUYXNrU3RhcnRFdmVudCA9IDE7XG52YXIgVGFza0NvbXBsZXRlRXZlbnQgPSAyO1xudmFyIFRhc2tFcnJvckV2ZW50ID0gMztcbnZhciBUYXNrQ2FuY2VsRXZlbnQgPSA0O1xudmFyIFRhc2tSdW5FdmVudCA9IDU7XG52YXIgVGFza1lpZWxkRXZlbnQgPSA2O1xudmFyIFNjaGVkdWxlclN1c3BlbmRFdmVudCA9IDc7XG52YXIgU2NoZWR1bGVyUmVzdW1lRXZlbnQgPSA4O1xuXG5mdW5jdGlvbiBsb2dFdmVudChlbnRyaWVzKSB7XG4gIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgIHZhciBvZmZzZXQgPSBldmVudExvZ0luZGV4O1xuICAgIGV2ZW50TG9nSW5kZXggKz0gZW50cmllcy5sZW5ndGg7XG5cbiAgICBpZiAoZXZlbnRMb2dJbmRleCArIDEgPiBldmVudExvZ1NpemUpIHtcbiAgICAgIGV2ZW50TG9nU2l6ZSAqPSAyO1xuXG4gICAgICBpZiAoZXZlbnRMb2dTaXplID4gTUFYX0VWRU5UX0xPR19TSVpFKSB7XG4gICAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgICBjb25zb2xlWydlcnJvciddKFwiU2NoZWR1bGVyIFByb2ZpbGluZzogRXZlbnQgbG9nIGV4Y2VlZGVkIG1heGltdW0gc2l6ZS4gRG9uJ3QgXCIgKyAnZm9yZ2V0IHRvIGNhbGwgYHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzKClgLicpO1xuICAgICAgICBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdFdmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nU2l6ZSAqIDQpO1xuICAgICAgbmV3RXZlbnRMb2cuc2V0KGV2ZW50TG9nKTtcbiAgICAgIGV2ZW50TG9nQnVmZmVyID0gbmV3RXZlbnRMb2cuYnVmZmVyO1xuICAgICAgZXZlbnRMb2cgPSBuZXdFdmVudExvZztcbiAgICB9XG5cbiAgICBldmVudExvZy5zZXQoZW50cmllcywgb2Zmc2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHMoKSB7XG4gIGV2ZW50TG9nU2l6ZSA9IElOSVRJQUxfRVZFTlRfTE9HX1NJWkU7XG4gIGV2ZW50TG9nQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGV2ZW50TG9nU2l6ZSAqIDQpO1xuICBldmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nQnVmZmVyKTtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG59XG5mdW5jdGlvbiBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpIHtcbiAgdmFyIGJ1ZmZlciA9IGV2ZW50TG9nQnVmZmVyO1xuICBldmVudExvZ1NpemUgPSAwO1xuICBldmVudExvZ0J1ZmZlciA9IG51bGw7XG4gIGV2ZW50TG9nID0gbnVsbDtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBtYXJrVGFza1N0YXJ0KHRhc2ssIG1zKSB7XG4gIHtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXSsrO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICAvLyBwZXJmb3JtYW5jZS5ub3cgcmV0dXJucyBhIGZsb2F0LCByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzLiBXaGVuIHRoZVxuICAgICAgLy8gZXZlbnQgaXMgbG9nZ2VkLCBpdCdzIGNvZXJjZWQgdG8gYW4gaW50LiBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcyB0b1xuICAgICAgLy8gbWFpbnRhaW4gZXh0cmEgZGVncmVlcyBvZiBwcmVjaXNpb24uXG4gICAgICBsb2dFdmVudChbVGFza1N0YXJ0RXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgdGFzay5wcmlvcml0eUxldmVsXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0NvbXBsZXRlZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXS0tO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza0NvbXBsZXRlRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZF0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tDYW5jZWxlZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tDYW5jZWxFdmVudCwgbXMgKiAxMDAwLCB0YXNrLmlkXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0Vycm9yZWQodGFzaywgbXMpIHtcbiAge1xuICAgIHByb2ZpbGluZ1N0YXRlW1BSSU9SSVRZXSA9IE5vUHJpb3JpdHk7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IDA7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tFcnJvckV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWRdKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtUYXNrUnVuKHRhc2ssIG1zKSB7XG4gIHtcbiAgICBydW5JZENvdW50ZXIrKztcbiAgICBwcm9maWxpbmdTdGF0ZVtQUklPUklUWV0gPSB0YXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IHRhc2suaWQ7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9SVU5fSURdID0gcnVuSWRDb3VudGVyO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1J1bkV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWQsIHJ1bklkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tZaWVsZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1JVTl9JRF0gPSAwO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1lpZWxkRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgcnVuSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU2NoZWR1bGVyU3VzcGVuZGVkKG1zKSB7XG4gIHtcbiAgICBtYWluVGhyZWFkSWRDb3VudGVyKys7XG5cbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJTdXNwZW5kRXZlbnQsIG1zICogMTAwMCwgbWFpblRocmVhZElkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKG1zKSB7XG4gIHtcbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJSZXN1bWVFdmVudCwgbXMgKiAxMDAwLCBtYWluVGhyZWFkSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwOyAvLyBOZXZlciB0aW1lcyBvdXRcblxudmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmN5LlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuXG4gICAgICB7XG4gICAgICAgIG1hcmtUYXNrU3RhcnQodGltZXIsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGltZXIuaXNRdWV1ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB7XG4gICAgbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKGluaXRpYWxUaW1lKTtcbiAgfSAvLyBXZSdsbCBuZWVkIGEgaG9zdCBjYWxsYmFjayB0aGUgbmV4dCB0aW1lIHdvcmsgaXMgc2NoZWR1bGVkLlxuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgdmFyIF9jdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIG1hcmtTY2hlZHVsZXJTdXNwZW5kZWQoX2N1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcblxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIShlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgKSkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmICghaGFzVGltZVJlbWFpbmluZyB8fCBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG4gICAgICBtYXJrVGFza1J1bihjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgbWFya1Rhc2tZaWVsZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtUYXNrQ29tcGxldGVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRhc2suaXNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICB7XG4gICAgbmV3VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuXG4gICAge1xuICAgICAgbWFya1Rhc2tTdGFydChuZXdUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICBuZXdUYXNrLmlzUXVldWVkID0gdHJ1ZTtcbiAgICB9IC8vIFNjaGVkdWxlIGEgaG9zdCBjYWxsYmFjaywgaWYgbmVlZGVkLiBJZiB3ZSdyZSBhbHJlYWR5IHBlcmZvcm1pbmcgd29yayxcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIHtcbiAgICBpZiAodGFzay5pc1F1ZXVlZCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIG1hcmtUYXNrQ2FuY2VsZWQodGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgdGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSAvLyBOdWxsIG91dCB0aGUgY2FsbGJhY2sgdG8gaW5kaWNhdGUgdGhlIHRhc2sgaGFzIGJlZW4gY2FuY2VsZWQuIChDYW4ndFxuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbnZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSAge1xuICBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHM6IHN0YXJ0TG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cyxcbiAgc3RvcExvZ2dpbmdQcm9maWxpbmdFdmVudHM6IHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzLFxuICBzaGFyZWRQcm9maWxpbmdCdWZmZXI6IHNoYXJlZFByb2ZpbGluZ0J1ZmZlclxufSA7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMVxuICogc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgZixnLGgsaztpZihcIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93KXt2YXIgbD1wZXJmb3JtYW5jZTtleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiBsLm5vdygpfX1lbHNle3ZhciBwPURhdGUscT1wLm5vdygpO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHAubm93KCktcX19XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvd3x8XCJmdW5jdGlvblwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsKXt2YXIgdD1udWxsLHU9bnVsbCx3PWZ1bmN0aW9uKCl7aWYobnVsbCE9PXQpdHJ5e3ZhciBhPWV4cG9ydHMudW5zdGFibGVfbm93KCk7dCghMCxhKTt0PW51bGx9Y2F0Y2goYil7dGhyb3cgc2V0VGltZW91dCh3LDApLGI7fX07Zj1mdW5jdGlvbihhKXtudWxsIT09dD9zZXRUaW1lb3V0KGYsMCxhKToodD1hLHNldFRpbWVvdXQodywwKSl9O2c9ZnVuY3Rpb24oYSxiKXt1PXNldFRpbWVvdXQoYSxiKX07aD1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KX07ZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZD1mdW5jdGlvbigpe3JldHVybiExfTtrPWV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGU9ZnVuY3Rpb24oKXt9fWVsc2V7dmFyIHg9d2luZG93LnNldFRpbWVvdXQseT13aW5kb3cuY2xlYXJUaW1lb3V0O2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSl7dmFyIHo9XG53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJmNvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxsc1wiKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgeiYmY29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHNcIil9dmFyIEE9ITEsQj1udWxsLEM9LTEsRD01LEU9MDtleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPWZ1bmN0aW9uKCl7cmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCk+PVxuRX07az1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZT1mdW5jdGlvbihhKXswPmF8fDEyNTxhP2NvbnNvbGUuZXJyb3IoXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIik6RD0wPGE/TWF0aC5mbG9vcigxRTMvYSk6NX07dmFyIEY9bmV3IE1lc3NhZ2VDaGFubmVsLEc9Ri5wb3J0MjtGLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKG51bGwhPT1CKXt2YXIgYT1leHBvcnRzLnVuc3RhYmxlX25vdygpO0U9YStEO3RyeXtCKCEwLGEpP0cucG9zdE1lc3NhZ2UobnVsbCk6KEE9ITEsQj1udWxsKX1jYXRjaChiKXt0aHJvdyBHLnBvc3RNZXNzYWdlKG51bGwpLGI7fX1lbHNlIEE9ITF9O2Y9ZnVuY3Rpb24oYSl7Qj1hO0F8fChBPSEwLEcucG9zdE1lc3NhZ2UobnVsbCkpfTtnPWZ1bmN0aW9uKGEsYil7Qz1cbngoZnVuY3Rpb24oKXthKGV4cG9ydHMudW5zdGFibGVfbm93KCkpfSxiKX07aD1mdW5jdGlvbigpe3koQyk7Qz0tMX19ZnVuY3Rpb24gSChhLGIpe3ZhciBjPWEubGVuZ3RoO2EucHVzaChiKTthOmZvcig7Oyl7dmFyIGQ9Yy0xPj4+MSxlPWFbZF07aWYodm9pZCAwIT09ZSYmMDxJKGUsYikpYVtkXT1iLGFbY109ZSxjPWQ7ZWxzZSBicmVhayBhfX1mdW5jdGlvbiBKKGEpe2E9YVswXTtyZXR1cm4gdm9pZCAwPT09YT9udWxsOmF9XG5mdW5jdGlvbiBLKGEpe3ZhciBiPWFbMF07aWYodm9pZCAwIT09Yil7dmFyIGM9YS5wb3AoKTtpZihjIT09Yil7YVswXT1jO2E6Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtkPGU7KXt2YXIgbT0yKihkKzEpLTEsbj1hW21dLHY9bSsxLHI9YVt2XTtpZih2b2lkIDAhPT1uJiYwPkkobixjKSl2b2lkIDAhPT1yJiYwPkkocixuKT8oYVtkXT1yLGFbdl09YyxkPXYpOihhW2RdPW4sYVttXT1jLGQ9bSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYwPkkocixjKSlhW2RdPXIsYVt2XT1jLGQ9djtlbHNlIGJyZWFrIGF9fXJldHVybiBifXJldHVybiBudWxsfWZ1bmN0aW9uIEkoYSxiKXt2YXIgYz1hLnNvcnRJbmRleC1iLnNvcnRJbmRleDtyZXR1cm4gMCE9PWM/YzphLmlkLWIuaWR9dmFyIEw9W10sTT1bXSxOPTEsTz1udWxsLFA9MyxRPSExLFI9ITEsUz0hMTtcbmZ1bmN0aW9uIFQoYSl7Zm9yKHZhciBiPUooTSk7bnVsbCE9PWI7KXtpZihudWxsPT09Yi5jYWxsYmFjaylLKE0pO2Vsc2UgaWYoYi5zdGFydFRpbWU8PWEpSyhNKSxiLnNvcnRJbmRleD1iLmV4cGlyYXRpb25UaW1lLEgoTCxiKTtlbHNlIGJyZWFrO2I9SihNKX19ZnVuY3Rpb24gVShhKXtTPSExO1QoYSk7aWYoIVIpaWYobnVsbCE9PUooTCkpUj0hMCxmKFYpO2Vsc2V7dmFyIGI9SihNKTtudWxsIT09YiYmZyhVLGIuc3RhcnRUaW1lLWEpfX1cbmZ1bmN0aW9uIFYoYSxiKXtSPSExO1MmJihTPSExLGgoKSk7UT0hMDt2YXIgYz1QO3RyeXtUKGIpO2ZvcihPPUooTCk7bnVsbCE9PU8mJighKE8uZXhwaXJhdGlvblRpbWU+Yil8fGEmJiFleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpOyl7dmFyIGQ9Ty5jYWxsYmFjaztpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7Ty5jYWxsYmFjaz1udWxsO1A9Ty5wcmlvcml0eUxldmVsO3ZhciBlPWQoTy5leHBpcmF0aW9uVGltZTw9Yik7Yj1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlP08uY2FsbGJhY2s9ZTpPPT09SihMKSYmSyhMKTtUKGIpfWVsc2UgSyhMKTtPPUooTCl9aWYobnVsbCE9PU8pdmFyIG09ITA7ZWxzZXt2YXIgbj1KKE0pO251bGwhPT1uJiZnKFUsbi5zdGFydFRpbWUtYik7bT0hMX1yZXR1cm4gbX1maW5hbGx5e089bnVsbCxQPWMsUT0hMX19dmFyIFc9aztleHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eT01O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtSfHxRfHwoUj0hMCxmKFYpKX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbD1mdW5jdGlvbigpe3JldHVybiBQfTtleHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIEooTCl9O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaChQKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj1QfXZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7UD1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ9VztleHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eT1mdW5jdGlvbihhLGIpe3N3aXRjaChhKXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmJyZWFrO2RlZmF1bHQ6YT0zfXZhciBjPVA7UD1hO3RyeXtyZXR1cm4gYigpfWZpbmFsbHl7UD1jfX07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yz8oYz1jLmRlbGF5LGM9XCJudW1iZXJcIj09PXR5cGVvZiBjJiYwPGM/ZCtjOmQpOmM9ZDtzd2l0Y2goYSl7Y2FzZSAxOnZhciBlPS0xO2JyZWFrO2Nhc2UgMjplPTI1MDticmVhaztjYXNlIDU6ZT0xMDczNzQxODIzO2JyZWFrO2Nhc2UgNDplPTFFNDticmVhaztkZWZhdWx0OmU9NUUzfWU9YytlO2E9e2lkOk4rKyxjYWxsYmFjazpiLHByaW9yaXR5TGV2ZWw6YSxzdGFydFRpbWU6YyxleHBpcmF0aW9uVGltZTplLHNvcnRJbmRleDotMX07Yz5kPyhhLnNvcnRJbmRleD1jLEgoTSxhKSxudWxsPT09SihMKSYmYT09PUooTSkmJihTP2goKTpTPSEwLGcoVSxjLWQpKSk6KGEuc29ydEluZGV4PWUsSChMLGEpLFJ8fFF8fChSPSEwLGYoVikpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1QO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPVA7UD1iO3RyeXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluYWxseXtQPWN9fX07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NjaGVkdWxlci9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NjaGVkdWxlci90cmFjaW5nLmpzIiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcbiAgJ3VzZScsXG4gICdvbicsXG4gICdvbmNlJyxcbiAgJ3NldCcsXG4gICdxdWVyeScsXG4gICd0eXBlJyxcbiAgJ2FjY2VwdCcsXG4gICdhdXRoJyxcbiAgJ3dpdGhDcmVkZW50aWFscycsXG4gICdzb3J0UXVlcnknLFxuICAncmV0cnknLFxuICAnb2snLFxuICAncmVkaXJlY3RzJyxcbiAgJ3RpbWVvdXQnLFxuICAnYnVmZmVyJyxcbiAgJ3NlcmlhbGl6ZScsXG4gICdwYXJzZScsXG4gICdjYScsXG4gICdrZXknLFxuICAncGZ4JyxcbiAgJ2NlcnQnLFxuICAnZGlzYWJsZVRMU0NlcnRzJ1xuXS5mb3JFYWNoKChmbikgPT4ge1xuICAvLyBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnRcbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMucHVzaCh7IGZuLCBhcmdzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5fc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAocmVxKSB7XG4gIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goKGRlZikgPT4ge1xuICAgIHJlcVtkZWYuZm5dKC4uLmRlZi5hcmdzKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL3NyYy9hZ2VudC1iYXNlLmpzIiwiLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RCYXNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3RCYXNlKG9iamVjdCkge1xuICBpZiAob2JqZWN0KSByZXR1cm4gbWl4aW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqZWN0KSB7XG4gIGZvciAoY29uc3Qga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVxdWVzdEJhc2UucHJvdG90eXBlLCBrZXkpKVxuICAgICAgb2JqZWN0W2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3VwbG9hZFRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICBkZWxldGUgdGhpcy5fdXBsb2FkVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKiAtIHVwbG9hZCBpcyB0aGUgdGltZSAgc2luY2UgbGFzdCBiaXQgb2YgZGF0YSB3YXMgc2VudCBvciByZWNlaXZlZC4gVGhpcyB0aW1lb3V0IHdvcmtzIG9ubHkgaWYgZGVhZGxpbmUgdGltZW91dCBpcyBvZmZcbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgdGhpcy5fdXBsb2FkVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pKSB7XG4gICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1cGxvYWQnOlxuICAgICAgICAgIHRoaXMuX3VwbG9hZFRpbWVvdXQgPSBvcHRpb25zLnVwbG9hZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Vua25vd24gdGltZW91dCBvcHRpb24nLCBvcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiAoY291bnQsIGZuKSB7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIE5PVEU6IHdlIGRvIG5vdCBpbmNsdWRlIEVTT0NLRVRUSU1FRE9VVCBiZWNhdXNlIHRoYXQgaXMgZnJvbSBgcmVxdWVzdGAgcGFja2FnZVxuLy8gICAgICAgPGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZ290L3B1bGwvNTM3PlxuLy9cbi8vIE5PVEU6IHdlIGRvIG5vdCBpbmNsdWRlIEVBRERSSU5GTyBiZWNhdXNlIGl0IHdhcyByZW1vdmVkIGZyb20gbGlidXYgaW4gMjAxNFxuLy8gICAgICAgPGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ1di9saWJ1di9jb21taXQvMDJlMWViZDQwYjgwN2JlNWFmNDYzNDNlYTg3MzMzMWIyZWU0ZTljMT5cbi8vICAgICAgIDxodHRwczovL2dpdGh1Yi5jb20vcmVxdWVzdC9yZXF1ZXN0L3NlYXJjaD9xPUVTT0NLRVRUSU1FRE9VVCZ1bnNjb3BlZF9xPUVTT0NLRVRUSU1FRE9VVD5cbi8vXG4vL1xuLy8gVE9ETzogZXhwb3NlIHRoZXNlIGFzIGNvbmZpZ3VyYWJsZSBkZWZhdWx0c1xuLy9cbmNvbnN0IEVSUk9SX0NPREVTID0gbmV3IFNldChbXG4gICdFVElNRURPVVQnLFxuICAnRUNPTk5SRVNFVCcsXG4gICdFQUREUklOVVNFJyxcbiAgJ0VDT05OUkVGVVNFRCcsXG4gICdFUElQRScsXG4gICdFTk9URk9VTkQnLFxuICAnRU5FVFVOUkVBQ0gnLFxuICAnRUFJX0FHQUlOJ1xuXSk7XG5cbmNvbnN0IFNUQVRVU19DT0RFUyA9IG5ldyBTZXQoW1xuICA0MDgsXG4gIDQxMyxcbiAgNDI5LFxuICA1MDAsXG4gIDUwMixcbiAgNTAzLFxuICA1MDQsXG4gIDUyMSxcbiAgNTIyLFxuICA1MjRcbl0pO1xuXG4vLyBUT0RPOiB3ZSB3b3VsZCBuZWVkIHRvIG1ha2UgdGhpcyBlYXNpbHkgY29uZmlndXJhYmxlIGJlZm9yZSBhZGRpbmcgaXQgaW4gKGUuZy4gc29tZSBtaWdodCB3YW50IHRvIGFkZCBQT1NUKVxuLy8gY29uc3QgTUVUSE9EUyA9IG5ldyBTZXQoWydHRVQnLCAnUFVUJywgJ0hFQUQnLCAnREVMRVRFJywgJ09QVElPTlMnLCAnVFJBQ0UnXSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2dvdCNyZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgYW4gZXJyb3JcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdIHJlc3BvbnNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaWYgc2VnbWVudCBzaG91bGQgYmUgcmV0cmllZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlID0gdGhpcy5fcmV0cnlDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoIChlcnJfKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycl8pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IHdlIHdvdWxkIG5lZWQgdG8gbWFrZSB0aGlzIGVhc2lseSBjb25maWd1cmFibGUgYmVmb3JlIGFkZGluZyBpdCBpbiAoZS5nLiBzb21lIG1pZ2h0IHdhbnQgdG8gYWRkIFBPU1QpXG4gIC8qXG4gIGlmIChcbiAgICB0aGlzLnJlcSAmJlxuICAgIHRoaXMucmVxLm1ldGhvZCAmJlxuICAgICFNRVRIT0RTLmhhcyh0aGlzLnJlcS5tZXRob2QudG9VcHBlckNhc2UoKSlcbiAgKVxuICAgIHJldHVybiBmYWxzZTtcbiAgKi9cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIFNUQVRVU19DT0RFUy5oYXMocmVzLnN0YXR1cykpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIEVSUk9SX0NPREVTLmhhcyhlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuICAgIC8vIFN1cGVyYWdlbnQgdGltZW91dFxuICAgIGlmIChlcnIudGltZW91dCAmJiBlcnIuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyeSByZXF1ZXN0XG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dEVycm9yID0gbnVsbDtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNlbGYub24oJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fbWF4UmV0cmllcyAmJiB0aGlzLl9tYXhSZXRyaWVzID4gdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRpbWVkb3V0ICYmIHRoaXMudGltZWRvdXRFcnJvcikge1xuICAgICAgICAgIHJlamVjdCh0aGlzLnRpbWVkb3V0RXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICBlcnIuY29kZSA9ICdBQk9SVEVEJztcbiAgICAgICAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gICAgICAgIGVyci51cmwgPSB0aGlzLnVybDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuZW5kKChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgcmVxdWlyZWQnKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24gKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgZGVwcmVjYXRlZCBpbnRlcm5hbCBBUEkuIFVzZSBgLmdldChmaWVsZClgIGluc3RlYWQuXG4gKlxuICogKGdldEhlYWRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzdXBlcmFnZW50IGNvZGUgYmFzZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZpZWxkLCBrZXkpKVxuICAgICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGQgZmllbGQgbmFtZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lIG5hbWUgb2YgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsIHZhbHVlIG9mIGZpZWxkXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobmFtZSA9PT0gbnVsbCB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCJcbiAgICApO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuYW1lLCBrZXkpKVxuICAgICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaSkpXG4gICAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsdWVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdW5kZWZpbmVkID09PSB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgfVxuXG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIGlmICh0aGlzLnhocikgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICBpZiAodGhpcy5yZXEpIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmFzaWMgJHtiYXNlNjRFbmNvZGVyKGAke3VzZXJ9OiR7cGFzc31gKX1gKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7dXNlcn1gKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGhpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbiBudW1iZXIgb2YgYnl0ZXNcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGlzT2JqZWN0XyA9IGlzT2JqZWN0KGRhdGEpO1xuICBsZXQgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIlxuICAgICk7XG4gIH1cblxuICBpZiAoaXNPYmplY3RfICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmplY3RfICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKVxuICAgICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAodHlwZSkgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgaWYgKHR5cGUgPT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YSA/IGAke3RoaXMuX2RhdGF9JiR7ZGF0YX1gIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iamVjdF8gfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbiAoc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gKHRoaXMudXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cblxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3QgcXVlcnlBcnJheSA9IHRoaXMudXJsLnNsaWNlKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fc29ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBxdWVyeUFycmF5LnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFycmF5LnNvcnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zbGljZSgwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFycmF5LmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSAoKSA9PiB7XG4gIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQnKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uIChyZWFzb24sIHRpbWVvdXQsIGVycm5vKSB7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke3JlYXNvbiArIHRpbWVvdXR9bXMgZXhjZWVkZWRgKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMudGltZWRvdXRFcnJvciA9IGVycjtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG5cbiAgLy8gcmVzcG9uc2UgdGltZW91dFxuICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0ICYmICF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoXG4gICAgICAgICdSZXNwb25zZSB0aW1lb3V0IG9mICcsXG4gICAgICAgIHNlbGYuX3Jlc3BvbnNlVGltZW91dCxcbiAgICAgICAgJ0VUSU1FRE9VVCdcbiAgICAgICk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvcmVxdWVzdC1iYXNlLmpzIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFJlc3BvbnNlQmFzZS5wcm90b3R5cGUsIGtleSkpXG4gICAgICBvYmpba2V5XSA9IFJlc3BvbnNlQmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gIC8vIFRPRE86IG1vYXIhXG4gIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAvLyBjb250ZW50LXR5cGVcbiAgY29uc3QgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAvLyBwYXJhbXNcbiAgY29uc3QgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGtleSkpXG4gICAgICB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgfVxuXG4gIHRoaXMubGlua3MgPSB7fTtcblxuICAvLyBsaW5rc1xuICB0cnkge1xuICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlXG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgY29uc3QgdHlwZSA9IChzdGF0dXMgLyAxMDApIHwgMDtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlO1xuICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gIC8vIGJhc2ljc1xuICB0aGlzLmluZm8gPSB0eXBlID09PSAxO1xuICB0aGlzLm9rID0gdHlwZSA9PT0gMjtcbiAgdGhpcy5yZWRpcmVjdCA9IHR5cGUgPT09IDM7XG4gIHRoaXMuY2xpZW50RXJyb3IgPSB0eXBlID09PSA0O1xuICB0aGlzLnNlcnZlckVycm9yID0gdHlwZSA9PT0gNTtcbiAgdGhpcy5lcnJvciA9IHR5cGUgPT09IDQgfHwgdHlwZSA9PT0gNSA/IHRoaXMudG9FcnJvcigpIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5jcmVhdGVkID0gc3RhdHVzID09PSAyMDE7XG4gIHRoaXMuYWNjZXB0ZWQgPSBzdGF0dXMgPT09IDIwMjtcbiAgdGhpcy5ub0NvbnRlbnQgPSBzdGF0dXMgPT09IDIwNDtcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gc3RhdHVzID09PSA0MDA7XG4gIHRoaXMudW5hdXRob3JpemVkID0gc3RhdHVzID09PSA0MDE7XG4gIHRoaXMubm90QWNjZXB0YWJsZSA9IHN0YXR1cyA9PT0gNDA2O1xuICB0aGlzLmZvcmJpZGRlbiA9IHN0YXR1cyA9PT0gNDAzO1xuICB0aGlzLm5vdEZvdW5kID0gc3RhdHVzID09PSA0MDQ7XG4gIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IHN0YXR1cyA9PT0gNDIyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvcmVzcG9uc2UtYmFzZS5qcyIsIi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSAoc3RyKSA9PiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJhbXMgPSAodmFsKSA9PiB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IHN0ciBvZiB2YWwuc3BsaXQoLyAqOyAqLykpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgICBjb25zdCBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIGNvbnN0IHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gKHZhbCkgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcbiAgZm9yIChjb25zdCBzdHIgb2YgdmFsLnNwbGl0KC8gKiwgKi8pKSB7XG4gICAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gICAgY29uc3QgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIGNvbnN0IHJlbCA9IHBhcnRzWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsIC0xKTtcbiAgICBvYmpbcmVsXSA9IHVybDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IChoZWFkZXIsIGNoYW5nZXNPcmlnaW4pID0+IHtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXIuaG9zdDtcbiAgLy8gc2VjdWlydHlcbiAgaWYgKGNoYW5nZXNPcmlnaW4pIHtcbiAgICBkZWxldGUgaGVhZGVyLmF1dGhvcml6YXRpb247XG4gICAgZGVsZXRlIGhlYWRlci5jb29raWU7XG4gIH1cblxuICByZXR1cm4gaGVhZGVyO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9zcmMvdXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N1cGVyYWdlbnQvfi9xcy9saWIvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcbiAgICBjaGFyc2V0U2VudGluZWw6IGZhbHNlLFxuICAgIGNvbW1hOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgaWdub3JlUXVlcnlQcmVmaXg6IGZhbHNlLFxuICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogZmFsc2UsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgcGFyc2VBcnJheXM6IHRydWUsXG4gICAgcGxhaW5PYmplY3RzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uICgkMCwgbnVtYmVyU3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcbiAgICB9KTtcbn07XG5cbnZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmNvbW1hICYmIHZhbC5pbmRleE9mKCcsJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdmFsLnNwbGl0KCcsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGJvZHkgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgcGFnZSBjb250YWluaW5nXG4vLyB0aGUgZm9ybSBpcyBpc28tODg1OS0xLCBvciB3aGVuIHRoZSBzdWJtaXR0ZWQgZm9ybSBoYXMgYW4gYWNjZXB0LWNoYXJzZXRcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG4vLyB0aGUg4pyTIGNoYXJhY3Rlciwgc3VjaCBhcyB1cy1hc2NpaS5cbnZhciBpc29TZW50aW5lbCA9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpXG5cbi8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxudmFyIGNoYXJzZXRTZW50aW5lbCA9ICd1dGY4PSVFMiU5QyU5Myc7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcbiAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuICAgIHZhciBza2lwSW5kZXggPSAtMTsgLy8gS2VlcCB0cmFjayBvZiB3aGVyZSB0aGUgdXRmOCBzZW50aW5lbCB3YXMgZm91bmRcbiAgICB2YXIgaTtcblxuICAgIHZhciBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0O1xuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCd1dGY4PScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09PSBjaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICd1dGYtOCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gaXNvU2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICdpc28tODg1OS0xJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpID0gcGFydHMubGVuZ3RoOyAvLyBUaGUgZXNsaW50IHNldHRpbmdzIGRvIG5vdCBhbGxvdyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA9PT0gc2tpcEluZGV4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIHZhciBicmFja2V0RXF1YWxzUG9zID0gcGFydC5pbmRleE9mKCddPScpO1xuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xuXG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHZhbCA9IHV0aWxzLm1heWJlTWFwKFxuICAgICAgICAgICAgICAgIHBhcnNlQXJyYXlWYWx1ZShwYXJ0LnNsaWNlKHBvcyArIDEpLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZW5jb2RlZFZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZWNvZGVyKGVuY29kZWRWYWwsIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsICYmIG9wdGlvbnMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzICYmIGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xuICAgICAgICAgICAgdmFsID0gaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzKHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydC5pbmRleE9mKCdbXT0nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWwgPSBpc0FycmF5KHZhbCkgPyBbdmFsXSA6IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdXRpbHMuY29tYmluZShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICB2YXIgbGVhZiA9IHZhbHVlc1BhcnNlZCA/IHZhbCA6IHBhcnNlQXJyYXlWYWx1ZSh2YWwsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScgJiYgb3B0aW9ucy5wYXJzZUFycmF5cykge1xuICAgICAgICAgICAgb2JqID0gW10uY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBjbGVhblJvb3QgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5cyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG9wdGlvbnMuZGVwdGggPiAwICYmIChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpO1xufTtcblxudmFyIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5kZWNvZGVyICE9PSBudWxsICYmIG9wdHMuZGVjb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRzLmRlY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGVjb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIHZhciBjaGFyc2V0ID0gdHlwZW9mIG9wdHMuY2hhcnNldCA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5jaGFyc2V0IDogb3B0cy5jaGFyc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cyxcbiAgICAgICAgYWxsb3dQcm90b3R5cGVzOiB0eXBlb2Ygb3B0cy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdHMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzLFxuICAgICAgICBhcnJheUxpbWl0OiB0eXBlb2Ygb3B0cy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMuYXJyYXlMaW1pdCA6IGRlZmF1bHRzLmFycmF5TGltaXQsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgY29tbWE6IHR5cGVvZiBvcHRzLmNvbW1hID09PSAnYm9vbGVhbicgPyBvcHRzLmNvbW1hIDogZGVmYXVsdHMuY29tbWEsXG4gICAgICAgIGRlY29kZXI6IHR5cGVvZiBvcHRzLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvbiwgbm8tZXh0cmEtcGFyZW5zXG4gICAgICAgIGRlcHRoOiAodHlwZW9mIG9wdHMuZGVwdGggPT09ICdudW1iZXInIHx8IG9wdHMuZGVwdGggPT09IGZhbHNlKSA/ICtvcHRzLmRlcHRoIDogZGVmYXVsdHMuZGVwdGgsXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxuICAgICAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IHR5cGVvZiBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgOiBkZWZhdWx0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMsXG4gICAgICAgIHBhcmFtZXRlckxpbWl0OiB0eXBlb2Ygb3B0cy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQsXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcbiAgICAgICAgcGxhaW5PYmplY3RzOiB0eXBlb2Ygb3B0cy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdHMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzLFxuICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHR5cGVvZiBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmdcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuY29tcGFjdChvYmopO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc3VwZXJhZ2VudC9+L3FzL2xpYi9wYXJzZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xudmFyIHB1c2hUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsdWVPckFycmF5KSB7XG4gICAgcHVzaC5hcHBseShhcnIsIGlzQXJyYXkodmFsdWVPckFycmF5KSA/IHZhbHVlT3JBcnJheSA6IFt2YWx1ZU9yQXJyYXldKTtcbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdEZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBjaGFyc2V0OiAndXRmLTgnLFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXQsXG4gICAgZm9ybWF0dGVyOiBmb3JtYXRzLmZvcm1hdHRlcnNbZGVmYXVsdEZvcm1hdF0sXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGluZGljZXM6IGZhbHNlLFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcbiAgICB9LFxuICAgIHNraXBOdWxsczogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzTm9uTnVsbGlzaFByaW1pdGl2ZSh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdib29sZWFuJ1xuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ3N5bWJvbCdcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnO1xufTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXRcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2NvbW1hJyAmJiBpc0FycmF5KG9iaikpIHtcbiAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknKSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknKTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJykpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXM7XG4gICAgaWYgKGlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5UHJlZml4ID0gaXNBcnJheShvYmopXG4gICAgICAgICAgICA/IHR5cGVvZiBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnZnVuY3Rpb24nID8gZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSkgOiBwcmVmaXhcbiAgICAgICAgICAgIDogcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyk7XG5cbiAgICAgICAgcHVzaFRvQXJyYXkodmFsdWVzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGtleVByZWZpeCxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgY2hhcnNldFxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmVuY29kZXIgIT09IG51bGwgJiYgb3B0cy5lbmNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNoYXJzZXQgIT09ICd1bmRlZmluZWQnICYmIG9wdHMuY2hhcnNldCAhPT0gJ3V0Zi04JyAmJiBvcHRzLmNoYXJzZXQgIT09ICdpc28tODg1OS0xJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFoYXMuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IG9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICB2YXIgZmlsdGVyID0gZGVmYXVsdHMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheShvcHRzLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0cy5maWx0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXG4gICAgICAgIGVuY29kZTogdHlwZW9mIG9wdHMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZSxcbiAgICAgICAgZW5jb2RlcjogdHlwZW9mIG9wdHMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXIsXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXG4gICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgICAgICAgc2VyaWFsaXplRGF0ZTogdHlwZW9mIG9wdHMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcbiAgICAgICAgc29ydDogdHlwZW9mIG9wdHMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuc29ydCA6IG51bGwsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyhvcHRzKTtcblxuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRzICYmIG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgJ2luZGljZXMnIGluIG9wdHMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcE51bGxzLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICBvcHRpb25zLnNvcnQsXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICBpZiAob3B0aW9ucy5jaGFyc2V0U2VudGluZWwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JyksIHRoZSBcIm51bWVyaWMgZW50aXR5XCIgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja21hcmtcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdXBlcmFnZW50L34vcXMvbGliL3N0cmluZ2lmeS5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXG5pbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50J1xuXG5jbGFzcyBCQlNGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIGJvZHk6ICcnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lQ2hhbmdlZCAoZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtuYW1lOiBlLnRhcmdldC52YWx1ZX0pXG4gICAgfVxuXG4gICAgYm9keUNoYW5nZWQgKGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Ym9keTogZS50YXJnZXQudmFsdWV9KVxuICAgIH1cblxuICAgIHBvc3QoZSkge1xuICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAuZ2V0KCcvYXBpL3dyaXRlJylcbiAgICAgICAgICAgIC5xdWVyeSh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5zdGF0ZS5uYW1lLFxuICAgICAgICAgICAgICAgIGJvZHk6IHRoaXMuc3RhdGUuYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Ym9keTogJyd9KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uUG9zdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uUG9zdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdiBzdHlsZT17c3R5bGVzLmZvcm19PlxuICAgICAgICAgICAgICAgIOydtOumhDo8YnIgLz5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0ndGV4dCcgdmFsdWU9e3RoaXMuc3RhdGUubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gdGhpcy5uYW1lQ2hhbmdlZChlKX0gLz48YnIgLz5cbiAgICAgICAgICAgICAgICDrs7jrrLg6PGJyIC8+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9J3RleHQnIHZhbHVlPXt0aGlzLnN0YXRlLmJvZHl9IHNpemU9JzYwJ1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB0aGlzLmJvZHlDaGFuZ2VkKGUpfSAvPjxiciAvPlxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17ZSA9PiB0aGlzLnBvc3QoKX0+7KCE7IahPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuY2xhc3MgQkJTQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9ncygpXG4gICAgfVxuXG4gICAgbG9hZExvZ3MgKCkge1xuICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAuZ2V0KCcvYXBpL2dldEl0ZW1zJylcbiAgICAgICAgICAgIC5lbmQoKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtpdGVtczogZGF0YS5ib2R5LmxvZ3N9KVxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgICBjb25zdCBpdGVtc0h0bWwgPSB0aGlzLnN0YXRlLml0ZW1zLm1hcChlID0+IChcbiAgICAgICAgICAgIDxsaSBrZXk9e2UuX2lkfT57ZS5uYW1lfSAtIHtlLmJvZHl9PC9saT5cbiAgICAgICAgKSlcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8aDEgc3R5bGU9e3N0eWxlcy5oMX0+6rKM7Iuc7YyQPC9oMT5cbiAgICAgICAgICAgICAgICA8QkJTRm9ybSBvblBvc3Q9e2UgPT4gdGhpcy5sb2FkTG9ncygpfSAvPlxuICAgICAgICAgICAgICAgIDxwIHN0eWxlPXtzdHlsZXMucmlnaHR9PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2UgPT4gdGhpcy5sb2FkTG9ncygpIH0+XG4gICAgICAgICAgICAgICAgICAgICAgICDri6Tsi5wg67aI65+s7Jik6riwIDwvYnV0dG9uPjwvcD5cbiAgICAgICAgICAgICAgICAgICAgPHVsPntpdGVtc0h0bWx9PC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxufVxuXG5jb25zdCBzdHlsZXMgPSB7XG4gICAgaDE6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmx1ZScsXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICBmb250U2l6ZTogMjQsXG4gICAgICAgIHBhZGRpbmc6IDEyXG4gICAgfSxcblxuICAgIGZvcm06IHtcbiAgICAgICAgcGFkZGluZzogMTIsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCBzaWx2ZXInLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjRjBGMEYwJ1xuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgICAgdGV4dEFsaWduOiAncmlnaHQnXG4gICAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoXG4gICAgPEJCU0FwcCAvPixcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9